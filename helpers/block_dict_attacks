#!/bin/bash

# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/
[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../")

source "$M_ROOT/lib/functions.sh"
LOG="$M_ROOT/logs/block_ip.log"

possible_options="file period maxlines maxinvalid method maxfail maxfailroot timeformat"
necessary_options=""

ARGV=`echo ${@} | sed 's/^--//' | sed 's/ --/|/g'`

IFS1=$IFS
IFS='|'
for s_option in $ARGV
do
  s_optname=${s_option%%=*}
  s_optname=`echo $s_optname | tr -d '-'`
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  for option in `echo $possible_options | sed 's/ /|/g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=1
  done
   if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

[ -z "$file" ] && echo "file is not defined" >&2 && exit 1
timeshift=`cat "$M_TEMP"/timeshift 2>/dev/null` || timeshift=10
freqdef=`expr $FREQ + $timeshift` || freqdef=210
[ -z "$period" ] && period="$freqdef sec"
[ -z "$maxlines" ] && maxlines=500
[ -z "$maxfail" ] && maxfail=5
[ -z "$maxfailroot" ] && maxfailroot=3
[ -z "$timeformat" ] && timeformat="%b %d %H:%M:%S"

logged=`"$M_ROOT"/helpers/logreader --file=$file --timeformat="$timeformat" --maxlines=$maxlines --period=$period`

userfails=`echo "$logged" | grep "Invalid\\ user"`
rootfails=`echo "$logged" | grep "Failed\\ password\\ for\\ root"`
loginbykey=`echo "$logged" | grep "Accepted\\ publickey\\ for"`
loginbypass=`echo "$logged" | grep "Accepted\\ password\\ for"`

if [ -n "$loginbykey" ]; then
  echo -e "Successful logins using key authentication:\n--------------------------------------------\n"
  echo "$loginbykey" | grep -oE "for\ .*\ from\ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}" | cut -d ' ' -f2,3,4
fi
if [ -n "$loginbypass" ]; then
  echo -e "Successful logins using password authentication:\n-------------------------------------------------\n"
  echo "$loginbypass" | grep -oE "for\ .*\ from\ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}" | cut -d ' ' -f2,3,4
fi

if [ -n "$rootfails" ]; then
  echo -e "Failed attempts to login as root:\n---------------------------------\n"
  rootfails=`echo "$rootfails" | grep -oE "from\ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}" | cut -d ' ' -f2 | sort | uniq -c | sed 's|^ *||' | tr ' ' '|'`
  for ip in `echo "$rootfails"` ; do
    ipaddr=`echo "$ip" | cut -d'|' -f2`
    invalid=`echo "$ip" | cut -d'|' -f1`
    echo -n "${ipaddr}: $invalid attempts"
    [ `expr "$invalid" : .*[^0-9].*` -ne 0 ] && log "wrong invalid user number for IP $ip" && continue
    previnvalid=`grep \|${ip}$ "$M_TEMP"/dict.attacks.tmp`
    if [ -z "$previnvalid" ]; then
      if [ $invalid -ge $maxfailroot ]; then
        echo ", blocking"
        echo "$ipaddr" | "$M_ROOT"/helpers/block_ip - --method="$method" --block_forever_after=0 && sed -i "/|${previnvalid}$/d" "$M_TEMP"/dict.attacks.tmp
      else
        echo "$ip" >> "$M_TEMP"/dict.attacks.tmp
      fi
    else
      nowinvalid=`expr $previnvalid + $invalid 2>/dev/null`
      if [ -n "$nowinvalid" ]; then
        if [ $nowinvalid -ge $maxfailroot ]; then
          echo ", $nowinvalid total, max ${maxfailroot}, blocking"
          echo "$ipaddr" | "$M_ROOT"/helpers/block_ip - --method=DROP --block_forever_after=0 && sed -i "/|${previnvalid}$/d" "$M_TEMP"/dict.attacks.tmp
        else
          echo ", $nowinvalid total, max ${maxfailroot}, not blocking yet"
          sed -i "/$previnvalid/s/^[0-9]*|/${nowinvalid}|/" "$M_TEMP"/dict.attacks.tmp
        fi
      else
        log "error in expression previnvalid + invalid ($previnvalid + $invalid)"
      fi
    fi
  done
fi

if [ -n "$userfails" ]; then
  echo -e "Attempts to login as non-existing user:\n---------------------------------------\n"
  userfails=`echo "$userfails" | grep -oE "from\ [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}" | cut -d ' ' -f2 | sort | uniq -c | sed 's|^ *||' | tr ' ' '|'`
  for ip in `echo "$userfails"` ; do
    ipaddr=`echo "$ip" | cut -d'|' -f2`
    invalid=`echo "$ip" | cut -d'|' -f1`
    echo -n "${ipaddr}: $invalid attempts"
    [ `expr "$invalid" : .*[^0-9].*` -ne 0 ] && log "wrong invalid user number for IP $ip" && continue
    previnvalid=`grep \|${ip}$ "$M_TEMP"/dict.attacks.tmp`
    if [ -z "$previnvalid" ]; then
      if [ $invalid -ge $maxfail ]; then
        echo ", blocking"
        echo "$ipaddr" | "$M_ROOT"/helpers/block_ip - --method="$method" --block_forever_after=0 && sed -i "/|${previnvalid}$/d" "$M_TEMP"/dict.attacks.tmp
      else
        echo "$ip" >> "$M_TEMP"/dict.attacks.tmp
      fi
    else
      nowinvalid=`expr $previnvalid + $invalid 2>/dev/null`
      if [ -n "$nowinvalid" ]; then
        if [ $nowinvalid -ge $maxfail ]; then
          echo ", $nowinvalid total, max ${maxfail}, blocking"
          echo "$ipaddr" | "$M_ROOT"/helpers/block_ip - --method=DROP --block_forever_after=0 && sed -i "/|${previnvalid}$/d" "$M_TEMP"/dict.attacks.tmp
        else
          echo ", $nowinvalid total, max ${maxfail}, not blocking yet"
          sed -i "/$previnvalid/s/^[0-9]*|/${nowinvalid}|/" "$M_TEMP"/dict.attacks.tmp
        fi
      else
        log "error in expression previnvalid + invalid ($previnvalid + $invalid)"
      fi
    fi
  done
fi



