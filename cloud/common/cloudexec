#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


rcommand=${0##*/}
rpath=${0%/*}
#*/

[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../../")
source "$M_ROOT/conf/mon.conf" || exit 99
if [ -n "$CLOUD" ]; then
  source "$M_ROOT/conf/clouds/${CLOUD}.conf" || exit 99
fi

SSH=`which ssh 2>/dev/null`
[ -z "$SSH" ] && echo "ssh utility not found, exiting" && exit 1
[ -n "$SSHPORT" ] || SSHPORT=22
[ -n "$CONNECT_TIMEOUT" ] && TIMEOUT="-o ConnectTimeout=$CONNECT_TIMEOUT"
[ -f "/sbin/ifconfig" ] && IFCFG=/sbin/ifconfig || IFCFG=`which ifconfig 2>/dev/null`

cleanup() {
  if [ "x$threaded" == "xyes" ]; then
    for ((i=0; i<$n; i++)) ; do
      if [ -n "${pid[$n]}" ]; then
        [ -d /proc/${pid[$n]} ] && kill ${pid[$n]}
        sleep 1
        if [ -d /proc/${pid[$n]} ]; then
          sleep 10
          kill -6 ${pid[$n]} 2>/dev/null
        fi
        if [ -d /proc/${pid[$n]} ]; then
          sleep 3
          kill -9 ${pid[$n]} 2>/dev/null
        fi
        unset pid[$n] res[$n]
      fi
      [ -f "$M_TEMP/$$.$i" ] && cat "$M_TEMP/$$.$i" && rm -f "$M_TEMP/$$.$i"
    done
  fi
}

remote_exec() {
  if [ "X$verbose" == "Xyes" ] ; then
    NAME=`echo $server | cut -d'|' -f4`
    echo -e "\n=  Server: $NAME ($IP)  Cluster: $CLUSTER"
  fi
  if [ `echo $IP | grep -c "^$localip$"` -ne 0 ] ; then
    [ -z "$nolocalhost" ] && eval $command
  else
    KEY=`$M_ROOT/helpers/find_key server $IP`
    [ $? -ne 0 ] && echo "Key not found for IP $IP" && continue
    if [ "x$nosudo" == "xyes" ]; then
      $SSH $TIMEOUT -i "$KEY" -p $SSHPORT "$SSH_REMOTE_USER"@"$IP" \(test -e "$M_ROOT_REMOTE/m.rc" \&\& source "$M_ROOT_REMOTE/m.rc" \; export ip=$IP \; $command\)
    else
      $SSH $TIMEOUT -i "$KEY" -p $SSHPORT "$SSH_REMOTE_USER"@"$IP" \(test -e "$M_ROOT_REMOTE/m.rc" \&\& source "$M_ROOT_REMOTE/m.rc" \; export ip=$IP \; sudo $command\)
    fi
  fi
}

possible_options="cluster help region verbose limit ip nolocalhost user nosudo cloud threaded"
commflag=0
for s_option in "$@"
do
  case $s_option in
  --*=*)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`
      s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'`
    fi
    ;;
  --*)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
      s_optarg='yes'
    fi
    ;;
  *=*)
    commflag=1
    command="$command $s_option"
    ;;
  *)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      commflag=1
      command="$s_option"
    fi
    ;;
  esac
  for option in `echo $possible_options`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=$s_optarg"
  done
done
if [ "X$help" == "Xyes" ] ; then
  cat <<"EOF"
Usage: ${0##*/} <options> command

Executes command on remote servers. The list of servers is defined by either
command-line arguments or environment variables.

Any option can be passed as environment variable of the same name.

Options:

  --cloud=[cloud name]     - limits operations by this cloud. Multiple clouds
                             are allowed, separated by comma.
  --cluster=[cluster name] - the command will be executed on all servers
                             from this cluster. Multiple clusters are
                             allowed, separated by comma.
                             MUST be defined. To execute the command on all
                             servers, use --cluster=all. Accepts also M_CLUSTER
                             environment variable (used by msh).
  --all                    - shortcut for --cluster=all.
  --region=[region]        - the command will be executed on all servers from
                             this region.
  --ip=IP                  - executes the command on a single server. This
                             allows other scripts to include this one the
                             way that makes possible to apply it to a single
                             server or multiple servers depending on which
                             variables are defined. With this option non-empty,
                             cluster and region are ignored.
  --verbose                - shows each server details before running the
                             command.
  --limit=N                - executes the command on first N servers of each
                             cluster defined by the --cluster option
  --user=[username]        - connects to remote servers as user [username] and
                             executes all commands via sudo. Default user is
                             root.
  --nosudo                 - if user is defined, executes commands without sudo.
                             If user is not defined, does nothing.
  --threaded               - executes commands on multiple servers in parallel.

EOF
  exit 0
fi

trap cleanup EXIT

[ -n "$cloud" ] && CLOUD=$cloud
[ -z "$CLOUD" ] && CLOUD=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^#|^[[:space:]]#|^$" | cut -d'|' -f12 | sort | uniq | grep -v ^$`

for cld in $CLOUD ; do

  [ "X$IFCFG" != "X" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//' | grep -v '127.0.0.1'` || localip="ifconfig_not_found"
  if [ -n "$ip" ] ; then
    cluster= ; region=
    if [ `grep "|${cld}$" "$M_ROOT/servers.list" | grep -c "^$ip|"` -eq 0 ] ; then
      # if name passed as ip
      if [ `cat "$M_ROOT/servers.list" | cut -d'|' -f4 | grep -c "$ip"` -ne 1 ] ; then
        "$rpath"/find_server --cloud=$cld --ip=$ip --updatelist
        [ `grep "|${cld}$" "$M_ROOT/servers.list" | grep -c "^$ip|"` -eq 0 ] && "$rpath"/find_server --cloud=$cld --name=$name --updatelist
      fi
    fi
    # again
    if [ `grep "|${cld}$" "$M_ROOT/servers.list" | grep -c "^$ip|"` -eq 0 ] ; then
      # maybe name passed as ip
      if [ `cat "$M_ROOT/servers.list" | cut -d'|' -f4 | grep -c "$ip"` -ne 1 ] ; then
        echo "Unable to find $ip in cloud $cld"
        exit 1
      else
        ip=`cat "$M_ROOT/servers.list" | grep -vE "^#|^[[:space:]]#|^$" | grep "|${cld}$" | cut -d'|' -f1,4 | grep "|${ip}$" | cut -d'|' -f1`
        [ -z "$ip" ] && echo "Was unable to find IP by server name." && exit 1
      fi
    else
      # cluster is still needed in some cases
      server=`grep "|${cld}$" "$M_ROOT/servers.list" | grep "^$ip|"`
      cluster=`echo "$server" | cut -d'|' -f5`
      region=`echo "$server" | cut -d'|' -f3`
    fi
  fi

  [ -n "$all" ] && cluster=all
  [ -z "$cluster" ] && cluster=$M_CLUSTER
  [ -z "$cluster" ] && echo "No clusters found" && exit 1

  [ "$cluster" == "all" ] && clusters=`cat "$M_ROOT/servers.list" | grep "|${cld}$" | grep -v ^$ | grep -v  ^#|grep -v ^[[:space:]]*# | cut -d'|' -f5 | sort | uniq | grep -v "^${SUPER_CLUSTER}$"` || clusters=$cluster

  declare -i n
  IFS1=$IFS
  IFS='
  '
  [ -n "$verbose" ] && echo -e "### Cloud $cld\n    Command: $command"
  if [ -n "$command" ] ; then
    for icluster in `echo -e "${clusters}\n"|sed 's|,|\n|g'` ; do
      [ -n "$user" ] && SSH_REMOTE_USER="$user"
      [ -z "$SSH_REMOTE_USER" ] && SSH_REMOTE_USER=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^#|^[[:space:]]#|^$" | grep "^$cluster|" | cut -s -d'|' -f13`
      [ -z "$SSH_REMOTE_USER" ] && SSH_REMOTE_USER="root" && nosudo="yes"
      n=0
      unset CLUSTER KEY REGION NAME M_ROOT_REMOTE
      M_ROOT_REMOTE=`grep ^$icluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f8`
      
      for server in `cat "$M_ROOT/servers.list" | grep "|${cld}$" | grep -v ^$ | grep -v  ^#|grep -v ^[[:space:]]*#` ; do
        [ -n "$limit" ] && [[ $n -ge $limit ]] && break
        IP=${server%%|*}
        if [ -n "$ip" ] ; then
          [ "X$ip" == "X$IP" ] || continue
        fi
        if [ -n "$region" ] ; then
          REGION=`echo $server | cut -d'|' -f3`
          [ "X$REGION" == "X$region" ] || continue
        fi
        CLUSTER=`echo $server | cut -d'|' -f5`
        # if server's cluster is not found, it's a bug, but it's a good idea to
        # still show it in the output when --cluster=all
        if [ -z "$CLUSTER" ]; then
          [ "$cluster" == "all" ] || continue
        else
          [ "$CLUSTER" == "$icluster" ] || continue
        fi
        if [ "x$threaded" == "xyes" ]; then
          #res[$n]=$(remote_exec) 2>&1 </dev/null &
          remote_exec > "$M_TEMP/$$.$n" 2>&1 &
          pid[$n]=$!
        else
          remote_exec
        fi
        n+=1
      done
      if [ "x$threaded" == "xyes" ]; then
        for ((i=0; i<$n; i++)); do
          while true ; do
            # always waiting here, for forced exit see cleanup()
            while [ -d /proc/${pid[$i]} ]; do
              sleep 1
            done
            cat "$M_TEMP/$$.$i" && rm -f "$M_TEMP/$$.$i"
            unset pid[$i]
            break
          done
        done
      fi
    done
  fi
  IFS=$IFS1

done


