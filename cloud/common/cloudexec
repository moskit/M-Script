#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


rcommand=${0##*/}
rpath=${0%/*}
#*/

[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../../")
source "$M_ROOT/conf/mon.conf" || exit 99
if [ -n "$CLOUD" ]; then
  source "$M_ROOT/conf/clouds/${CLOUD}.conf" || exit 99
fi

SSH=`which ssh 2>/dev/null`
[ -z "$SSH" ] && echo "ssh utility not found, exiting" && exit 1
[ -n "$SSHPORT" ] || SSHPORT=22
[ -n "$CONNECT_TIMEOUT" ] && TIMEOUT="-o ConnectTimeout=$CONNECT_TIMEOUT"
[ -f "/sbin/ifconfig" ] && IFCFG=/sbin/ifconfig || IFCFG=`which ifconfig 2>/dev/null`
possible_options="cluster help region verbose limit ip nolocalhost user nosudo cloud"
commflag=0
for s_option in "$@"
do
  case $s_option in
  --*=*)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`
      s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'`
    fi
    ;;
  --*)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
      s_optarg='yes'
    fi
    ;;
  *=*)
    commflag=1
    command="$command $s_option"
    ;;
  *)
    if [ "$commflag" == "1" ] ; then
      command="$command $s_option"
    else
      commflag=1
      command="$s_option"
    fi
    ;;
  esac
  for option in `echo $possible_options`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=$s_optarg"
  done
done
if [ "X$help" == "Xyes" ] ; then
  cat <<"EOF"
Usage: ${0##*/} <options> command

Executes command on remote servers. The list of servers is defined by either
command-line arguments or environment variables.

Any option can be passed as environment variable of the same name.

Options:

  --cloud=[cloud name]     - limits operations by this cloud. Multiple clouds
                             are allowed, separated by comma.
  --cluster=[cluster name] - the command will be executed on all servers
                             from this cluster. Multiple clusters are
                             allowed, separated by comma.
                             MUST be defined. To execute the command on all
                             servers, use --cluster=all. Accepts also M_CLUSTER
                             environment variable (used by msh).
  --all                    - shortcut for --cluster=all.
  --region=[region]        - the command will be executed on all servers from
                             this region.
  --ip=IP                  - executes the command on a single server. This
                             allows other scripts to include this one the
                             way that makes possible to apply it to a single
                             server or multiple servers depending on which
                             variables are defined. With this option non-empty,
                             cluster and region are ignored.
  --verbose                - shows each server details before running the
                             command.
  --limit=N                - executes the command on first N servers of each
                             cluster defined by the --cluster option
  --user=[username]        - connects to remote servers as user [username] and
                             executes all commands via sudo. Username can also
                             be defined in conf/mon.conf (REMOTE_USER). Default
                             user is root.
  --nosudo                 - if user is defined, executes commands without sudo.
                             If user is not defined, does nothing.

EOF
  exit 0
fi

[ -n "$cloud" ] && CLOUD=$cloud
[ -z "$CLOUD" ] && CLOUD=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^#|^[[:space:]]#|^$" | cut -d'|' -f12 | sort | uniq | grep -v ^$`

for cld in $CLOUD ; do

  [ "X$IFCFG" != "X" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//' | grep -v '127.0.0.1'` || localip="ifconfig_not_found"
  if [ -n "$ip" ] ; then
    cluster= ; region=
    if [ `grep "|${cld}$" "$M_ROOT/servers.list" | grep -c "^$ip|"` -eq 0 ] ; then
      # if name passed as ip
      if [ `cat "$M_ROOT/servers.list" | cut -d'|' -f4 | grep -c "$ip"` -ne 1 ] ; then
        echo "Unable to find $ip in cloud $cld"
        exit 1
      else
        ip=`cat "$M_ROOT/servers.list" | grep -v ^$ | grep -v  ^#|grep -v ^[[:space:]]*# | grep "|${cld}$" | cut -d'|' -f1,4 | grep "|${ip}$" | cut -d'|' -f1`
        [ -z "$ip" ] && echo "Was unable to find IP by server name." && exit 1
      fi
    else
      # cluster is still needed in some cases
      server=`grep "|${cld}$" "$M_ROOT/servers.list" | grep "^$ip|"`
      cluster=`echo "$server" | cut -d'|' -f5`
      region=`echo "$server" | cut -d'|' -f3`
    fi
  fi

  [ -n "$all" ] && cluster=all
  [ -z "$cluster" ] && cluster=$M_CLUSTER
  [ -z "$cluster" ] && echo "No clusters found" && exit 1

  [ "x$cluster" == "xall" ] && clusters=`cat "$M_ROOT/servers.list" | grep "|${cld}$" | grep -v ^$ | grep -v  ^#|grep -v ^[[:space:]]*# | cut -d'|' -f5 | sort | uniq | grep -v "^${SUPER_CLUSTER}$"` || clusters=$cluster


  declare -i n
  IFS1=$IFS
  IFS='
  '
  [ -n "$verbose" ] && echo -e "### Cloud $cld\n    Command: $command"
  if [ "X$command" != "X" ] ; then
    for icluster in `echo -e "${clusters}\n"|sed 's|,|\n|g'` ; do
      [ -n "$user" ] && REMOTE_USER="$user"
      [ -z "$REMOTE_USER" ] && REMOTE_USER=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^#|^[[:space:]]#|^$" | grep "^$cluster|" | cut -d'|' -f13`
      [ -z "$REMOTE_USER" ] && REMOTE_USER="root" && nosudo="yes"
      n=0
      unset CLUSTER KEY REGION NAME M_ROOT_REMOTE
      M_ROOT_REMOTE=`grep ^$icluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f8`
      for server in `cat "$M_ROOT/servers.list" | grep "|${cld}$" | grep -v ^$ | grep -v  ^#|grep -v ^[[:space:]]*#` ; do
        [ -n "$limit" ] && [[ $n -ge $limit ]] && break
        IP=${server%%|*}
        if [ -n "$ip" ] ; then
          [ "X$ip" == "X$IP" ] || continue
        fi
        if [ -n "$region" ] ; then
          REGION=`echo $server | cut -d'|' -f3`
          [ "X$REGION" == "X$region" ] || continue
        fi
        CLUSTER=`echo $server | cut -d'|' -f5`
        # if server's cluster is not found, it's a bug, but it's a good idea to
        # still show it in the output when --cluster=all
        if [ -z "$CLUSTER" ]; then
          [ "$cluster" == "all" ] || continue
        else
          [ "$CLUSTER" == "$icluster" ] || continue
        fi
        if [ "X$verbose" == "Xyes" ] ; then
          NAME=`echo $server | cut -d'|' -f4`
          echo
          echo "=  Server: $NAME ($IP)  Cluster: $CLUSTER"
        fi
        if [ `echo $IP | grep -c "^$localip$"` -ne 0 ] ; then
          [ -z "$nolocalhost" ] && eval $command
        else
          KEY=`$M_ROOT/helpers/find_key server $IP`
          [ $? -ne 0 ] && echo "Key not found for IP $IP" && continue
          if [ "x$nosudo" == "xyes" ]; then
            $SSH $TIMEOUT -i "$KEY" -p $SSHPORT "$REMOTE_USER"@"$IP" \(test -e "$M_ROOT_REMOTE/m.rc" \&\& source "$M_ROOT_REMOTE/m.rc" \; $command\)
          else
            $SSH $TIMEOUT -i "$KEY" -p $SSHPORT "$REMOTE_USER"@"$IP" \(test -e "$M_ROOT_REMOTE/m.rc" \&\& source "$M_ROOT_REMOTE/m.rc" \; sudo $command\)
          fi
        fi
        n+=1
      done
    done
  fi
  IFS=$IFS1

done

