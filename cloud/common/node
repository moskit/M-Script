#!/bin/bash
# Copyright (C) 2015 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rpath=$(readlink -f "$BASH_SOURCE")
rcommand="${rpath##*/}"
rpath="${rpath%/*}"
[ -n "$M_ROOT" ] || M_ROOT=$(readlink -f "$rpath/../../")
#*/

printcol() {
  if [ -n "$1" ] ; then
    l=`expr $col - 1`
    str=`echo "$1" | cut -b 1-${l}`
    printf "%-${l}s" $str
  else
    printf "%${col}s"
  fi
}

find_clust() {
  clust=`echo -e "$cluster" | tr ',' '\n'`
  [ -z "$clust" ] && clust=$M_CLUSTER
  if [ -z "$clust" ] || [ "_$cluster" == "_all" ]; then
    clust=`cat "$M_ROOT/nodes.list" | grep "|${cld}$" | grep -vE '^$|^#|^[[:space:]]*#' | cut -d'|' -f5 | sort | uniq | grep -v "^${SUPER_CLUSTER}$"`
  fi
  [ -z "$clust" ] && echo "No clusters found" >&2 && return 1
  return 0
}

possible_commands="help list clone create save destroy show stop shutdown start boot reboot restart"
possible_subcommands="list:short,long,name,ip show:short,full"
possible_options="ip name role cluster flavor cloud"

declare -i ppn
ppn=1

commfound=false
subcommfound=false

IFS1=$IFS
IFS='-'
for s_option in "$@"
do
  found=false
  case $s_option in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'`
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes'
    ;;
  *=*)
    echo "Wrong syntax: options must start with a double dash"
    exit 1
    ;;
  *)
    s_param=$s_option
    s_optname=''
    s_optarg=''
    case $ppn in
      1)
        for comm in ${possible_commands// /-}; do
          if [ "_$s_param" == "_$comm" ]; then
            if $commfound ; then
              echo "Only one command can be executed!"
              echo "Commands are: $possible_commands"
              exit 1
            else
              found=true
              commfound=true
            fi
          fi
        done
        if ! $found ; then 
          echo "Unknown command: $s_param"
          exit 1
        fi
        command1=$s_param
        ;;
      2)
        for subcomm in ${possible_subcommands// /-}; do
          [ "_${subcomm%%:*}" == "_$command1" ] && subcommands=${subcomm#*:}
          for sub in ${subcommands//,/-}; do
            if [ "_$s_param" == "_$sub" ]; then
              if $subcommfound ; then
                echo "Only one subcommand can be executed!"
                echo "Subcommands for $command1 are: ${subcommands}"
                exit 1
              else
                found=true
                subcommfound=true
              fi
            fi
          done
          unset subcommands
        done
        if ! $found ; then 
          param1=$s_param
        else
          command2=$s_param
        fi
        ;;
      3)
        if [ -z "$param1" ] ; then
          param1=$s_param
        else
          param2=$s_param
        fi
        ;;
      4)
        if [ -z "$param2" ] ; then
          param2=$s_param
        else
          echo "Wrong number of positional parameters!"
          exit 1
        fi
        ;;
      *)
        echo "Wrong number of positional parameters!"
        exit 1
        ;;
    esac
    shift
    ppn+=1
    ;;
  esac
  for option in `echo $possible_options | sed 's| |-|g'`; do
    if [ "_$s_optname" == "_$option" ]; then
      if [ -n "$s_optarg" ]; then
        eval "$s_optname=\"$s_optarg\""
      else
        [ -z "$(eval echo \$$option)" ] && eval "$option="
      fi
      found=1
    fi
  done
done

if [ -n "$cloud" ]; then
  cloud=`echo -e "$cloud" | tr ',' '\n'`
  if [ "$cloud" == "all" ]; then
    cloud=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^$|^#|^[[:space:]]*#" | cut -d'|' -f12 | sort | uniq | grep -v ^$`
  fi
elif [ -n "$CLOUD" ]; then
  cloud=$CLOUD
else
  cloud=`cat "$M_ROOT/conf/clusters.conf" | grep -vE "^$|^#|^[[:space:]]*#" | cut -d'|' -f12 | sort | uniq | grep -v ^$`
fi

IFS='
'
case $command1 in
  list)
    if [ "_$command2" == "_long" ]; then
      COL=`tput cols`
      [ -n "$COL" ] && col=$((COL/4)) || col=20
      printcol "Node"
      printcol "IP"
      printcol "Cluster"
      echo "Cloud"
      printf "%${COL}s\n" | tr ' ' '-'
      
      for cld in $cloud ; do
        
        find_clust || continue

        for cl in `echo -e "$clust"` ; do
        
          nodes=`grep -E "\|$cl\|$cld$|\|$cl\|$cld\|$" "$M_ROOT"/nodes.list`
          
          for node in $nodes ; do
            nodeip=`echo "$node" | cut -d'|' -f1`
            nodename=`echo "$node" | cut -d'|' -f4`
            printcol "$nodename"
            printcol "$nodeip"
            printcol "$cl"
            echo "$cld"
          done
          
        done
        
      done
    else
      for cld in $cloud ; do
        
        find_clust || continue
        
        for cl in `echo -e "$clust"` ; do
          nodes=`grep -E "\|$cl\|$cld$|\|$cl\|$cld\|$" "$M_ROOT"/nodes.list`
          if [ -z "$command2" ] || [ "_$command2" == "_name" ]; then
            echo "$nodes" | cut -d'|' -f4 | grep -v ^$
          fi
          if [ "_$command2" == "_ip" ]; then
            echo "$nodes" | cut -d'|' -f1 | grep -v ^$
          fi
        done
      done
    fi
    ;;
  show)
    "$rpath"/get_node_details $@
    ;;
  create)
    "$rpath"/create_node $@
    ;;
  destroy)
    "$rpath"/destroy_node $@
    ;;
  save)
    "$rpath"/save_node $@
    ;;
  stop|shutdown)
    if [ -n "$ip" ]; then
      "$M_ROOT"/helpers/mssh $ip poweroff
      stopres=$?
    elif [ -n "$name" ]; then
      "$M_ROOT"/helpers/mssh $name poweroff
      stopres=$?
    else
      stopres=1
    fi
    if [ $stopres -eq 1 ]; then
      if [ -n "$id" ]; then
        "$M_ROOT"/cloud/common/stop_node --id=$id && exit 0
      elif [ -n "$ip" ]; then
        "$M_ROOT"/cloud/common/stop_node --id=$ip && exit 0
      elif [ -n "$name" ]; then
        "$M_ROOT"/cloud/common/stop_node --id=$name && exit 0
      fi
    fi
    ;;
  start|boot)
    if [ -n "$id" ]; then
      "$M_ROOT"/cloud/common/start_node --id=$id && exit 0
    elif [ -n "$ip" ]; then
      "$M_ROOT"/cloud/common/start_node --id=$ip && exit 0
    elif [ -n "$name" ]; then
      "$M_ROOT"/cloud/common/start_node --id=$name && exit 0
    fi
    # TODO find_by_id
    if [ -n "$ip" ] || [ -n "$name" ]; then
      sleep 10
      log "Waiting for node ${ip}${name} up..."
      waittimeout=1200
      waitperiod=10
      checks=`expr $waittimeout / $waitperiod`
      for ((i=1; i<$checks; i++)) ; do
        sleep $waitperiod
        "$M_ROOT"/helpers/mssh ${ip}${name} && break
      done
    fi
    ;;
  restart|reboot)
    if [ -n "$ip" ]; then
      "$M_ROOT"/helpers/mssh $ip reboot
      restartres=$?
    elif [ -n "$name" ]; then
      "$M_ROOT"/helpers/mssh $name reboot
      restartres=$?
    else
      restartres=1
    fi
    if [ $restartres -eq 1 ]; then
      if [ -n "$id" ]; then
        "$M_ROOT"/cloud/common/restart_node --id=$id && exit 0
      elif [ -n "$ip" ]; then
        "$M_ROOT"/cloud/common/restart_node --id=$ip && exit 0
      elif [ -n "$name" ]; then
        "$M_ROOT"/cloud/common/restart_node --id=$name && exit 0
      fi
    fi
    if [ -n "$ip" ] || [ -n "$name" ]; then
      sleep 10
      waittimeout=1200
      waitperiod=10
      checks=`expr $waittimeout / $waitperiod`
      for ((i=1; i<$checks; i++)) ; do
        sleep $waitperiod
        "$M_ROOT"/helpers/mssh ${ip}${name} && break
      done
    fi
    ;;
  *)
    echo "Command $command1 is not supported"
    ;;
esac

