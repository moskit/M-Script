#!/bin/bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../../")
#*/

CURL=`which curl 2>/dev/null`
[ -z "$CURL" ] && echo "Curl not found" && exit 1
LOG="$M_ROOT/logs/cloud.log"

debug=false

possible_options="cloud help region verbose cluster tag noupdate view update_nodes_list forceupdate all count resolveids name_source log_request"
necessary_options=""

if [ -n "$help" ]; then
  echo "Possible options: $possible_options"
fi

[ -n "$cloud" ] && CLOUD=$cloud
[ -z "$CLOUD" ] && echo "No cloud defined" && exit 1

source "$M_ROOT/conf/mon.conf"
source "$M_ROOT/conf/clouds/${CLOUD}.conf"
source "$M_ROOT/lib/functions.sh"
source "$M_ROOT/lib/cloud_functions.sh"
source "$rpath/functions.sh"
LOG="$M_ROOT/logs/cloud.log"
keep_response=true
[ -n "$name_source" ] && NAME_SOURCE=$name_source
[ -z "$NAME_SOURCE_FALLBACK" ] && NAME_SOURCE_FALLBACK=metadata
[ -z "$CLUSTER_TAG" ] && CLUSTER_TAG="cluster"
get_opts "$@"

export IAMACHILD M_TEMP CLOUD
lock_cloudops || exit 10

declare -i icount
[ -n "$forceupdate" ] && unset noupdate # for compatibility
if [ -n "$cluster" ]; then
  if [ "$cluster" == "all" ]; then
    unset M_CLUSTER
  fi
else
  [ -n "$M_CLUSTER" ] && cluster=$M_CLUSTER
fi

if [ -z "$region" ]; then
  region=`find_region`
  [ -z "$region" ] && region=$DEFAULT_REGION
  [ -z "$region" ] && echo "Region not defined!" >&2 && proper_exit 1 74
  log "searching nodes in region $region"
fi

HTTPMETHOD=GET
SERVICE=droplets
AUTHMETHOD=header

list_nodes() {
  [ "_$view" == "_raw" ] && echo "$reqparsed" && return
  declare -a nodelist
  IFSORIG=$IFS; IFS='
'
  nodes=`echo "$reqparsed" | grep -v "\/\"meta\"\/" | cut -sd'/' -f3-`
  for nodesn in `echo "$nodes" | cut -d'/' -f1 | sort -n | uniq` ; do
    nodeObj=`echo "$nodes" | grep "^$nodesn/"`
    if [ "_$NETWORK" == "_internal" ]; then
      nodeIP=`echo "$nodeObj" | readpath - $nodesn/networks/v4/0/ip_address "type|private"`
    else
      nodeIP=`echo "$nodeObj" | readpath - $nodesn/networks/v4/0/ip_address "type|public"`
    fi
    nodeName=`echo "$nodeObj" | readpath - $nodesn/name`
    if [ -n "$CLUSTER_TAG" ]; then
      nodeCluster=`echo "$nodeObj" | readpath - $nodesn/tags "${CLUSTER_TAG}:" | cut -sd':' -f2 | tail -1`
    elif [ -n "$CLUSTER_TAG_REGEXP" ]; then
      nodeCluster=`expr "$nodeName" : "$CLUSTER_TAG_REGEXP"`
    fi
    if [ -n "$nodeCluster" ]; then
      if [ `grep -c ^$nodeCluster\| "$M_ROOT/conf/clusters.conf"` -ne 0 ] ; then
        key=`grep ^$nodeCluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f2`
        [ "_$key" != "_$ikey" ] && log "Warning: key name from conf/clusters.conf ($key) for node $IP (name: $iname) doesn't match the one from node metadata ($ikey)" && key="$ikey"
        check_super_cluster $ip "$nodeCluster" && continue
        nodelist+=("$nodeIP|$key|$region|$nodeName|$nodeCluster|$CLOUD")
      fi
    fi
  done
  if [ -n "$cluster" ] && [ -z "$update_nodes_list" ]; then
    case $view in
    nodelist)
      if [ "$cluster" == "all" ]; then
        for ((i=0; i<${#nodelist[*]}; i++)); do echo "${nodelist[$i]}"; done
      else
        for ((i=0; i<${#nodelist[*]}; i++)); do echo "${nodelist[$i]}"; done | grep "|$cluster|$CLOUD$"
      fi
      ;;
    *)
      if [ "$cluster" == "all" ]; then
        for ((i=0; i<${#nodelist[*]}; i++)); do echo "${nodelist[$i]}"; done
      else
        for ((i=0; i<${#nodelist[*]}; i++)); do echo "${nodelist[$i]}"; done | grep "|$cluster|$CLOUD$"
      fi
      ;;
    esac
  fi
  if [ -n "$update_nodes_list" ]; then
    if [ ${#nodelist[*]} -eq 0 ]; then
      log "generated list is empty"
      echo -n > "$M_ROOT/cloud/nodes.list.${CLOUD}.${region}"
    else
      log "saving generated list (${#nodelist[*]} nodes)"
      for ((i=0; i<${#nodelist[*]}; i++)); do echo "${nodelist[$i]}"; done > "$M_ROOT/cloud/nodes.list.${CLOUD}.${region}"
    fi
  fi
  IFS=$IFSORIG
}

if [ -z "$noupdate" ]; then
  [ -n "$verbose" ] && log "sending request"
  reqparsed=`do_api_request $SERVICE $VERSION $AUTHMETHOD $HTTPMETHOD $region "" $qparams`
  echo "$reqparsed" > "$M_TEMP/cloud/$CLOUD/${rcommand}.resp"
  [ `echo "$reqparsed" | grep -v ^$ | wc -l` -eq 0 ] && log "parsed response to $rcommand is empty" && proper_exit 1 244
  [ `echo "$reqparsed" | grep -cvE "\/\"droplets\"\/|\/\"meta\"\/"` -ne 0 ] && log "request failed with error `echo "$reqparsed" | grep Error | cut -d'|' -f2`" && proper_exit 1 245
else
  # force update if the tmp file is older than FORCE_LIST_UPDATE_AFTER
  # if no setting, force update is disabled
  if [ -n "$FORCE_LIST_UPDATE_AFTER" ]; then
    tmpfileage=$(expr `date +"%s"` - `stat -c "%Z" "$M_TEMP/cloud/$CLOUD/${rcommand}.resp" || echo 0`)
    [ $tmpfileage -gt $FORCE_LIST_UPDATE_AFTER ] && unset noupdate
  fi
  [ -n "$verbose" ] && log "not sending request: noupdate is set, using existing data"
  [ ! -e "$M_TEMP/cloud/$CLOUD/${rcommand}.resp" ] && echo "No existing data found, run without --noupdate" && log "file $M_TEMP/cloud/$CLOUD/${rcommand}.resp not found" && proper_exit 1 245
  [ `cat "$M_TEMP/cloud/$CLOUD/${rcommand}.resp" | wc -l` -eq 0 ] && echo "No existing data found, run without --noupdate" && log "file $M_TEMP/cloud/$CLOUD/${rcommand}.resp is empty" && proper_exit 1 246
  reqparsed=`cat "$M_TEMP/cloud/$CLOUD/${rcommand}.resp"`
fi

list_nodes

[ -n "$count" ] && echo $icount
proper_exit 0 252




