#!/bin/bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


rcommand=${0##*/}
rpath=${0%/*}
[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../../")
#*/
DIFF=`which diff 2>/dev/null`
[ -z "$DIFF" ] && echo "Diff utility not found, exiting..  " && exit 1
SED=`which sed 2>/dev/null`
[ -z "$SED" ] && echo "Sed utility not found, exiting..  " && exit 1
SSH=`which ssh 2>/dev/null`
SSLEX=`which openssl 2>/dev/null`
CURL=`which curl 2>/dev/null`
CURL="$CURL -s"
[ -z "$SSH" ] && echo "Ssh utility not found, exiting..  " && exit 1
IFCFG=`which ifconfig 2>/dev/null`
# Normally needed for localhost only, and not always: depends on system.
# Hostnames of remote servers are obtained via ssh which is a login shell;
# this is why the variable below is not used for remote servers: you may
# have different OSes there with different paths to hostname utility.
HOSTNAME=`which hostname 2>/dev/null`

get_hostname() {
  [ -z "$1" ] && return 1
  if [ -f "${rpath}/../../keys/${keypair}.pem" ] ; then
    key=${keypair}.pem
  elif [ -f "${rpath}/../../keys/${keypair}" ] ; then
    key=${keypair}
  else
    message=" (key ${rpath}/../../keys/${keypair}{.pem} not found)"
  fi
  if [ `echo $localip | grep -c "^$1$"` -ne 0 ] ; then
    sname=`$HOSTNAME`
  else
    sname=`$SSH -i "$M_ROOT/keys/${key}" -o StrictHostKeyChecking=no -o ConnectionAttempts=1 -o ConnectTimeout=10 $1 hostname 2>/dev/null`
  fi
  [ `expr "$sname" : ".*[\"\t\s_,\.\']"` -ne 0 ] && unset sname
  [ "X$sname" == "X" ] && log "Unable to retrieve hostname of the server with IP $intIP|$extIP$message" && unset message && return 1
  return 0
}

request() {
  timestamp=`date +"%Y-%m-%dT%H%%3A%M%%3A%SZ"`
  Q=`echo -e "GET\nhttps://ec2.amazonaws.com\n/\nAWSAccessKeyId=${AWS_ACCESS_KEY_ID}&Action=DescribeInstances&SignatureMethod=HmacSHA256&SignatureVersion=2&Timestamp=${timestamp}&Version=2013-07-15"`
  signature=`echo -n "$Q"| $SSLEX dgst -binary -sha256 -hmac | base64`
  $CURL "https://ec2.amazonaws.com/?AWSAccessKeyId=${AWS_ACCESS_KEY_ID}&Action=DescribeInstances&SignatureMethod=HmacSHA256&SignatureVersion=2&Timestamp=${timestamp}&Version=2013-07-15&Signature=${signature}" > "$M_TEMP/${rcommand}.resp"
  "$M_ROOT"/lib/xml2txt "$M_TEMP/${rcommand}.resp" > "$M_TEMP/servers.${region}.ips"
}

possible_options="help region verbose cluster state status filter short noupdate view update_servers_list forceupdate all status count resolveids id name_source"
necessary_options=""
IFS1=$IFS
IFS='-'
for s_option in "$@"
do
  found=false
  s_option=${s_option/--/}
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"

  for option in ${possible_options// /-} ; do
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=true && break
  done
  
  if ! $found ; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

if [ "X$help" == "Xyes" ] ; then
  echo "Usage: ${0##*/} <options>"
  echo 
  echo "Without options all found clusters will be synced"
  echo
  echo "Options:"
  echo
  echo "  --region=region          - syncs only servers in this region."
  exit 0
fi

source $M_ROOT/conf/mon.conf
source $M_ROOT/conf/cloud.conf
source $M_ROOT/lib/functions.sh
source $M_ROOT/lib/cloud_functions.sh
LOG=$M_ROOT/logs/cloud.log

for var in JAVA_HOME EC2_HOME EC2_PRIVATE_KEY EC2_CERT EC2_REGION EC2_TOOLS_BIN_PATH ; do
  [ -z "`eval echo \\$\$var`" ] && log "$var is not defined! Define it in conf/cloud.conf please." && exit 1
done
PATH="${EC2_TOOLS_BIN_PATH}:${PATH}"
export JAVA_HOME EC2_HOME EC2_PRIVATE_KEY EC2_CERT EC2_REGION PATH
M_TEMP=$M_TEMP/cloud/ec2
install -d $M_TEMP

[ -z "$region" ] && region=$EC2_REGION

[ -z "$status" ] && [ -n "$state" ] && status=$state
[ -z "$status" ] && status="running"

[ -n "$name_source" ] && NAME_SOURCE=$name_source

[ "X$IFCFG" == "X" ] || localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//' | grep -v '127.0.0.1'`

changed=0
[ -f $M_TEMP/servers.${region}.ips ] && mv $M_TEMP/servers.${region}.ips $M_TEMP/servers.${region}.ips.prev || touch $M_TEMP/servers.${region}.ips.prev
[ -f $M_TEMP/servers.${region}.bdevs ] && mv $M_TEMP/servers.${region}.bdevs $M_TEMP/servers.${region}.bdevs.prev || touch $M_TEMP/servers.${region}.bdevs.prev

# force update if the tmp file is older than FORCE_LIST_UPDATE_AFTER
# if no setting, force update is disabled
if [ -n "$FORCE_LIST_UPDATE_AFTER" -a -n "$noupdate" ] ; then
  tmpfileage=$(expr `date +"%s"` - `stat -c "%Z" $M_TEMP/${rcommand}.resp || echo 0` || echo 86400)
  [ $tmpfileage -gt $FORCE_LIST_UPDATE_AFTER ] && unset noupdate
fi

request

[ `cat "$M_TEMP/${rcommand}.resp" | wc -l` -eq 0 ] && log "file $M_TEMP/${rcommand}.resp is empty" && exit 1


