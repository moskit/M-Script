#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/ (this is needed to fix vi syntax highlighting)

CURL=`which curl 2>/dev/null`
LYNX=`which lynx 2>/dev/null`
LINKS=`which links 2>/dev/null`
WGET=`which wget 2>/dev/null`

CURL="$CURL -s"
V="v1.0"

possible_options="region flavor cluster image name return verbose"
necessary_options="cluster"

ARGV=`echo ${@} | sed 's/^--//' | sed 's/ --/|/g'`

IFS1=$IFS
IFS='|'
for s_option in $ARGV
do
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  for option in `echo $possible_options | sed 's/ /|/g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=1
  done
   if [[ found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

found=0
for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found"
  exit 1
fi

source "${rpath}/../../conf/mon.conf"
TMPDIR="$TMPDIR"/cloud/rackspace
install -d "$TMPDIR"
source "${rpath}/../../conf/cloud.conf"

generate_name() {
  nam=$(cat "${rpath}/../../servers.list" | grep ${cluster}[[:space:]]*$ | cut -d'|' -f4 | while read name ; do expr "X$name" : 'X\(.*[^0-9]\)[0-9]*' ; done | sort | uniq -c | sort | tail -1) ; nam=${nam##* }
  [ -n "$nam" ] || nam=$cluster
  am=0 ; lm=0
  num=$(cat "${rpath}/../../servers.list" | grep ${cluster}[[:space:]]*$ | cut -d'|' -f4 | while read name ; do a=`expr "X$name" : 'X.*[^0-9]\([0-9]*\)'` ; l=${#a} ; [ `expr $l \> ${lm}` -gt 0 ] && lm=$l ; [ `expr $a \> ${am}` -gt 0 ] && am=$a ; echo "$am|$lm" ; done | tail -1)
  am=${num%|*} ; lm=${num#*|}
  [ -n "$am" ] && am=`expr $am + 1` || am=1
  [ -n "$lm" ] || lm=3
  echo "$nam`until [[ ${#am} -eq $lm ]] ; do am="0$am" ; m0="0$m0" ; echo $m0 ; done | tail -1`$am"
}

find_image() {
  image=`grep ^$cluster\| "${rpath}/../../conf/clusters.conf" | cut -d'|' -f6`
}

find_flavor() {
  flavor=`grep ^$cluster\| "${rpath}/../../conf/clusters.conf" | cut -d'|' -f5`
}

check_cluster_limit() {
  limit=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f7`
  [ -z "$limit" ] && return 0
  limit=${limit#*:}
  [ "$limit" == "0" ] && return 0
  n=`${rpath}/show_servers --view=none --count --cluster=$cluster`
  [ -z "$n" ] && return 1
  [ `expr $n \>= 0` -gt 0 ] || return 1
  [ `expr $limit \> $n` -gt 0 ] && return 0
  return 1
}

request() {
  URL=`grep ^1\/auth\/serviceCatalog\/cloudServers\/0\/publicURL "${TMPDIR}/auth.resp" | cut -d'|' -f2`
  TOKEN=`grep ^1\/auth\/token\/id "${TMPDIR}/auth.resp" | cut -d'|' -f2`
  $CURL -X POST -T "$TMPDIR/${rcommand}.req" -H "Content-Type: application/json" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}/servers" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/${rcommand}.resp"
  #[ -n "`find "${TMPDIR}" -mtime -60 -name flavors.resp`" ] || $CURL -X GET -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}/flavors/detail" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/flavors.resp"
  #[ -n "`find "${TMPDIR}" -mtime -60 -name images.resp`" ] || $CURL -X GET -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}/images/detail" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/images.resp"
}

save_details() {
  echo -e "\n`date`\n\nCluster|$cluster\nName|$name\n`grep -E "\/id\||\/imageId\||\/flavorId\||\/adminPass\||\/addresses\/public|\/addresses\/private" "${TMPDIR}/${rcommand}.resp"`\n" >> "${rpath}/../rackspace.log"
  chmod 600 "${rpath}/../rackspace.log"
  if [ "X$NETWORK" == "Xexternal" ] ; then
    slip=`grep \/addresses\/public "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2`
  else
    slip=`grep \/addresses\/private "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2`
  fi
  echo "${slip}|${thekey}|${region}|${name}|${cluster}" >> "${rpath}/../../servers.list"
}

wait_ready() {
  echo
  waittimeout=600
  waitperiod=10
  checks=`expr $waittimeout / $waitperiod`
  for ((i=1; i<$checks; i++)) ; do
    sleep $waitperiod
    "$rpath"/get_server_details $newid >/dev/null 2>&1
    if [ -n "$1" ] ; then
      printf "Progress: `grep \/progress\| "${TMPDIR}/get_server_details.resp" | cut -d'|' -f2`     \r"
    fi
    if [ "X`grep \/status\| "${TMPDIR}/get_server_details.resp" | cut -d'|' -f2`" == "XACTIVE" ] ; then
      echo
      return 0
    fi
  done
  return 1
}

printreturn() {
  for res in `echo $return | tr ',' ' '` ; do
    case $res in
      ip)
        if [ "X$NETWORK" == "Xexternal" ] ; then
          grep \/addresses\/public "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        else
          grep \/addresses\/private "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        fi
        ;;
      ipext)
        grep \/addresses\/public "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        ;;
      ipint)
        grep \/addresses\/private "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        ;;
      id)
        grep \/id\| "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        ;;
      pass|password)
        grep \/adminPass "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2
        ;;
    esac
  done
}

check_cluster_limit || exit 5
[ -z "$name" ] && name=`generate_name`
[ -z "$name" ] && exit 6
[ -z "$image" ] && find_image
[ -z "$image" ] && exit 7
[ -z "$flavor" ] && find_flavor
[ -z "$flavor" ] && exit 8
thekey=`cat "${rpath}/../../conf/clusters.conf" | grep ^$cluster\| | cut -d'|' -f2`
[ -f "${rpath}/../../keys/${thekey}.pub" ] && thekey=${thekey}.pem
PUBLIC_KEY=`cat $thekey 2>/dev/null`
[ -z "$PUBLIC_KEY" ] && PUBLIC_KEY=`cat ${HOME}/.ssh/id_dsa.pub 2>/dev/null`
[ -z "$PUBLIC_KEY" ] && PUBLIC_KEY=`cat ${HOME}/.ssh/id_rsa.pub 2>/dev/null`
[ -z "$PUBLIC_KEY" ] && [ -z "$nokey" ] && echo "No key found" && exit 1
PUBLIC_KEY=`echo "$PUBLIC_KEY" | openssl enc -base64`
cat "${rpath}/create_server.$V.json.1" | sed "s|NAME|$name|;s|IMAGE_ID|$image|;s|FLAVOR_ID|$flavor|;s|CLUSTER|$cluster|" > "$TMPDIR/${rcommand}.req"
echo "        \"personality\" : [" >> "$TMPDIR/${rcommand}.req"
echo "            {" >> "$TMPDIR/${rcommand}.req"
echo -n "                \"path\" : " >> "$TMPDIR/${rcommand}.req"
echo "\"/root/.ssh/authorized_keys\"," >> "$TMPDIR/${rcommand}.req"
echo -n "                \"contents\" : " >> "$TMPDIR/${rcommand}.req"
echo -n "\"" >> "$TMPDIR/${rcommand}.req"
echo -n ${PUBLIC_KEY} >> "$TMPDIR/${rcommand}.req"
echo "\"" >> "$TMPDIR/${rcommand}.req"
echo "            }" >> "$TMPDIR/${rcommand}.req"
echo "        ]" >> "$TMPDIR/${rcommand}.req"
echo "    }" >> "$TMPDIR/${rcommand}.req"
echo "}" >> "$TMPDIR/${rcommand}.req"

[ -f "${TMPDIR}/auth.resp" ] || ${rpath}/auth
request
if [ `grep -c ^1\/unauthorized\/code\|401$ "${TMPDIR}/${rcommand}.resp"` -eq 1 ] ; then
  ${rpath}/auth
  request
fi

newid=`grep \/id\| "${TMPDIR}/${rcommand}.resp" | cut -d'|' -f2`
if [ -n "$newid" ] ; then
  save_details
  wait_ready $verbose
  [ -n "$return" ] && printreturn $return
else
  exit 1
fi


