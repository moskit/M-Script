#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/ (this is needed to fix vi syntax highlighting)

CURL=`which curl 2>/dev/null`
LYNX=`which lynx 2>/dev/null`
LINKS=`which links 2>/dev/null`
WGET=`which wget 2>/dev/null`
[ -z "$CURL" ] && echo "Curl not found" && exit 1
source "${rpath}/../../conf/mon.conf"
TMPDIR=$TMPDIR/cloud/rackspace
install -d $TMPDIR
CURL="$CURL -s"
declare -i icount

possible_options="cluster state filter region short noupdate view update_servers_list forceupdate all status count resolve-ids"
necessary_options=""

ARGV=`echo ${@} | sed 's/^--//' | sed 's/ --/|/g'`

IFS1=$IFS
IFS='|'
for s_option in $ARGV
do
  s_optname=${s_option%%=*}
  s_optname=`echo $s_optname | tr -d '-'`
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  for option in `echo $possible_options | sed 's/ /|/g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=1
  done
   if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

found=0
for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found"
  exit 1
fi

[ -n "$update_servers_list" -a -n "$filter" ] && echo "Impossible options combination" && exit 1
[ -n "$short" ] && req='/servers' || req='/servers/detail'
[ -n "$forceupdate" ] && rm -f "${TMPDIR}"/${rcommand}.resp
[ -z "$status" ] && status="active"
[ -n "$filter" ] && filter="${filter},addresses,cluster"

request() {
  URL=`grep ^1\/auth\/serviceCatalog\/cloudServers\/0\/publicURL "${TMPDIR}/auth.resp" | cut -d'|' -f2`
  TOKEN=`grep ^1\/auth\/token\/id "${TMPDIR}/auth.resp" | cut -d'|' -f2`
  $CURL -X GET -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}${req}" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/${rcommand}.resp"
  [ -n "`find "${TMPDIR}" -mtime -60 -name flavors.resp`" ] || $CURL -X GET -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}/flavors/detail" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/flavors.resp"
  [ -n "`find "${TMPDIR}" -mtime -60 -name images.resp`" ] || $CURL -X GET -H "Content-Type: application/json; charset=UTF-8" -H "Accept: application/json" -H "X-Auth-Token: $TOKEN" "${URL}/images/detail" | "${rpath}/../../lib/json2txt" > "${TMPDIR}/images.resp"
}

list_servers() {
  IFS1=$IFS
  IFS='
'
  if [ -f "${TMPDIR}/${rcommand}.resp" ] ; then
    for n in `cat "${TMPDIR}/${rcommand}.resp" | cut -d'/' -f3 | sort | uniq` ; do
      unset id name istatus extIP intIP IP imageId flavorId region icluster
      for LINE in `grep \/servers\/${n}\/ "${TMPDIR}/${rcommand}.resp"` ; do
        LINE=`echo $LINE | awk -F"servers/${n}/" '{print $2}'`
        lvar=`echo $LINE | cut -d'|' -f1`
        if [ -n "$filter" ] ; then
          
          for fvar in `echo -e ${filter} | tr ',' '\n'` ; do            
            [[ $lvar =~ $fvar ]] || continue 2
          done
        fi
        lvalue=`echo $LINE | cut -d'|' -f2`
        case $lvar in
          imageId)
            [ -n "$resolveids" ] && imageId=`imageid $lvalue` || imageId=$lvalue
            ;;
          flavorId)
            [ -n "$resolveids" ] && flavorId=`flavorid $lvalue` || flavorId=$lvalue
            ;;
          status)
            istatus=`echo $lvalue | sed 's|.|\l&|g'`
            ;;
          addresses/public/*)
            extIP="$extIP $lvalue"
            ;;
          addresses/private/*)
            intIP="$intIP $lvalue"
            ;;
          metadata/cluster)
            icluster="$lvalue"
            ;;
          *)
            eval "$lvar=\"$lvalue\""
            ;;
        esac
      done
      if [ "X$NETWORK" == "Xexternal" ] ; then
        IP=$extIP
      else
        IP=$intIP
      fi
      for ip in $IP ; do
        ip=${ip#* } ; ip=${ip% *}
        if [ -z "$icluster" ] ; then
          icluster=`grep ^$ip\| "${rpath}/../../servers.list" | cut -d'|' -f5` && break
        else
          [ `grep -c ^$icluster\| "${rpath}/../../conf/clusters.conf"` -eq 0 ] && unset icluster
        fi
      done
      if [ -z "$update_servers_list" ] ; then
        # icluster existence condition is needed for the case there are multiple
        # projects (cluster groups) in the same cloud.
        # Note that if you use same names for clusters in different cluster
        # groups, you'll get them mixed here.
        if [ -n "$icluster" -o -n "$all" ] ; then
          [ -n "$cluster" -a "$cluster" != "$icluster" ] && continue
          [ "X$status" != "X$istatus" ] && [ "X$status" != "Xall" ] && continue
          extIP=${extIP#* } ; extIP=${extIP% *}
          intIP=${intIP#* } ; intIP=${intIP% *}
          case $view in
            list)
              echo "ID: $id  Name: $name  Status: $status  ext IP: $extIP  intIP: $intIP  Image: $imageId  Size: $flavorId"
              ;;
            table)
              echo "${id}|${name}|${status}|${extIP}|${intIP}|${imageId}|${flavorId}"
              ;;
            column)
              echo -e "ID: $id\nName: $name\nStatus: $status\next IP: $extIP\nintIP: $intIP\nImage: $imageId\nSize: $flavorId\n"
              ;;
            none)
              ;;
            *)
              echo "------------------------------------------------------------------------------"
              echo "Server ID: $id    Name: $name    Cluster: $icluster"
              echo "Public IP: $extIP"
              echo "Private IP: $intIP"
              echo "Server image: $imageId"
              echo "Server size: $flavorId    Status: $istatus"
              ;;
          esac
          icount+=1
        fi
      else
        if [ -n "$icluster" ] ; then
          if [ `grep -c ^${icluster}\| "${rpath}/../../conf/clusters.conf"` -ne 0 ] ; then
            key=`grep ^${icluster}\| "${rpath}/../../conf/clusters.conf" | cut -d'|' -f2`
            for ip in $IP ; do
              ip=${ip#* } ; ip=${ip% *}
              sed -i /^$ip\|/d "${rpath}/../../servers.list"
              echo "${ip}|${key}|${region}|${name}|${icluster}" >> "${rpath}/../../servers.list"
            done
            for listip in `cat "${rpath}/../../servers.list" | grep -v ^# | grep -v ^$ | cut -d'|' -f1` ; do
              [ `grep -c \|${listip}$ "${TMPDIR}/${rcommand}.resp"` -eq 0 ] && sed -i /^${listip}\|/d "${rpath}/../../servers.list"
            done
          fi
        fi
      fi
      
    done
  else
    echo "No data. Run without --noupdate"
  fi
  IFS=$IFS1
}

imageid() {
  imagenum=`grep \/id\|${1}$ "${TMPDIR}/images.resp" | cut -d'/' -f3`
  grep \/$imagenum\/name\| "${TMPDIR}/images.resp" | cut -d'|' -f2
}

flavorid() {
  imagenum=`grep \/id\|${1}$ "${TMPDIR}/flavors.resp" | cut -d'/' -f3`
  grep \/$imagenum\/name\| "${TMPDIR}/flavors.resp" | cut -d'|' -f2
}

try_auth() {
  local -i i
  i=0
  while [ ! -e "${TMPDIR}/auth.resp" -o `cat "${TMPDIR}/auth.resp" 2>/dev/null | wc -l` -eq 0 ] ; do
    [ $i > 20 ] && echo "Problem getting authorization from the Rackspace Cloud API" && exit 1
    ${rpath}/auth
    i+=1
    sleep 30
  done
  echo "rackspace/show_servers: $i additional auth requests due to no reply from API" >> "$rpath"/../../logs/cloud.log
}

source "${rpath}/../../conf/cloud.conf"

if [ -z "$noupdate" ] ; then
  try_auth
  request
  declare -i n
  n=0
  while [ `grep -c ^1\/unauthorized\/code\|401$ "${TMPDIR}/${rcommand}.resp"` -eq 1 ] ; do
    sleep 300
    try_auth
    request
    n+=1
  fi
  echo "rackspace/show_servers: $n additional auth requests due to authorization expired" >> "$rpath"/../../logs/cloud.log
fi
list_servers

[ -n "$count" ] && echo $icount || exit 0

