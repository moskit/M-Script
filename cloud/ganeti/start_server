#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/

GNTI=`which gnt-instance 2>/dev/null`
GNTC=`which gnt-cluster 2>/dev/null`
ROUTE=`which route 2>/dev/null`
IPR2=`which ip 2>/dev/null`
[ -z "$GNTI" ] && echo "gnt-instance utility not found" && exit 1
[ -z "$ROUTE" ] && echo "route utility not found" && exit 1
[ -z "$IPR2" ] && echo "ip utility not found" && exit 1
possible_options="region flavor cluster image name return verbose test"
necessary_options="cluster"

LOG="${rpath}"/../../logs/cloud.log
SSHK=`which ssh-keygen 2>/dev/null`
SSH=`which ssh 2>/dev/null`
ARGV=`echo ${@} | sed 's/^--//' | sed 's/ --/|/g'`

IFS1=$IFS
IFS='|'
for s_option in $ARGV
do
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  for option in `echo $possible_options | sed 's/ /|/g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=1
  done
   if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

found=0
for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found"
  exit 1
fi

source "${rpath}/../../conf/mon.conf"
source "${rpath}/../../conf/cloud.conf"
[ -z "$GANETI_NETWORK" ] && echo "Define GANETI_NETWORK in conf/cloud.conf, please" && exit 1
source "${rpath}/../../lib/functions.sh"
source "${rpath}/../../lib/cloud_functions.sh"

M_TEMP="$M_TEMP/cloud/ganeti"
install -d "$M_TEMP"

find_ip() {
  class=${GANETI_NETWORK%.*}
  [ -z "$class" ] && class="10.1.1"
  maxip=`cat "${rpath}/../../servers.list" | cut -d'|' -f1 | grep ^$class | sort | uniq | tail -1`
  maxip=${maxip##*.}
  if [ -n "$maxip" ]; then
    [ "$maxip" == "254" ] && echo "No more IPs available!" && exit 1
    echo "${class}.$((maxip+1))"
  else
    echo "${class}.2"
  fi
}

find_gateway() {
  class=${GANETI_NETWORK%.*}
  [ -z "$class" ] && class="10.1.1"
  echo "${class}.1"
}

find_broadcast() {
  class=${GANETI_NETWORK%.*}
  [ -z "$class" ] && class="10.1.1"
  echo "${class}.254"
}

save_details() {
  [ -n "$1" ] && echo "Saving details..."
  echo -e "\n`date`\n\nCluster|$cluster\nName|$name\nIP|$ip\n" >> "${rpath}/../ganeti.log"
  echo "${ip}|${thekey}||${name}|${cluster}" >> "${rpath}/../../servers.list"
  return 0
}

wait_ready() {
  [ -n "$1" ] && echo "Waiting..."
  waittimeout=200
  waitperiod=10
  checks=`expr $waittimeout / $waitperiod`
  for ((i=1; i<$checks; i++)) ; do
    sleep $waitperiod
    [ -n "$1" ] && echo -n '.'
    "$rpath"/get_server_details --name=$name >/dev/null 2>&1
    if [ `cat "${M_TEMP}/get_server_details.resp" | grep ^State | grep -c 'actual state is up'` -eq 1 ] ; then
      echo
      return 0
    fi
  done
  return 1
}

request() {
  node=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f3`
  ios=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f5`
  iparams=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f6`
  sed -i "/^${ip}/d" /etc/hosts
  echo "$ip $name" >> /etc/hosts
  #echo "$GNTI add -n $node -o $iparams $name"
  $GNTI add -n $node -o $ios $iparams $name >>"$LOG" 2>&1 </dev/null &
}

find_idev() {
  if [ "`cat "${M_TEMP}/get_server_details.resp" | grep '^State/Hardware/NICs/nic/0/mode' | cut -d'|' -f2`" == "routed" ]; then
    link=`cat "${M_TEMP}/get_server_details.resp" | grep '^State/Hardware/NICs/nic/0/link' | cut -d'|' -f2`
  fi
  $IPR2 route show table $link | grep "^${1}[[:space:]]" | awk '{print $3}'
}

prepare_file() {
IFS1=$IFS
IFS='
'
  rm -f "${2}" "${2}.orig"

  cat "$1" | sed 's|}\%|}\%\\\n|g' | \
    sed "s|\\$|\\\\$|g;s|\%{\(.*\)}\%|$\{\1\}|g" | \
    sed 's|\\"|\\\\"|g' | \
    sed 's|"|\\\"|g' | \
    sed 's|`|\\\`|g' >> "${2}.orig"

  [ -n "$debug" ] && echo -e "\n --- TMP FILE ---\n\n" && cat "${2}.orig" && echo -e " --- END OF TMP FILE ---\n\n --- TMP FILE w/vars substituted ---\n\n"

  for LINE in `cat -E "${2}.orig"` ; do
    if [[ `echo $LINE | grep -c '\\\\$$'` -gt 0 ]]; then
      KEEP="${KEEP}`echo "$LINE" | sed 's|\\\\$$||'`"
      continue
    else
      LINE="${KEEP}`echo $LINE | sed 's|\$$||'`"
      unset KEEP
      a=`eval "echo \"$LINE\"" 2>>"$LOG"`
      if [ $? -eq 0 ] && [ -n "$a" ]; then
        echo "$a" >> "${2}"
      else
        echo "$LINE" >> "${2}"
      fi
      [ -n "$debug" ] && tail -1 "${2}" || true
    fi
  done
  IFS=$IFS1
}

[ -z "$cluster" ] && cluster=$M_CLUSTER
[ -z "$cluster" ] && echo "Cluster not defined" && exit 1

log "($CLOUD) checking cluster $cluster limit"
res=`check_cluster_limit $verbose`
[[ $res -ne 0 ]] && exit 5
[ -z "$name" ] && name=`generate_name` && log "name auto-generated: $name"
[ -z "$name" ] && exit 6
[ -z "$ip" ] && ip=`find_ip` && log "IP that will be used: $ip"
[ -z "$ip" ] && exit 4

thekey=`cat "${rpath}/../../conf/clusters.conf" | grep ^$cluster\| | cut -d'|' -f2`
[ -f "${rpath}/../../keys/${thekey}.pub" ] && PUBLIC_KEY="${rpath}/../../keys/${thekey}.pub"
[ -z "$PUBLIC_KEY" ] && [ -f "${rpath}/../../keys/${thekey}.pem.pub" ] && PUBLIC_KEY="${rpath}/../../keys/${thekey}.pem.pub"
[ -z "$PUBLIC_KEY" ] && [ -f ${HOME}/.ssh/id_dsa.pub ] && PUBLIC_KEY=${HOME}/.ssh/id_dsa.pub
[ -z "$PUBLIC_KEY" ] && [ -f ${HOME}/.ssh/id_rsa.pub ] && PUBLIC_KEY=${HOME}/.ssh/id_rsa.pub
[ -z "$PUBLIC_KEY" ] && [ -f ${HOME_ORIG}/.ssh/id_dsa.pub ] && PUBLIC_KEY=${HOME_ORIG}/.ssh/id_dsa.pub
[ -z "$PUBLIC_KEY" ] && [ -f ${HOME_ORIG}/.ssh/id_rsa.pub ] && PUBLIC_KEY=${HOME_ORIG}/.ssh/id_rsa.pub
[ -z "$PUBLIC_KEY" ] && log "No public key found. Tried ${rpath}/../../keys/${thekey}.\*, public keys from ${HOME}/.ssh and ${HOME_ORIG}/.ssh" && exit 1

# Ganeti cluster must be running, and this script can run on master node only
$GNTC master-ping
[ $? -ne 0 ] && echo "Error pinging Ganeti cluster. Is it running?" && exit 1
# If it's alive, we can get some info from it
OSPATH=`$GNTC info | grep 'OS search path'`
OSPATH="${OSPATH##*: }"
# OS required for the new server
OSNAME=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f5 | cut -d'+' -f1`
[ -z "$OSNAME" ] && log "Unable to find OS for cluster $cluster" && exit 1
# common.sh is supposed to be a file containing functions and default settings
# it cannot be just sourced, but we need only two things anyway
OS_DEFAULT_CONF=`cat "$OSPATH/$OSNAME/common.sh" | grep 'DEFAULT_FILE=' | cut -d'=' -f2 | cut -d'"' -f2`

source "$OS_DEFAULT_CONF"
log "$OS_DEFAULT_CONF sourced"
HOOKS_DIR="$CUSTOMIZE_DIR"
[ -z "$HOOKS_DIR" ] && HOOKS_DIR=`cat "$OSPATH/$OSNAME/common.sh" | grep 'CUSTOMIZE_DIR:=' | awk -F':=' '{print $2}' | cut -d'"' -f2`
log "HOOKS_DIR: $HOOKS_DIR"

[ -z "$HOOKS_DIR" ] && log "Unable to find a hooks directory" && exit 1

[ -z "$GANETI_GATEWAY" ] && GANETI_GATEWAY=`find_gateway`

broadcast=`find_broadcast`
log "gateway: $GANETI_GATEWAY  broadcast: $broadcast"

# some logic to define the Linux flavor will be here
# for now it's the default Debian debootstrap OS
prepare_file "$rpath/network_if.debian.tmpl" "$M_TEMP/interfaces"
[ $? -eq 0 ] && log "$M_TEMP/interfaces prepared" || log "error preparing $M_TEMP/interfaces"
prepare_file "$rpath/network_if.debian" "$M_TEMP/network"
[ $? -eq 0 ] && log "$M_TEMP/network prepared" || log "error preparing $M_TEMP/network"
# installing software via chroot has proven to be unreliable
cp "$rpath/setup.sh.debian" "$M_TEMP/setup.sh"
cp "$M_TEMP/network" "$HOOKS_DIR/"
chmod 755 "$HOOKS_DIR/network"

if [ -z "$test" ]; then
  request $verbose
  reqexit=$?
  if [ $reqexit -eq 0 ]; then
    log "request sent successfully"
    sleep 20
  else
    log "request returned status $reqexit"
    exit 1
  fi
  wait_ready $V 
  if [ $? -eq 0 ]; then
    idev=`find_idev $ip`
    if [ -n "$idev" ]; then
      $ROUTE add -host $ip dev $idev
      [ $? -ne 0 ] && log "Failure adding the route: $ROUTE add -host $ip dev $idev" && exit 1
    else
      log "Instance started, but tap device doesn't exist"
      exit 1
    fi
  else
    log "Timeout while waiting for the server is up"
    exit 1
  fi

  # adding to the list
  $GNTI add-tags $name cluster:$cluster
  if [ $? -eq 0 ]; then
    log "Tag cluster:$cluster added"
    "$rpath/show_servers" --update_servers_list
  else
    log "Adding tag cluster:$cluster failed"
    echo -e "\nWas unable to add the cluster tag, so servers.list is not updated.\nFix the problem and re-create the instance or try to tag it manually:\n\n$GNTI add-tags $name cluster:$cluster\n\nthen update the list:\n\nupdate_servers_list\n"
  fi
else
  log "This was a test, not sending request, exiting"
  exit 0
fi

$SSHK -q -R "$ip" >/dev/null
[ ! -f "${rpath}/../../keys/$thekey" ] && thekey="${thekey}.pem"
[ ! -f "${rpath}/../../keys/$thekey" ] && thekey="$HOME/.ssh/id_rsa.pub"
[ ! -f "$thekey" ] && thekey="$HOME/.ssh/id_dsa.pub"
[ -f "$thekey" ] && $SSH -i "$thekey" -o StrictHostKeyChecking=no $ip echo 2>/dev/null

if [ $? -ne 0 ]; then
  log "($CLOUD) Unable to login to the server $ip using the key $thekey, trying again..."
  for ((k=0; k<3; k++)); do
    $SSH -i "$thekey" -o StrictHostKeyChecking=no $ip echo >/dev/null
    [ $? -eq 0 ] && $SSH -i "$thekey" -o StrictHostKeyChecking=no $name echo >/dev/null && break
    sleep 5
  done
fi
[ $? -ne 0 ] && exit 1

if [ -n "$return" ]; then
  echo
  for ret in `echo $return | tr ',' ' '`; do
    case $ret in
      ip)
        echo $ip ;;
      name)
        echo $name ;;
      idev)
        echo $idev ;;
      iparams)
        echo $iparams ;;
      node)
        echo $node ;;
      ios)
        echo $ios ;;
    esac
  done
fi

exit $existatus

