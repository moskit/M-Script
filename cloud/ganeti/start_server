#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/

GNTI=`which gnt-instance 2>/dev/null`
GNTC=`which gnt-cluster 2>/dev/null`
ROUTE=`which route 2>/dev/null`
IPR2=`which ip 2>/dev/null`
[ -z "$GNTI" ] && echo "gnt-instance utility not found" && exit 1
[ -z "$ROUTE" ] && echo "route utility not found" && exit 1
[ -z "$IPR2" ] && echo "ip utility not found" && exit 1
possible_options="region flavor cluster image name return verbose"
necessary_options="cluster"

ARGV=`echo ${@} | sed 's/^--//' | sed 's/ --/|/g'`

IFS1=$IFS
IFS='|'
for s_option in $ARGV
do
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  for option in `echo $possible_options | sed 's/ /|/g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=1
  done
   if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFS1

found=0
for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found"
  exit 1
fi

source "${rpath}/../../conf/mon.conf"
TMPDIR="$TMPDIR"/cloud/ganeti
install -d "$TMPDIR"
source "${rpath}/../../conf/cloud.conf"

generate_name() {
  nam=$(cat "${rpath}/../../servers.list" | grep -v ^# | grep -v ^$ | grep ${cluster}[[:space:]]*$ | cut -d'|' -f4 | while read name ; do expr "X$name" : 'X\(.*[^0-9]\)[0-9]*' ; done | sort | uniq -c | sort | tail -1) ; nam=${nam##* }
  [ -n "$nam" ] || nam=$cluster
  am=0 ; lm=0
  num=$(cat "${rpath}/../../servers.list" | grep -v ^# | grep -v ^$ | cut -d'|' -f4 | grep ^$nam | while read name ; do a=`expr "X$name" : 'X.*[^0-9]\([0-9]*\)'` ; l=${#a} ; [ `expr $l \> ${lm}` -gt 0 ] && lm=$l ; [ `expr $a \> ${am}` -gt 0 ] && am=$a ; echo "$am|$lm" ; done | tail -1)
  am=${num%|*} ; lm=${num#*|}
  if [ -n "$am" ] ; then
    am=`expr $am + 1`
    # length might change
    lnew=${#a}
    [[ $lnew -gt $lm ]] && lm=$lnew
  else
    am=1
  fi
  [ -n "$lm" ] || lm=$NAME_INDEX_LENGTH
  echo "$nam`until [[ ${#am} -eq $lm ]] ; do am="0$am" ; m0="0$m0" ; [[ ${#am} -gt $lm ]] && exit 1 ; echo $m0 ; done | tail -1`$am"
}

check_cluster_limit() {
  limit=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f7`
  [ -z "$limit" ] && return 0
  limit=${limit#*:}
  [ "$limit" == "0" ] && return 0
  n=`${rpath}/show_servers --view=none --count --cluster=$cluster`
  [ -z "$n" ] && return 1
  [ `expr $n \>= 0` -gt 0 ] || return 1
  [ `expr $limit \> $n` -gt 0 ] && return 0
  return 1
}

find_ip() {
  class=${GANETI_NETWORK%.*}
  [ -z "$class" ] && class="10.1.1"
  maxip=`cat "${rpath}/../../servers.list" | cut -d'|' -f1 | grep ^$class | sort | uniq | tail -1`
  maxip=${maxip##*.}
  if [ -n "$maxip" ]; then
    [ "$maxip" == "254" ] && echo "No more IPs available!" && exit 1
    echo "${class}.$((maxip+1))"
  else
    echo "${class}.2"
  fi
}

save_details() {
  [ -n "$1" ] && echo "Saving details..."
  echo -e "\n`date`\n\nCluster|$cluster\nName|$name\nIP|$ip\n" >> "${rpath}/../ganeti.log"
  echo "${ip}|${thekey}||${name}|${cluster}" >> "${rpath}/../../servers.list"
  return 0
}

wait_ready() {
  [ -n "$1" ] && echo "Waiting..."
  waittimeout=200
  waitperiod=5
  checks=`expr $waittimeout / $waitperiod`
  for ((i=1; i<$checks; i++)) ; do
    sleep $waitperiod
    "$rpath"/get_server_details --name=$name >/dev/null 2>&1
    if [ `cat "${TMPDIR}/get_server_details.resp" | grep ^State | grep -c 'actual state is up'` -eq 1 ] ; then
      echo
      return 0
    fi
  done
  return 1
}

request() {
node=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f3`
ios=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f5`
iparams=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f6`
echo "$ip $name" >> /etc/hosts
#echo "$GNTI add -n $node -o $iparams $name"
$GNTI add -n $node -o $ios $iparams $name 2>&1
}

find_idev() {
if [ "`cat "${TMPDIR}/get_server_details.resp" | grep '^State/Hardware/NICs/nic/0/mode' | cut -d'|' -f2`" == "routed" ]; then
  link=`cat "${TMPDIR}/get_server_details.resp" | grep '^State/Hardware/NICs/nic/0/link' | cut -d'|' -f2`
fi
$IPR2 route show table $link | grep "^${1}[[:space:]]" | awk '{print $3}'
}

prepare_file() {
  tmpfile="${TMPDIR}/interfaces"
  rm -f "${tmpfile}" "${tmpfile}.orig"

  cat "$1" | sed 's|}\%|}\%\\\n|g' | \
    sed "s|\\$|\\\\$|g;s|\%{\(.*\)}\%|$\{\1\}|g" | \
    sed 's|\\"|\\\\"|g' | \
    sed 's|"|\\\"|g' | \
    sed 's|`|\\\`|g' >> "${tmpfile}.orig"

  [ -n "$debug" ] && echo -e "\n --- TMP FILE ---\n\n" && cat "${tmpfile}.orig" && echo -e " --- END OF TMP FILE ---\n\n --- TMP FILE w/vars substituted ---\n\n"

  for LINE in `cat -E "${tmpfile}.orig"` ; do
    if [[ `echo $LINE | grep -c '\\\\$$'` -gt 0 ]]; then
      KEEP="${KEEP}`echo "$LINE" | sed 's|\\\\$$||'`"
      continue
    else
      LINE="${KEEP}`echo $LINE | sed 's|\$$||'`"
      unset KEEP
      a=`eval "echo \"$LINE\"" 2>>"${rpath}/../deploy.log"`
      if [ $? -eq 0 ] && [ -n "$a" ]; then
        echo "$a" >> "${tmpfile}"
      else
        echo "$LINE" >> "${tmpfile}"
      fi
      [ -n "$debug" ] && tail -1 "${tmpfile}" || true
    fi
  done
}

[ -z "$cluster" ] && cluster=$M_CLUSTER
[ -z "$cluster" ] && echo "Cluster not defined" && exit 1

res=`check_cluster_limit`
[[ $res -ne 0 ]] && exit 5
[ -z "$name" ] && name=`generate_name` && echo "`date +"%m.%d %H:%M"` ganeti/start_server: name auto-generated: $name">>"${rpath}"/../../logs/cloud.log
[ -z "$name" ] && exit 6
[ -z "$ip" ] && ip=`find_ip` && echo "`date +"%m.%d %H:%M"` ganeti/start_server: IP that will be used: $ip">>"${rpath}"/../../logs/cloud.log
[ -z "$ip" ] && exit 4

# Ganeti cluster must be running, and this script can run on master node only
$GNTC master-ping
[ $? -ne 0 ] && echo "Error pinging Ganeti cluster. Is it running?" && exit 1
# If it's alive, we can get some info from it
OSPATH=`$GNTC info | grep 'OS search path'`
OSPATH="${OSPATH##*: }"
# OS required for the new server
OSNAME=`cat "${rpath}/../../conf/clusters.conf" | grep ^${cluster}\| | cut -d'|' -f5 | ct -d'+' -f1`
# common.sh is supposed to be a file containing functions and default settings
# it cannot be just sourced, but we need only two things anyway
OS_DEFAULT_CONF=`cat "$OSPATH/$OSNAME/common.sh" | grep 'CUSTOMIZE_DIR:=' | awk -F':=' '{print $2}' | cut -d'"' -f2`

source "$OS_DEFAULT_CONF"
HOOKS_DIR="$CUSTOMIZE_DIR"
[ -z "$HOOKS_DIR" ] && HOOKS_DIR=`cat "$OSPATH/$OSNAME/common.sh" | grep 'DEFAULT_FILE=' | cut -d'=' -f2`

# some logic to define the Linux flavor will be here

prepare_file "$rpath/network_if.debian.tmpl"
cp "$rpath/network_if.debian" "$HOOKS_DIR"/
chmod 755 "$HOOKS_DIR/network_if.debian"
export M_TMPDIR=$TMPDIR

request && echo "`date +"%m.%d %H:%M"` ganeti/start_server: request sent">>"${rpath}"/../../logs/cloud.log
wait_ready
idev=`find_idev $ip`
if [ -n "$idev" ]; then
  $ROUTE add -host $ip dev $idev
else
  echo "Instance started, but tap device doesn't exist"
fi


