#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

solve() {
bc << EOF
scale=2
${1}
EOF
}

rcommand=${0##*/}
rpath=${0%/*}
#*/ (this is needed to fix vi syntax highlighting)

SSH=`which ssh 2>/dev/null`
[ -n "$SSH" ] || (echo "No ssh found" && exit 1)

possible_options="metric help from to ip"
necessary_options="metric ip"
#[ "X$*" == "X" ] && echo "Can't run without options. Possible options are: ${possible_options}" && exit 1
for s_option in "${@}"
do
  found=0
  case ${s_option} in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo "Wrong syntax: options must start with a double dash"
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  for option in `echo $possible_options | sed 's/,//g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=${s_optarg}" && found=1
  done
  [ "X$s_option" == "X$s_param" ] && found=1
  if [[ found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
if [ "X$help" == "Xyes" ] ; then
  echo "Usage: ${0##*/} --metric=metric <options>"
  echo 
  echo "Without --from a graph for the last 600 * \$FREQ will be generated"
  echo "(see mon.conf). The --to option is ignored in this case."
  echo "With --from but without --to the latter defaults to the current time."
  echo
  echo "Options:"
  echo
  echo "  --from=<start time in any format acceptable by the 'date' utility>"
  echo "  --to=<end time in any format acceptable by the 'date' utility>"
  echo "  --metric=<check sqlite3 sysdata '.schema sysdata' to see all metrics>"
  exit 0
fi
found=0

for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found"
  exit 1
fi

source ${rpath}/conf/dash.conf
TMPDIR=/tmp/m_script
install -d $TMPDIR
[ -n "$graphH" ] && [ -n "$graphV" ] || (echo "Define graph size please" && exit 1)
[ -n "$padding" ] || padding=20
[ -n "$legend" ] || legend=60
areaH=`expr $graphH - 2 \* $padding - $legend`
areaV=`expr $graphV - 2 \* $padding - $legend`
if [ -n "$from" ] ; then
  from=`date -d "$from" +"%s"`
  if [ -n "$to" ] ; then
    to=`date -d "$to" +"%s"`
  else
    to=`date -u +"%s"`
  fi
else
  from=`date -u +"%s"` ; from=`expr $from - $areaH \* $freqdef`
  to=`date -u +"%s"`
fi

if [ ! -f "${rpath}/servers.list" ] ; then
  echo "Create ${rpath}/servers.list please" | tee -a "${rpath}/dashboard.log"
  exit 1
fi
if [ ! -f "${rpath}/conf/clusters.conf" ] ; then
  echo "Create ${rpath}/conf/clusters.conf please" | tee -a "${rpath}/dashboard.log"
  exit 1
fi
server=`grep "^${ip}|" "${rpath}/servers.list"|tail -1`
if [ -z "$server" ] ; then
  echo "Server with IP ${ip} not found in ${rpath}/servers.list" | tee -a "${rpath}/dashboard.log"
  exit 1
fi
sIP=`echo $server | cut -d'|' -f1`
skey=`echo $server | cut -d'|' -f2`
scluster=`echo $server | cut -d'|' -f5`
spath=`cat ${rpath}/conf/clusters.conf|grep "^${scluster}|"|tail -1|cut -d'|' -f8`
if [ -n "$skey" ] && [ -f "${rpath}/keys/${skey}.pem" ] ; then
  thekey="-i ${rpath}/keys/${skey}.pem"
fi
rm -f ${TMPDIR}/graph.${sIP}.${metric}*
$SSH $thekey -o StrictHostKeyChecking=no $sIP "sqlite3 \"${spath}/sysdata\" \"select timeindex, $metric from sysdata where timeindex between $from and $to;\"" > ${TMPDIR}/graph.${sIP}.${metric}
if [ `cat ${TMPDIR}/graph.${sIP}.${metric} | wc -l` -le 5 ] ; then
  echo "Too few data for graph. Might be ssh error." >> "${rpath}/dashboard.log"
  exit 1
fi
minmax=`$SSH $thekey -o StrictHostKeyChecking=no $sIP "sqlite3 \"${spath}/sysdata\" \"select min($metric), max($metric) from sysdata where timeindex between $from and $to\""`
metricmin=`echo $minmax|cut -d'|' -f1` ; metricmin=${metricmin%.*}
metricmax=`echo $minmax|cut -d'|' -f2` ; metricmax=${metricmax%.*}

perdotY=`expr \( $metricmax - $metricmin \) / $areaV`
[[ $perdotY -lt 1 ]] && perdotY=1
perdotX=`expr \( $to - $from \) / $areaH`
[[ $perdotX -lt 1 ]] && perdotX=1
firstdot=1

while read LINE
do
  X=`echo $LINE | cut -d'|' -f1`
  Y=`echo $LINE | cut -d'|' -f2` ; Y=${Y%.*}
  X=`expr \( $X - $from \) / $perdotX + $padding + $legend`
  Y=`expr $graphV - $padding - $legend - \( $Y - $metricmin \) / $perdotY`
  [ "X$firstdot" == "X1" ] && printf "line $X,$Y " >> ${TMPDIR}/graph.${sIP}.${metric}.dots
  [ "X$firstdot" != "X1" ] && printf "$X,$Y line $X,$Y " >> ${TMPDIR}/graph.${sIP}.${metric}.dots
  firstdot=0
done<${TMPDIR}/graph.${sIP}.${metric}
printf "$X,$Y" >> ${TMPDIR}/graph.${sIP}.${metric}.dots

# 20 to 40 pixels

countminX=20
countminY=20

# How many pixels one hour takes
hourX=`expr 3600 / $perdotX`
[[ $hourX -lt 1 ]] && hourX=1
# Variable looping across all X marks
currpoint=$from
startX=`expr $legend + $padding`
startY=`expr $graphV - $legend - $padding`
mX1=`expr $startY + 2`
mX2=$padding
mY1=`expr $startX - 2`
mY2=`expr $graphH - $padding`
if [[ $hourX -lt $countminX ]] ; then
  # 1-hour marks would be too close to each other
  # How many hours are within 40 pixels
  hourN=`expr 2 \* $countminX / $hourX`
  # If it's more than 24 hours, try days instead:
  if [[ $hourN -ge 24 ]] ; then
    echo "Trying days"
    # How many pixels 1 day takes
    dayX=`expr 86400 / $perdotX`
    [[ $dayX -lt 1 ]] && dayX=1
    if [[ $dayX -lt $countminX ]] ; then
      # How many days are within 40 pixels
      dayN=`expr 2 \* $countminX / $dayX`
      # If it's more than 30 days, use months instead:
      if [[ $dayN -ge 30 ]] ; then
        # How many pixels are there in one month
        monthX=`expr 2592000 / $perdotX`
        [[ $monthX -lt 1 ]] && monthX=1
        if [[ $monthX -lt $countminX ]] ; then
        # Resolution should be this many months
          res=`expr 2 \* $countminX / $monthX`
        else
          res=1
        fi
        # Finding the next month beginning
        while [[ $currpoint -le $to ]]
        do
          currpoint=`date -d "1970/01/01 +$currpoint sec +$res month" +"%s"`
          themonth=`date -d "1970/01/01 +$currpoint" +"%m"`
          theyear=`date -d "1970/01/01 +$currpoint" +"%Y"`
          themark=`date -d "${theyear}/${themonth}/1" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          marksX="$marksX`echo "line $themark,$mX1 $themark,$mX2 "`"
        done
        unset nextmonth res monthX
      else
        echo "Using days"
        [[ $dayN -eq 0 ]] && dayN=1  # just in case
        while [[ $currpoint -le $to ]]
        do
          currpoint=`date -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
          theday=`date -d "1970/01/01 +$currpoint sec" +"%d"`
          themonth=`date -d "1970/01/01 +$currpoint sec" +"%m"`
          theyear=`date -d "1970/01/01 +$currpoint sec" +"%Y"`
          themark=`date -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          marksX="$marksX`echo "line $themark,$mX1 $themark,$mX2 "`"
        done
        unset nextday
      fi
    else
      dayN=1
      while [[ $currpoint -le $to ]]
      do
        currpoint=`date -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
        theday=`date -d "1970/01/01 +$currpoint sec" +"%d"`
        themonth=`date -d "1970/01/01 +$currpoint sec" +"%m"`
        theyear=`date -d "1970/01/01 +$currpoint sec" +"%Y"`
        themark=`date -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
        themark=`expr \( $themark - $from \) / $perdotX + $startX`
        marksX="$marksX`echo "line $themark,$mX1 $themark,$mX2 "`"
      done
    fi
    unset dayN
  else
    echo "Using hours"
    [[ $hourN -eq 0 ]] && hourN=1
    while [[ $currpoint -le $to ]]
    do
      currpoint=`date -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
      thehour=`date -d "1970/01/01 +$currpoint sec" +"%H"`
      theday=`date -d "1970/01/01 +$currpoint sec" +"%d"`
      themonth=`date -d "1970/01/01 +$currpoint sec" +"%m"`
      theyear=`date -d "1970/01/01 +$currpoint sec" +"%Y"`
      themark=`date -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
      themark=`expr \( $themark - $from \) / $perdotX + $startX`
      marksX="$marksX`echo "line $themark,$mX1 $themark,$mX2 "`"
    done
  fi
  unset hourN
else
# So 1-hour marks are far enough from each other, and it is the maximal
# resolution possible. It's the same as the previous loop actually, but
# I leave it here to possibly add more resolution like e.g. 10 minutes
  while [[ $currpoint -le $to ]]
  do
    currpoint=`date -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
    thehour=`date -d "1970/01/01 +$currpoint sec" +"%H"`
    theday=`date -d "1970/01/01 +$currpoint sec" +"%d"`
    themonth=`date -d "1970/01/01 +$currpoint sec" +"%m"`
    theyear=`date -d "1970/01/01 +$currpoint sec" +"%Y"`
    themark=`date -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
    themark=`expr \( $themark - $from \) / $perdotX + $startX`
    marksX="$marksX`echo "line $themark,$mX1 $themark,$mX2 "`"
  done
fi

unset nexthour theday themonth theyear themark currpoint hourX

# Now for Y
# Finding out what resolution might be
a=`expr $perdotY \* $countminY`
b=`expr 2 \* $a`
s=`expr length $b`
echo "in 40 pixels: $b"
echo "length: $s"
pof=1
for ((i=0; i<$s; i++)); do pof="${pof}0"; done
echo "power of: $pof"
res=`expr $pof / 10`
if [[ $res -lt $a ]] ; then
  res=`expr $pof / 4`
  if [[ $res -lt $a ]] ; then
    res=`expr $pof / 2`
  fi
fi
echo "resolution: $res"
# Drawing
declare -i i
res=`expr $res / $perdotY`
echo "pixel resolution: $res"
i=`expr $legend + $padding`
imax=`expr $i + $areaV`
echo "i current: $i  i max: $imax"
while true
do
  i+=$res
  [[ $i -gt $imax ]] && break
  irev=`expr ${graphV} - $i`
  marksY="$marksY`echo "line $mY1,$irev $mY2,$irev "`"
done


echo "$marksX"
echo "============================"
echo "$marksY"

datalines=`cat ${TMPDIR}/graph.${sIP}.${metric}.dots`

convert -size ${graphH}x${graphV} xc:white -fill none \
  -draw "stroke gray line $startX,$startY $mY2,$startY" \
  -draw "stroke gray line $startX,$startY $startX,$mX2" \
  -draw "stroke gray $marksX " -draw "stroke gray $marksY " \
  -draw "stroke green $datalines " \
  test.png

#  points="10,10 30,90   25,10 50,50   50,50 80,50   70,10 90,40"
#  clines=`echo "$points" | sed 's/   /\n/g' |\
#             while read line; do echo "line $line"; done`
#  symbols=`echo path "'"; for point in $points; do
#             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
#           done;  echo "'"`
#  convert -size 100x100 xc:skyblue -fill none \
#          -draw "stroke gray $clines    stroke blue $symbols " \
#          -draw "stroke red  bezier 10,10 30,90   25,10 50,50 " \
#          -draw "stroke red  bezier 50,50 80,50   70,10 90,40 " \
#          draw_bezier_disjoint.gif

# convert -size ${graphH}x${graphV} xc:white -fill none \
#  -draw "stroke gray $marksX " -draw "stroke gray $marksY" \
#  test.png




