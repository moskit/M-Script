#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

solve() {
bc << EOF
scale=2
${1}
EOF
}

addxmarks() {
  marksX="$marksX`echo "<line x1=\\"$1\\" y1=\\"$mX1\\" x2=\\"$1\\" y2=\\"$mX2\\" />"`"
  textX="${textX}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$1\\" y=\\"$mXT1\\" >$2</text>"`"
}

rcommand=${0##*/}
rpath=${0%/*}
#*/ (this is needed to fix vi syntax highlighting)

SSH=`which ssh 2>/dev/null`
[ -n "$SSH" ] || (echo "No ssh found" && exit 1)
source "${rpath}/conf/cloud.conf"
[ -n "$SSHPORT" ] || SSHPORT=22
IFCFG=`which ifconfig 2>/dev/null`
possible_options="metric help from to ip new database table size width height scale padding legend fontsize strokewidth pointsize"
necessary_options="metric"
source ${rpath}/conf/dash.conf
RSYNC=`which rsync 2>/dev/null`

#[ "X$*" == "X" ] && echo "Can't run without options. Possible options are: ${possible_options}" && exit 1
for s_option in "${@}"
do
  found=0
  case ${s_option} in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo "Wrong syntax: options must start with a double dash" >> "${rpath}/dashboard.log"
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  for option in `echo $possible_options | sed 's/,//g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=${s_optarg}" && found=1
  done
  [ "X$s_option" == "X$s_param" ] && found=1
  if [[ found -ne 1 ]]; then 
    echo "Unknown option: $s_optname" >> "${rpath}/dashboard.log"
    exit 1
  fi
done
# "metric help from to ip new database table size width height scale padding legend fontsize strokewidth pointsize"
if [ "X$help" == "Xyes" ] ; then
  echo "Usage: ${0##*/} --metric=metric <other options>"
  echo 
  echo "Without --from a graph for the default period will be generated,"
  echo "depending on the graph size and FREQ variable (see conf/dash.conf)."
  echo "The --to option is ignored in this case."
  echo "With --from but without --to the latter defaults to the current time."
  echo
  echo "Options:"
  echo
  echo "  --ip=<IP address of the server to get data from>"
  echo "           Server must be present in servers.list"
  echo "           If empty, means localhost"
  echo "  --from=<start time in any format acceptable by the 'date' utility>"
  echo "  --to=<end time in any format acceptable by the 'date' utility>"
  echo "  --metric=<check sqlite3 sysdata '.schema sysdata' to see all metrics>"
  echo "           Multiple metrics accepted, separated by comma, no spaces"
  echo "  --new  - forces getting the latest data from the server. Without this"
  echo "           option a new graph is generated using the data received by"
  echo "           the dashboard update daemon. Option --from always invokes"
  echo "           this option"
  echo "  --database=<path to database file, relative to M-Script root folder>"
  echo "           The default is sysdata"
  echo "  --table=<table name>  The default is sysdata"
  echo "  --size=<small|thumbnail>  If not defined, it's the default big graph"
  echo "  --scale  Used to create combined graphs with multiple metrics."
  echo "           This options scales graphs so that changes become visible"
  echo "           and places graphs one under another."
  echo "  --where=<field:value>  Additional WHERE clause for SQL query."
  echo "           Add escaped quotes to value if needed: field:\'value\'"
  echo
  echo "Graph format options:"
  echo
  echo "  --width, --height, --padding, --legend,"
  echo "  --fontsize, --strokewidth, --pointsize"
  echo "  These options can be used to overwrites those from conf/dash.conf."
  echo
  exit 0
fi
found=0

for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ -n "$from" ] ; then new="yes" ; fi
if [ -z "$new" ] && [ $RSYNC == "" ] ; then
  echo "Rsync is required if neither --new nor --from is present" >> "${rpath}/dashboard.log"
  exit 1
fi

[ "X$IFCFG" != "X" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//'`
if [ -n "$ip" ] ; then
  if [ `echo $sIP | grep -c "$localip"` -ne 0 ] ; then
    localip="yes"
  else
    unset localip
  fi
else
  localip="yes"
fi

TMPDIR=/tmp/m_script/dash
install -d $TMPDIR
install -d ${rpath}/www/graphs
declare -a colors
colors=( "#009900" "#000099" "#999900" "#660000" "#990099" "#009999" "#666600" "#44ff00" "#4400ff" "#00ff44" "#996644" "#994466" "#446699" "#449966" "#664499" "#669944" )

[ -n "$padding" ] || padding=20
[ -n "$legend" ] || legend=60
[ -n "$fontsize" ] || fontsize=10
[ -n "$strokewidth" ] || strokewidth=3
[ -n "$pointsize" ] || pointsize=12
[ -n "$width" ] && graphH=$width
[ -n "$height" ] && graphV=$height

[ -n "$graphH" ] && [ -n "$graphV" ] || (echo "Define graph size in conf/dash.conf or as command-line options >> "${rpath}/dashboard.log"" && exit 1)
if [ "X$size" == "Xsmall" ] ; then
  graphH=`expr $graphH / 2`
  graphV=`expr $graphV / 2`
  padding=`expr $padding / 2`
  legend=`expr $legend / 2`
  fontsize=`expr $fontsize - 2`
  strokewidth=2
  pointsize=`expr $pointsize / 2`
fi
if [ "Xsize" == "Xthumbnail" ] ; then
  graphH=`expr $graphH / 4`
  graphV=`expr $graphV / 4`
  padding=`expr $padding / 4`
  legend=`expr $legend / 4`
  fontsize=`expr $fontsize - 4`
  strokewidth=1
  pointsize=`expr $pointsize / 4`
fi
areaH=`expr $graphH - 2 \* $padding - $legend`
areaV=`expr $graphV - 2 \* $padding - $legend`

# the idea is to work entirely in UTC (timestamps in the db is UTC as well)
# only X axis marks are converted to server local time
if [ -n "$from" ] ; then
# whatever you provide as --from, it is supposed to be UTC unless you provided
# the time zone. In this latter case it will be converted to UTC, not just
# considered to be UTC
  tfrom=`date -u -d "$from"`
  from=`date -u -d "$from" +"%s"`
  if [ -n "$to" ] ; then
    tto=`date -u -d "$to"`
    to=`date -d "$to" +"%s"`
  else
    to=`date +"%s"`
    tto=`date -u`
  fi
else
  from=`date +"%s"` # this is always UTC
  from=`expr $from - $areaH \* $freqdef`
  tfrom=`date -u -d "1970/01/01 +$from sec"`
  to=`date +"%s"`
  tto=`date -u`
fi
title="Graph: $metric from $tfrom to $tto"
#tlength=`expr length $title`
echo "`date +"%d/%m %H:%M"` Generating graph $metric from $tfrom to $tto" >> "${rpath}/dashboard.log"
if [ ! -f "${rpath}/servers.list" ] ; then
  echo "Create ${rpath}/servers.list please" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ ! -f "${rpath}/conf/clusters.conf" ] ; then
  echo "Create ${rpath}/conf/clusters.conf please" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ -z "$localip" ] ; then
  server=`grep "^${ip}|" "${rpath}/servers.list"|tail -1`
  if [ -z "$server" ] ; then
    echo "Server with IP ${ip} not found in ${rpath}/servers.list" >> "${rpath}/dashboard.log"
    exit 1
  fi
  sIP=`echo $server | cut -d'|' -f1`
  skey=`echo $server | cut -d'|' -f2`
  scluster=`echo $server | cut -d'|' -f5`
  mpath=`cat ${rpath}/conf/clusters.conf|grep "^${scluster}|"|tail -1|cut -d'|' -f8`
  [ -z "$mpath" ] && echo "M-Script path for server $server not found" >> "${rpath}/dashboard.log" && exit 1
  if [ -n "$skey" ] && [ -f "${rpath}/keys/${skey}.pem" ] ; then
    thekey="-i ${rpath}/keys/${skey}.pem"
  fi
else
  sIP="localhost"
fi

[ -z "$database" ] && database="sysdata"
dbname=`echo "$database" | tr '/' '_'`
[ -z "$table" ] && table="sysdata"

######     Getting min and max values from database

#minmax=`$SSH $thekey -o StrictHostKeyChecking=no $sIP "sqlite3 \"${rpath}/sysdata\" \"select min($metric), max($metric) from sysdata where timeindex between $from and $to\""`
#metricminfp=`echo $minmax|cut -d'|' -f1` ; metricmin=${metricminfp%.*}
#metricmaxfp=`echo $minmax|cut -d'|' -f2` ; metricmax=${metricmaxfp%.*}
#if [ -z "$metricminfp" ] || [ -z "$metricmaxfp" ] ; then
#  echo "Error getting minimum and maximum values for $metric from $from to $to" >> "${rpath}/dashboard.log"
#  exit 1
#fi
#[ -z "$metricmin" ] && metricmin=0
#[ -z "$metricmax" ] && metricmax=0

## Ideally we want 3 meaningful digits
#if [ `expr length $metricmax` -lt 3 ] ; then
#  metricmaxdec=`expr length ${metricmaxfp#*.}`
#  if [[ $metricmaxdec -eq 0 ]] ; then
#    mp=10
#  else
#    mp=1 ; for ((i=0; i<$metricmaxdec; i++)) ; do mp="${mp}0" ; done
#  fi
#  QUERY="select timeindex, ${metric}*${mp} from sysdata where timeindex between $from and $to;"
#  metricmin=`solve "$metricminfp * $mp"` ; metricmin=${metricmin%.*}
#  metricmax=`solve "$metricmaxfp * $mp"` ; metricmax=${metricmax%.*}
#else
#  QUERY="select timeindex, $metric from sysdata where timeindex between $from and #$to;"
#fi
#$SSH $thekey -o StrictHostKeyChecking=no $sIP "sqlite3 \"${rpath}/sysdata\" \"${QUERY}\"" > ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}
#if [ `cat ${TMPDIR}/graph.${sIP}.${dbname}.${smetric} | wc -l` -le 5 ] ; then
#  echo "Too few data for graph. Might be connection to ${sIP} problems. Graph is not generated." >> "${rpath}/dashboard.log"
#  exit 1
#fi
########

########    The part above, but with getting min and max from the file

metricmin=0
metricmax=0
# Using fixed multiplyer to avoid double querying
mp=100
name=`echo $metric | tr ',' '_'`
qmetric="timeindex"
for smetric in `echo $metric | tr ',' ' '` ; do
  rm -f ${TMPDIR}/graph.${sIP}.${dbname}.${smetric} 2>/dev/null
  qmetric="${qmetric}, ${smetric}*${mp}"
done
  
if [ -n "$new" ] ; then
  QUERY="SELECT $qmetric FROM $table WHERE timeindex BETWEEN $from AND $to"
  if [ -n "$where" ] ; then
    field=${where%%:*}
    value=${where#*:}
    QUERY="$QUERY AND $field=$value" 
  fi
  if [ "X$sIP" == "Xlocalhost" ] ; then
    sqlite3 "${rpath}/${database}" "${QUERY}" > ${TMPDIR}/graph.${sIP}.${dbname}.${name} || echo "Problem getting ${smetric} data from ${rpath}/${database}, server $sIP" >> "${rpath}/dashboard.log"
  else
  # -o StrictHostKeyChecking=no 
    $SSH $thekey -p $SSHPORT $sIP "sqlite3 \"${mpath}/${database}\" \"${QUERY}\"" > ${TMPDIR}/graph.${sIP}.${dbname}.${name} || echo "Problem getting data from ${rpath}/${database}, server $sIP" >> "${rpath}/dashboard.log"
  fi
  if [ `cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | wc -l` -le 1 ] ; then
    echo "Too little data for graph. Might be connection to ${sIP} problems. Graph is not generated." >> "${rpath}/dashboard.log"
    exit 1
  fi
fi
declare -i n
n=2
for smetric in `echo $metric | tr ',' ' '` ; do
  smax=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | sort -n | tail -1` ; smax=${smax%.*}
  smin=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | grep -v ^$ | sort -n | head -1` ; smin=${smin%.*}
  [[ $metricmax -eq 0 ]] && metricmin=$smax
  [ -z "$metricmin" ] && metricmin=0
  [[ $smax -gt $metricmax ]] && metricmax=$smax
  [[ $smin -lt $metricmin ]] && metricmin=$smin
  n+=1
done

if [ "X$scale" == "Xyes" ] ; then
  sn=`echo $metric | tr ',' ' ' | wc -w`
  sadd=`solve "($metricmax - $metricmin) / $sn"` 2>/dev/null || sadd=`solve "$metricmax / $sn"` 2>/dev/null || sadd=10
  snadd=0
  n=2
  for smetric in `echo $metric | tr ',' ' '` ; do
    rm -f ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled 2>/dev/null
    smax=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | sort -n | tail -1`
    if [ -n "$smax" ] ; then
      [ `echo "$smax == 0" | bc` -ne 1 ] && sratio=`solve "$metricmax / $smax / $sn / 1.2"` || sratio=1
      for LINE in `cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f1,${n}` ; do
        st=`echo $LINE | cut -d'|' -f1`
        [ -z "$st" ] && continue
        sd=`echo $LINE | cut -d'|' -f2`
        [ -z "$sd" ] && continue
        sds=`solve "$sd * $sratio + $snadd"`
        echo "${st}|${sds}" >> ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled
      done
    fi
    snadd=`solve "$snadd + $sadd"`
    n+=1
  done
fi

perdotY=`expr \( $metricmax - $metricmin \) / $areaV + 1`
[[ $perdotY -lt 1 ]] && perdotY=1
perdotX=`expr \( $to - $from \) / $areaH + 1`
[[ $perdotX -lt 1 ]] && perdotX=1

# 20 to 40 pixels

countminX=20
countminY=20

# How many pixels one hour takes
hourX=`expr 3600 / $perdotX`
[[ $hourX -lt 1 ]] && hourX=1
# Variable looping across all X marks
currpoint=$from
# Various coordinates
# 0:0 coordinate
startX=`expr $legend + $padding`
startY=`expr $graphV - $legend - $padding`
# Vertical grid lines
mX1=`expr $startY + 2`
mXT1=`expr $mX1 + 14`
mX2=$padding
# Horisontal grid lines
mY1=`expr $startX - 2`
mYT1=`expr $mY1 - 50`
mY2=`expr $graphH - $padding`
# Axis names coordinates
axisXX=`expr $graphH - $padding - 60`
axisXY=`expr $graphV - $legend + 20`
axisYX=$padding
axisYY=$padding

#titleX=`expr \( $graphH - $tlength \) / 2`
titleX=`expr $padding + $legend + 20`
titleY=`expr $graphV - $padding`
if [[ $hourX -lt $countminX ]] ; then
  # 1-hour marks would be too close to each other
  # How many hours are within 40 pixels
  hourN=`expr 2 \* $countminX / $hourX`
  # If it's more than 24 hours, try days instead:
  if [[ $hourN -ge 24 ]] ; then
    #echo "Trying days"
    # How many pixels 1 day takes
    dayX=`expr 86400 / $perdotX`
    [[ $dayX -lt 1 ]] && dayX=1
    if [[ $dayX -lt $countminX ]] ; then
      # How many days are within 40 pixels
      dayN=`expr 2 \* $countminX / $dayX`
      # If it's more than 30 days, use months instead:
      if [[ $dayN -ge 30 ]] ; then
        # How many pixels are there in one month
        monthX=`expr 2592000 / $perdotX`
        [[ $monthX -lt 1 ]] && monthX=1
        if [[ $monthX -lt $countminX ]] ; then
        # Resolution should be this many months
          res=`expr 2 \* $countminX / $monthX`
        else
          res=1
        fi
        axisX="months"
        # Finding the next month beginning
        while [[ $currpoint -lt $to ]]
        do
          currpoint=`date -u -d "1970/01/01 +$currpoint sec +$res month" +"%s"`
          themonth=`date -u -d "1970/01/01 +$currpoint" +"%m"`
          theyear=`date -u -d "1970/01/01 +$currpoint" +"%Y"`
          themark=`date -u -d "${theyear}/${themonth}/1" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          [[ $themark -gt $mY2 ]] && break
          textmark=`date -u -d "1970/01/01 +$currpoint sec"`
          textmark=`date -d "$textmark" +"%m"`
          addxmarks $themark $textmark
        done
        unset nextmonth res monthX
      else
        #echo "Using days"
        axisX="days"
        [[ $dayN -eq 0 ]] && dayN=1  # just in case
        while [[ $currpoint -lt $to ]]
        do
          currpoint=`date -u -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
          theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
          themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
          theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
          themark=`date -u -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          [[ $themark -gt $mY2 ]] && break
          textmark=`date -u -d "1970/01/01 +$currpoint sec"`
          textmark=`date -d "$textmark" +"%d"`
          addxmarks $themark $textmark
        done
        unset nextday
      fi
    else
      dayN=1
      axisX="days"
      while [[ $currpoint -lt $to ]]
      do
        currpoint=`date -u -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
        theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
        themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
        theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
        themark=`date -u -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
        themark=`expr \( $themark - $from \) / $perdotX + $startX`
        [[ $themark -gt $mY2 ]] && break
        textmark=`date -u -d "1970/01/01 +$currpoint sec"`
        textmark=`date -d "$textmark" +"%d"`
        addxmarks $themark $textmark
      done
    fi
    unset dayN
  else
    axisX="hours"
    [[ $hourN -eq 0 ]] && hourN=1
    while [[ $currpoint -lt $to ]]
    do
      currpoint=`date -u -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
      thehour=`date -u -d "1970/01/01 +$currpoint sec" +"%H"`
      theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
      themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
      theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
      themark=`date -u -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
      themark=`expr \( $themark - $from \) / $perdotX + $startX`
      [[ $themark -gt $mY2 ]] && break
      textmark=`date -u -d "1970/01/01 +$currpoint sec"`
    textmark=`date -d "$textmark" +"%H"`
      addxmarks $themark $textmark
    done
  fi
  unset hourN
else
# So 1-hour marks are far enough from each other, and it is the maximal
# resolution possible. It's the same as the previous loop actually, but
# I leave it here to possibly add more resolution like e.g. 10 minutes
  axisX="hours"
  while [[ $currpoint -lt $to ]]
  do
    currpoint=`date -u -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
    thehour=`date -u -d "1970/01/01 +$currpoint sec" +"%H"`
    theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
    themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
    theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
    themark=`date -u -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
    themark=`expr \( $themark - $from \) / $perdotX + $startX`
    [[ $themark -gt $mY2 ]] && break
    textmark=`date -u -d "1970/01/01 +$currpoint sec"`
    textmark=`date -d "$textmark" +"%H"`
    addxmarks $themark $textmark
  done
fi

unset nexthour theday themonth theyear themark currpoint hourX

# Now for Y
# Finding out what resolution might be
a=`expr $perdotY \* $countminY`
b=`expr 2 \* $a`
s=`expr length $b`
pof=1
for ((i=0; i<$s; i++)); do pof="${pof}0"; done
res=`expr $pof / 10`
if [[ $res -lt $a ]] ; then
  res=`expr $pof / 4`
  if [[ $res -lt $a ]] ; then
    res=`expr $pof / 2`
  fi
fi

# Drawing
declare -i i
declare -i imark
imark=`expr $metricmin / $res \* $res`
shiftY=`expr $metricmin - $imark`
ires=`expr $res / $perdotY`
i=`expr $legend + $padding`
imax=`expr $i + $areaV`
while true
do
  i+=$ires
  imark+=$res
  [[ $i -gt $imax ]] && break
  # Freeing some room for axis Y title
  [[ `expr $i + $ires` -gt $imax ]] && unset imark imarkfp
  irev=`expr ${graphV} - $i`
  marksY="$marksY`echo "<line x1=\\"$mY1\\" y1=\\"$irev\\" x2=\\"$mY2\\" y2=\\"$irev\\" />"`"
  if [ "X$scale" != "Xyes" ] ; then
    if [ -n "$mp" ] ; then
      [ -n "$imark" ] && imarkfp=`solve "$imark/$mp"`
      textY="${textY}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$mYT1\\" y=\\"$irev\\" >$imarkfp</text>"`"
    else
      textY="${textY}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$mYT1\\" y=\\"$irev\\" >$imark</text>"`"
    fi
  fi
done

cat "${rpath}/wwwtemplates/graph.head.svg.tmpl" > "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"$graphH\" height=\"$graphV\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Axis
echo "<g id=\"axis\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf "<path id=\"y\" style=\"fill:none;stroke:#000;stroke-width:$strokewidth\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf " $startX,$startY $startX,$mX2" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf "<path id=\"x\" style=\"fill:none;stroke:#000;stroke-width:2\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf " $startX,$startY $mY2,$startY" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Marks
echo "<g id=\"marks\" style=\"fill:none;stroke:#999;stroke-width:1;\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $marksX >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $marksY >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<g id=\"marks_text\" text-rendering=\"optimizeSpeed\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $textX >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
[ "X$scale" == "Xyes" ] || echo $textY >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<text font-family=\"Verdana\" font-size=\"${fontsize}\" fill=\"#666\" x=\"$axisXX\" y=\"$axisXY\">$axisX</text>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
[ "X$scale" == "Xyes" ] || echo "<text x=\"$axisYX\" y=\"$axisYY\" font-family=\"Verdana\" font-size=\"${fontsize}\" fill=\"#666\">$axisY</text>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Graphs
i=0
startlegendX=`solve "$startX - $legend"`
slegendY=$startY
sadd=`expr \( $graphV - $legend - $padding \) / $sn`
echo "<g id=\"graph\" shape-rendering=\"geometricPrecision\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
n=2
for smetric in `echo $metric | tr ',' ' '` ; do
  slegend="${slegend}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"${colors[$i]}\\" x=\\"$startlegendX\\" y=\\"$slegendY\\" >$smetric</text>"`"
  slegendY=`solve "$slegendY - $sadd"`
  printf "<path id=\"graph_${smetric}\" style=\"fill:none;stroke:${colors[$i]};stroke-width:${strokewidth}\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  if [ "X$scale" == "Xyes" ] ; then cat ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled ; else cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f1,${n} ; fi | while read LINE
  do
    X=`echo $LINE | cut -d'|' -f1`
    Y=`echo $LINE | cut -d'|' -f2` ; Y=${Y%.*}
    if [ "X$X" == "X" ] || [ "X$Y" == "X" ] ; then echo "No data" ; continue ; fi
    X=`expr \( $X - $from \) / $perdotX + $padding + $legend`
    Y=`expr $graphV - $padding - $legend - \( $Y - $metricmin + $shiftY \) / $perdotY`
    printf " $X,$Y" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  done
  echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  i+=1
  n+=1
done
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<g id=\"legend\" text-rendering=\"optimizeSpeed\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "$slegend" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</svg>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

#convert -size ${graphH}x${graphV} xc:white -family $fontfamily -pointsize $fontsize \
#  -strokewidth $strokewidth \
#  -draw "stroke black line $startX,$startY $mY2,$startY" \
#  -draw "stroke black line $startX,$startY $startX,$mX2" \
#  -strokewidth 1 \
#  -draw "stroke gray $marksX " -draw "stroke gray $marksY " \
#  -draw "$textY " -draw "$textX " \
#  -draw "${datalines}" \
#  -draw "text $axisXX,$axisXY `printf "\'$axisX\'"`" \
#  -draw "text $axisYX,$axisYY `printf "\'$metric\'"`" \
#  -pointsize $pointsize \
#  -draw "text $titleX,$titleY `printf "\'$title\'"`" \
#  "${rpath}/www/graphs/${sIP}.${dbname}${name}.png"






