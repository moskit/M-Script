#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

solve() {
bc << EOF
scale=2
${1}
EOF
}

addxmarks() {
  marksX="$marksX`echo "<line x1=\\"$1\\" y1=\\"$mX1\\" x2=\\"$1\\" y2=\\"$mX2\\" />"`"
  textX="${textX}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$1\\" y=\\"$mXT1\\" >$2</text>"`"
}

rcommand=${0##*/}
rpath=${0%/*}
#*/

SSH=`which ssh 2>/dev/null`
[ -n "$SSH" ] || (echo "No ssh found" && exit 1)
source "${rpath}/conf/cloud.conf"
[ -n "$SSHPORT" ] || SSHPORT=22
IFCFG=`which ifconfig 2>/dev/null`
possible_options="metric help from to ip new database table size width height scale padding legend fontsize strokewidth pointsize where as legendpos perpixel"
necessary_options="metric"
source "${rpath}/conf/mon.conf"
source "${rpath}/conf/dash.conf"

RSYNC=`which rsync 2>/dev/null`
SQL3=`which sqlite3 2>/dev/null` # assuming that remote path is the same

for s_option in "${@}"
do
  found=0
  case ${s_option} in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo "Wrong syntax: options must start with a double dash" >> "${rpath}/dashboard.log"
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  for option in `echo $possible_options | sed 's/,//g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=${s_optarg}" && found=1
  done
  [ "X$s_option" == "X$s_param" ] && found=1
  if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname" >> "${rpath}/dashboard.log"
    exit 1
  fi
done
# "metric help from to ip new database table size width height scale padding legend fontsize strokewidth pointsize"
if [ "X$help" == "Xyes" ] ; then
cat << "EOF"
Usage: ${0##*/} --metric=metric <other options>

Without --from a graph for the default period will be generated,
depending on the graph size and FREQ variable (see conf/dash.conf).
The --to option is ignored in this case.
With --from but without --to the latter defaults to the current time.

Options:

--ip=<IP>               IP address of the server to get data from
                        Server must be present in servers.list
                        If empty, means localhost
                    
--from=<date/time>      time of the beginning of the graph in any format
                        acceptable by the 'date' utility

--to=<date/time>        graph end time in any format acceptable by the 'date'
                        utility

--metric=<metric>       metric = database field name
                        Multiple metrics accepted, separated by comma, no spaces
                    
--new                   forces getting the latest data from the server.
                        Without this option a new graph is generated using the
                        data received by the dashboard update daemon.
                        Option --from always invokes this option
                    
--database=<path/to/database>
                        path to database file, relative to M-Script root folder
                        The default is sysdata
                    
--table=<table name>    The default is sysdata

--size=<small|thumbnail>
                        If not defined, it's the default big graph
                        
--scale                 Used to create combined graphs with multiple metrics.
                        This options scales graphs so that changes become visible
                        and places graphs one under another.
                        
--where=<field:value>   Additional WHERE clause for SQL query.
                        Add escaped quotes to value if needed: field:\'value\'
                        
--as=<name>             New name for metric. Especially useful if metric is an
                        ariphmetic expression like:
                        --metric=\"\(metric1+metric2\)\" --as=MyMetric
                        
--legendpos=<left|below>

Graph format options:

  --width, --height, --padding, --legend,           These options can be used
  --fontsize, --strokewidth, --pointsize            to overwrites those from
                                                    conf/dash.conf.
  
  
EOF
  exit 0
fi
found=0

for option in `echo $necessary_options | sed 's/,//g'`; do
  [ "X$(eval echo \$$option)" == "X" ] && missing_options="${missing_options}, --${option}" && found=1
done
if [[ found -eq 1 ]]; then
  missing_options=${missing_options#*,}
  echo "Necessary options: ${missing_options} not found" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ -n "$from" ] ; then new="yes" ; fi
if [ -z "$new" ] && [ $RSYNC == "" ] ; then
  echo "Rsync is required if neither --new nor --from is present" >> "${rpath}/dashboard.log"
  exit 1
fi

[ "X$IFCFG" != "X" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//'`
if [ -n "$ip" ] ; then
  if [ `echo $sIP | grep -c "^$localip$"` -ne 0 ] ; then
    localip="yes"
  else
    unset localip
  fi
else
  localip="yes"
fi

TMPDIR="$TMPDIR"/dash
install -d "$TMPDIR"
install -d "${rpath}/www/graphs"
declare -a colors
colors=( "#009900" "#000099" "#999900" "#660000" "#990099" "#009999" "#666600" "#44ff00" "#4400ff" "#00ff44" "#996644" "#994466" "#446699" "#449966" "#664499" "#669944" )

##################################
#### Definitions and defaults ####
##################################

[ -n "$padding" ] || padding=20
[ -n "$axis" ] || axis=40
[ -n "$legend" ] || legend=60
[ -n "$fontsize" ] || fontsize=10
[ -n "$strokewidth" ] || strokewidth=2
[ -n "$pointsize" ] || pointsize=12
[ -n "$width" ] && graphH=$width
[ -n "$height" ] && graphV=$height
[ -n "$graphH" ] && [ -n "$graphV" ] || (echo "Define graph size in conf/dash.conf or as command-line options >> "${rpath}/dashboard.log"" && exit 1)
if [ "X$size" == "Xsmall" ] ; then
  graphH=`expr $graphH / 2`
  graphV=`expr $graphV / 2`
  padding=`expr $padding / 2`
  axis=`expr $axis / 2`
  legend=`expr $legend / 2`
  fontsize=`expr $fontsize - 2`
  strokewidth=1
  pointsize=`expr $pointsize / 2`
fi
if [ "Xsize" == "Xthumbnail" ] ; then
  graphH=`expr $graphH / 4`
  graphV=`expr $graphV / 4`
  padding=`expr $padding / 4`
  axis=`expr $axis / 4`
  legend=`expr $legend / 4`
  fontsize=`expr $fontsize - 4`
  strokewidth=1
  pointsize=`expr $pointsize / 4`
fi

[ -z "$legendpos" ] && legendpos=left
[ "$legendpos" == "left" ] && legendH=$legend && legendV=0
[ "$legendpos" == "below" ] && legendH=0 && legendV=$legend
areaH=`expr $graphH - 2 \* $padding - $legendH - $axis`
areaV=`expr $graphV - 2 \* $padding - $legendV - $axis`

#####################
#### Time period ####
#####################

# perpixel option makes time period obsolete
if [ -z "$perpixel" ] ; then
  # the idea is to work entirely in UTC (timestamps in the db is UTC as well)
  # only X axis marks are converted to server local time
  if [ -n "$from" ] ; then
  # whatever you provide as --from, it is supposed to be UTC unless you provided
  # the time zone. In this latter case it will be converted to UTC, not just
  # considered to be UTC
    tfrom=`date -u -d "$from"`
    from=`date -u -d "$from" +"%s"`
    if [ -n "$to" ] ; then
      tto=`date -u -d "$to"`
      to=`date -d "$to" +"%s"`
    else
      to=`date +"%s"`
      tto=`date -u`
    fi
  else
    from=`date +"%s"` # this is always UTC
    from=`expr $from - $areaH \* $freqdef`
    tfrom=`date -u -d "1970/01/01 +$from sec"`
    to=`date +"%s"`
    tto=`date -u`
  fi
  title="Graph: $metric from $tfrom to $tto"
  #tlength=`expr length $title`
  echo "`date +"%d/%m %H:%M"` Generating graph $metric from $tfrom to $tto" >> "${rpath}/dashboard.log"
else
  title="Graph: $metric"
  echo "`date +"%d/%m %H:%M"` Generating graph ${metric}, last $areaH values">> "${rpath}/dashboard.log"
fi

##############################
#### Servers and clusters ####
##############################

if [ ! -f "${rpath}/servers.list" ] ; then
  echo "Create ${rpath}/servers.list please" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ ! -f "${rpath}/conf/clusters.conf" ] ; then
  echo "Create ${rpath}/conf/clusters.conf please" >> "${rpath}/dashboard.log"
  exit 1
fi
if [ -z "$localip" ] ; then
  server=`grep "^${ip}|" "${rpath}/servers.list"|tail -1`
  if [ -z "$server" ] ; then
    echo "Server with IP ${ip} not found in ${rpath}/servers.list" >> "${rpath}/dashboard.log"
    exit 1
  fi
  sIP=`echo $server | cut -d'|' -f1`
  skey=`echo $server | cut -d'|' -f2`
  scluster=`echo $server | cut -d'|' -f5`
  mpath=`cat ${rpath}/conf/clusters.conf|grep "^${scluster}|"|tail -1|cut -d'|' -f8`
  [ -z "$mpath" ] && echo "M-Script path for server $server not found" >> "${rpath}/dashboard.log" && exit 1
  [ -f "${rpath}/keys/${skey}" ] && thekey="-i ${rpath}/keys/${skey}"
  [ -z "$thekey" -a -f "${rpath}/keys/${skey}.pem" ] && thekey="-i ${rpath}/keys/${skey}.pem"
else
  sIP="localhost"
fi

###########################
#### Querying the data ####
###########################

[ -z "$database" ] && database="sysdata"
dbname=`echo "$database" | tr '/' '_'`
[ -z "$table" ] && table="sysdata" || dbname="${dbname}_${table}"
[ -n "$where" ] && dbname="${dbname}_`echo "$where" | tr -d \\ | tr -d \' | tr ':' '_' | tr ' ' '_'`"

if [ -n "$perpixel" ]; then
  expr $perpixel / 1 >/dev/null 2>&1 || perpixel=1
  limit=$(($areaH/$perpixel))
###### Getting min and max values from database
  minmaxQ="select min($metric)*1000, max($metric)*1000 from (select $metric from $table order by timeindex desc limit $limit)"
  if [ "$sIP" == "localhost" ]; then
    minmax=`$SQL3 "${rpath}/$database" "$minmaxQ"`
  else
    minmax=`$SSH $thekey -p $SSHPORT $sIP "$SQL3 \"${rpath}/$database\" \"$minmaxQ\""`
  fi
  metricminfp=`echo $minmax|cut -d'|' -f1` ; metricmin=${metricminfp%.*}
  metricmaxfp=`echo $minmax|cut -d'|' -f2` ; metricmax=${metricmaxfp%.*}
  if [ -z "$metricminfp" -o -z "$metricmaxfp" ] ; then
    echo "Error getting minimum and maximum values for $metric $limit last values" >> "${rpath}/dashboard.log"
    exit 1
  fi
  [ -z "$metricmin" ] && metricmin=0
  [ -z "$metricmax" ] && metricmax=$areaV

  mp=`solve "$areaV / $metrixmax"`
  
  QUERY="select ${metric}*${mp} from $table order by timeindex desc limit $limit"
  
  if [ "$sIP" == "localhost" ]; then
    $SQL3 "${rpath}/$database" "${QUERY}" > ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}
  else
    $SSH $thekey -p $SSHPORT $sIP "$SQL3 \"${rpath}/$database\" \"${QUERY}\"" > ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}
  fi
  if [ `cat ${TMPDIR}/graph.${sIP}.${dbname}.${smetric} | wc -l` -le 5 ] ; then
    echo "Too few data for graph. Might be connection to ${sIP} problems. Graph is not generated." >> "${rpath}/dashboard.log"
    exit 1
  fi

########
else
##  Same as above, but with getting min and max from the file

  metricmin=0
  metricmax=0
  # Using fixed multiplyer to avoid double querying
  mp=100
  if [ -n "$as" ] ; then
    name=$as
  else
    name=`echo $metric | tr ',' '_'`
  fi
  qmetric="timeindex"
  for smetric in `echo $metric | tr ',' ' '` ; do
    rm -f ${TMPDIR}/graph.${sIP}.${dbname}.${smetric} 2>/dev/null
    qmetric="${qmetric}, ${smetric}*${mp}"
  done
    
  if [ -n "$new" ] ; then
    QUERY="SELECT $qmetric FROM $table WHERE timeindex BETWEEN $from AND $to"
    if [ -n "$where" ] ; then
      field=${where%%:*}
      value=${where#*:}
      QUERY="$QUERY AND $field=$value" 
    fi
    if [ "X$sIP" == "Xlocalhost" ] ; then
      $SQL3 "${rpath}/${database}" "${QUERY}" > ${TMPDIR}/graph.${sIP}.${dbname}.${name} || echo "Problem getting ${smetric} data from ${rpath}/${database}, server $sIP" >> "${rpath}/dashboard.log"
    else
    # -o StrictHostKeyChecking=no 
      $SSH $thekey -p $SSHPORT $sIP "$SQL3 \"${mpath}/${database}\" \"${QUERY}\"" > ${TMPDIR}/graph.${sIP}.${dbname}.${name} || echo "Problem getting data from ${rpath}/${database}, server $sIP" >> "${rpath}/dashboard.log"
    fi
    if [ `cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | wc -l` -le 1 ] ; then
      echo "Too little data for graph. Might be connection to ${sIP} problems. Graph is not generated." >> "${rpath}/dashboard.log"
      exit 1
    fi
  fi
fi

#############################
#### Processing the data ####
#############################

declare -i n
n=2
for smetric in `echo $metric | tr ',' ' '` ; do
  smax=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | sort -n | tail -1` ; smax=${smax%.*}
  smin=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | grep -v ^$ | sort -n | head -1` ; smin=${smin%.*}
  [[ $metricmax -eq 0 ]] && metricmin=$smax
  [ -z "$metricmin" ] && metricmin=0
  [[ $smax -gt $metricmax ]] && metricmax=$smax
  [[ $smin -lt $metricmin ]] && metricmin=$smin
  n+=1
done
sn=`echo $metric | tr ',' ' ' | wc -w`

if [ "X$scale" == "Xyes" ] ; then
  sadd=`solve "($metricmax - $metricmin) / $sn"` 2>/dev/null || sadd=`solve "$metricmax / $sn"` 2>/dev/null || sadd=10
  snadd=0
  n=2
  for smetric in `echo $metric | tr ',' ' '` ; do
    rm -f ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled 2>/dev/null
    smax=`cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f${n} | sort -n | tail -1`
    if [ -n "$smax" ] ; then
      [ `echo "$smax == 0" | bc` -ne 1 ] && sratio=`solve "$metricmax / $smax / $sn / 1.2"` || sratio=1
      for LINE in `cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f1,${n}` ; do
        st=`echo $LINE | cut -d'|' -f1`
        [ -z "$st" ] && continue
        sd=`echo $LINE | cut -d'|' -f2`
        [ -z "$sd" ] && continue
        sds=`solve "$sd * $sratio + $snadd"`
        echo "${st}|${sds}" >> ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled
      done
    fi
    snadd=`solve "$snadd + $sadd"`
    n+=1
  done
fi

#####################################
#### Graph geometry calculations ####
#####################################

# 20 to 40 pixels
countminX=20
countminY=20

perdotY=`expr \( $metricmax - $metricmin \) / $areaV + 1`
[[ $perdotY -lt 1 ]] && perdotY=1
perdotX=`expr \( $to - $from \) / $areaH + 1`
[[ $perdotX -lt 1 ]] && perdotX=1

# How many pixels one hour takes
hourX=`expr 3600 / $perdotX`
[[ $hourX -lt 1 ]] && hourX=1
# Variable looping across all X marks
currpoint=$from
# Various coordinates
# 0:0 coordinate
startX=`expr $legendH + $padding + $axis`
startY=`expr $graphV - $legendV - $padding - $axis`
# Vertical grid lines
mX1=`expr $startY + 2`
mXT1=`expr $mX1 + 14`
mX2=$padding
# Horisontal grid lines
mY1=`expr $startX - 2`
mYT1=`expr $mY1 - 50`
mY2=`expr $graphH - $padding`
# Axis names coordinates
axisXX=`expr $graphH - $padding - 60`
axisXY=`expr $graphV - $legendV - $axis + 20`
axisYX=$padding
axisYY=$padding

#titleX=`expr \( $graphH - $tlength \) / 2`
titleX=`expr $padding + $legendH + 20`
titleY=`expr $graphV - \( $padding / 2 \)`

if [[ $hourX -lt $countminX ]] ; then
  # 1-hour marks would be too close to each other
  # How many hours are within 40 pixels
  hourN=`expr 2 \* $countminX / $hourX`
  # If it's more than 24 hours, try days instead:
  if [[ $hourN -ge 24 ]] ; then
    #echo "Trying days"
    # How many pixels 1 day takes
    dayX=`expr 86400 / $perdotX`
    [[ $dayX -lt 1 ]] && dayX=1
    if [[ $dayX -lt $countminX ]] ; then
      # How many days are within 40 pixels
      dayN=`expr 2 \* $countminX / $dayX`
      # If it's more than 30 days, use months instead:
      if [[ $dayN -ge 30 ]] ; then
        # How many pixels are there in one month
        monthX=`expr 2592000 / $perdotX`
        [[ $monthX -lt 1 ]] && monthX=1
        if [[ $monthX -lt $countminX ]] ; then
        # Resolution should be this many months
          res=`expr 2 \* $countminX / $monthX`
        else
          res=1
        fi
        axisX="months"
        # Finding the next month beginning
        while [[ $currpoint -lt $to ]]
        do
          currpoint=`date -u -d "1970/01/01 +$currpoint sec +$res month" +"%s"`
          themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
          theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
          themark=`date -u -d "${theyear}/${themonth}/1" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          [[ $themark -gt $mY2 ]] && break
          textmark=`date -u -d "1970/01/01 +$currpoint sec"`
          textmark=`date -d "$textmark" +"%m"`
          addxmarks $themark $textmark
        done
        unset nextmonth res monthX
      else
        #echo "Using days"
        axisX="days"
        [[ $dayN -eq 0 ]] && dayN=1  # just in case
        while [[ $currpoint -lt $to ]]
        do
          currpoint=`date -u -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
          theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
          themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
          theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
          themark=`date -u -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
          themark=`expr \( $themark - $from \) / $perdotX + $startX`
          [[ $themark -gt $mY2 ]] && break
          textmark=`date -u -d "1970/01/01 +$currpoint sec"`
          textmark=`date -d "$textmark" +"%d"`
          addxmarks $themark $textmark
        done
        unset nextday
      fi
    else
      dayN=1
      axisX="days"
      while [[ $currpoint -lt $to ]]
      do
        currpoint=`date -u -d "1970/01/01 +$currpoint sec +$dayN day" +"%s"`
        theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
        themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
        theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
        themark=`date -u -d "${theyear}/${themonth}/${theday} 00:00" +"%s"`
        themark=`expr \( $themark - $from \) / $perdotX + $startX`
        [[ $themark -gt $mY2 ]] && break
        textmark=`date -u -d "1970/01/01 +$currpoint sec"`
        textmark=`date -d "$textmark" +"%d"`
        addxmarks $themark $textmark
      done
    fi
    unset dayN
  else
    axisX="hours"
    [[ $hourN -eq 0 ]] && hourN=1
    while [[ $currpoint -lt $to ]]
    do
      currpoint=`date -u -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
      thehour=`date -u -d "1970/01/01 +$currpoint sec" +"%H"`
      theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
      themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
      theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
      themark=`date -u -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
      themark=`expr \( $themark - $from \) / $perdotX + $startX`
      [[ $themark -gt $mY2 ]] && break
      textmark=`date -u -d "1970/01/01 +$currpoint sec"`
    textmark=`date -d "$textmark" +"%H"`
      addxmarks $themark $textmark
    done
  fi
  unset hourN
else
# So 1-hour marks are far enough from each other, and it is the maximal
# resolution possible. It's the same as the previous loop actually, but
# I leave it here to possibly add more resolution like e.g. 10 minutes
  axisX="hours"
  while [[ $currpoint -lt $to ]]
  do
    currpoint=`date -u -d "1970/01/01 +$currpoint sec +$hourN hour" +"%s"`
    thehour=`date -u -d "1970/01/01 +$currpoint sec" +"%H"`
    theday=`date -u -d "1970/01/01 +$currpoint sec" +"%d"`
    themonth=`date -u -d "1970/01/01 +$currpoint sec" +"%m"`
    theyear=`date -u -d "1970/01/01 +$currpoint sec" +"%Y"`
    themark=`date -u -d "${theyear}/${themonth}/${theday} ${thehour}:00" +"%s"`
    themark=`expr \( $themark - $from \) / $perdotX + $startX`
    [[ $themark -gt $mY2 ]] && break
    textmark=`date -u -d "1970/01/01 +$currpoint sec"`
    textmark=`date -d "$textmark" +"%H"`
    addxmarks $themark $textmark
  done
fi

unset nexthour theday themonth theyear themark currpoint hourX

# Now for Y
# Finding out what resolution might be
a=`expr $perdotY \* $countminY`
b=`expr 2 \* $a`
s=`expr length $b`
pof=1
for ((i=0; i<$s; i++)); do pof="${pof}0"; done
res=`expr $pof / 10`
if [[ $res -lt $a ]] ; then
  res=`expr $pof / 4`
  if [[ $res -lt $a ]] ; then
    res=`expr $pof / 2`
  fi
fi

################
### Drawing ####
################

declare -i i
declare -i imark
imark=`expr $metricmin / $res \* $res`
shiftY=`expr $metricmin - $imark`
ires=`expr $res / $perdotY`
i=`expr $legendV + $padding + $axis`
imax=`expr $i + $areaV`
while true
do
  i+=$ires
  imark+=$res
  [[ $i -gt $imax ]] && break
  # Freeing some room for axis Y title
  [[ `expr $i + $ires` -gt $imax ]] && unset imark imarkfp
  irev=`expr ${graphV} - $i`
  marksY="$marksY`echo "<line x1=\\"$mY1\\" y1=\\"$irev\\" x2=\\"$mY2\\" y2=\\"$irev\\" />"`"
  if [ "X$scale" != "Xyes" ] ; then
    if [ -n "$mp" ] ; then
      [ -n "$imark" ] && imarkfp=`solve "$imark/$mp"`
      textY="${textY}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$mYT1\\" y=\\"$irev\\" >$imarkfp</text>"`"
    else
      textY="${textY}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"#666\\" x=\\"$mYT1\\" y=\\"$irev\\" >$imark</text>"`"
    fi
  fi
done

cat "${rpath}/wwwtemplates/graph.head.svg.tmpl" > "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"$graphH\" height=\"$graphV\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Axis
echo "<g id=\"axis\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf "<path id=\"y\" style=\"fill:none;stroke:#000;stroke-width:$strokewidth\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf " $startX,$startY $startX,$mX2" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf "<path id=\"x\" style=\"fill:none;stroke:#000;stroke-width:$strokewidth\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
printf " $startX,$startY $mY2,$startY" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Marks
echo "<g id=\"marks\" shape-rendering=\"geometricPrecision\" style=\"fill:none;stroke:#999;stroke-width:1;\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $marksX >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $marksY >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<g id=\"marks_text\" text-rendering=\"optimizeSpeed\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo $textX >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
[ "X$scale" == "Xyes" ] || echo $textY >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<text font-family=\"Verdana\" font-size=\"${fontsize}\" fill=\"#666\" x=\"$axisXX\" y=\"$axisXY\">$axisX</text>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
[ "X$scale" == "Xyes" ] || echo "<text x=\"$axisYX\" y=\"$axisYY\" font-family=\"Verdana\" font-size=\"${fontsize}\" fill=\"#666\">$axisY</text>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# Graphs
i=0
if [ "$legendpos" == "left" ]; then
  slegendX=`solve "$startX - $legend"`
  slegendY=$startY
  sadd=`expr \( $graphV - $padding \) / $sn`
else
  slegendX=$padding
  slegendY=$axisXY
  sadd=`expr 2 \* $fontsize`
fi
echo "<g id=\"graph\" shape-rendering=\"geometricPrecision\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

# first column is the X axis, data starts from the column 2
n=2
for smetric in `echo $metric | tr ',' ' '` ; do

  slegend="${slegend}`echo "<text font-family=\\"Verdana\\" font-size=\\"${fontsize}\\" fill=\\"${colors[$i]}\\" x=\\"$slegendX\\" y=\\"$slegendY\\" >$smetric</text>"`"
  
  if [ "$legendpos" == "left" ]; then
    slegendY=`expr $slegendY - $sadd`
  else
    slegendY=`expr $slegendY + $sadd`
  fi
  printf "<path id=\"graph_${smetric}\" style=\"fill:none;stroke:${colors[$i]};stroke-width:${strokewidth}\" d=\"M" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  
  if [ "X$scale" == "Xyes" ] ; then cat ${TMPDIR}/graph.${sIP}.${dbname}.${smetric}.scaled ; else cat ${TMPDIR}/graph.${sIP}.${dbname}.${name} | cut -d'|' -f1,${n} ; fi | while read LINE
  do
    X=`echo $LINE | cut -d'|' -f1`
    Y=`echo $LINE | cut -d'|' -f2` ; Y=${Y%.*}
    if [ "X$X" == "X" ] || [ "X$Y" == "X" ] ; then echo "No data" ; continue ; fi
    X=`expr \( $X - $from \) / $perdotX + $padding + $legendH + $axis`
    Y=`expr $graphV - $padding - $axis - $legendV - \( $Y - $metricmin + $shiftY \) / $perdotY`
    printf " $X,$Y" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  done
  echo "\" />" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
  i+=1
  n+=1
done
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "<g id=\"legend\" text-rendering=\"optimizeSpeed\">" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "$slegend" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</g>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"
echo "</svg>" >> "${rpath}/www/graphs/${sIP}.${dbname}.${name}.svg"

#convert -size ${graphH}x${graphV} xc:white -family $fontfamily -pointsize $fontsize \
#  -strokewidth $strokewidth \
#  -draw "stroke black line $startX,$startY $mY2,$startY" \
#  -draw "stroke black line $startX,$startY $startX,$mX2" \
#  -strokewidth 1 \
#  -draw "stroke gray $marksX " -draw "stroke gray $marksY " \
#  -draw "$textY " -draw "$textX " \
#  -draw "${datalines}" \
#  -draw "text $axisXX,$axisXY `printf "\'$axisX\'"`" \
#  -draw "text $axisYX,$axisYY `printf "\'$metric\'"`" \
#  -pointsize $pointsize \
#  -draw "text $titleX,$titleY `printf "\'$title\'"`" \
#  "${rpath}/www/graphs/${sIP}.${dbname}${name}.png"






