#!/bin/bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/
[ -z "$M_ROOT" ] && M_ROOT=$(cd "$rpath/../" && pwd)
LOG="$M_ROOT/logs/deploy.log"

genline() {
  metatype=$1
  shift
  metascript=$@
  case $metatype in
  local)
    echo "local \"$metascript\""
    ;;
  remote)
    echo "remote \"$metascript\""
    ;;
  include)
    IFS='
'
    metascript=`eval "echo $metascript"`
    if [ -e "$ROLES_ROOT/$metascript" ]; then
      irole=${metascript%%/*}
      cat "$ROLES_ROOT/$metascript" | grep -v ^# | grep -v ^$ | grep -v ^[[:space:]]*# | sed "s|\$role|$irole|;s|\${role}|$irole|" | while read metaline ; do (IFS=$IFSORIG ; genline $metaline >> "$CURRTASKDIR"/meta) ; done
    else
      log "$ROLES_ROOT/$metascript not found"
    fi
    ;;
  *)
    # finding out from shebang
    ipr=`head -1 "$metascript" 2>/dev/null || log "$metascript not found" | grep ^#! | cut -b 3- | awk '{print $1}'`
    if [ -n "$ipr" ] ; then
      case $ipr in
        runlocal) ipr="local" ;;
        runremote) ipr="remote" ;;
        *) unset ipr ;;
      esac
    fi
    if [ -n "$ipr" ]; then
      echo "$ipr \"$1 $metascript\""
    else
      echo -e "# ERROR generating full line:\n# $metatype $metascript\n# either meta type is unknown or it is empty and no shebang in the script"
    fi
    ;;
  esac
}

run_meta() {
  declare -i res
  res=0
  [ `grep -c ^"$*"$ "$CURRTASKDIR/log"` -ne 0 ] && echo "Skipping: $*" | tee -a "$LOG" && return 0
  [ -n "$test" -o -n "$dry" ] && dry="--dry"
  
  metatype=$1
  shift
  metascript="$*"
  [ -n "$use_color" ] && printf "\033[01;36mMETA: \033[00;36m${metatype} $metascript\033[0m" || printf "META: $metatype $metascript"
  [ -z "$verbose" ] && echo -n " .. "
  
  if [ -n "$verbose" ] ; then
    printf "\n  type: $metatype  script: $metascript \n"
    V='--verbose'
  fi
  if $debug ; then
    D='--debug'
  fi
  if [ -n "$ignoreemptycluster" ] ; then
    I="--ignoreemptycluster"
  fi
  if [ -n "$ignorenocluster" ] ; then
    F="--ignorenocluster"
  fi
  if [ -n "$metatype" ] && [ -n "$metascript" ] ; then
    if [ ! -e "$ROLES_ROOT/$metascript" ] ; then
      thescript=${metascript##*/}
      therest=${metascript%/*}
      [ `expr "$therest" : "\.*/"` -gt 0 ] && therest=`expr "$therest" : "\.*/\(.*\)"`
      if [ -z "$therest" ]; then
        if [ -e "$ROLES_ROOT/$role/$flavor/$thescript" ]; then
          metascript="$role/$flavor/$thescript"
        else
          metascript=`find "$ROLES_ROOT" -name "$thescript"`
          if [ -z "$metascript" ]; then
            echo "$metascript not found"
            res=1
          else
            echo -e "\n$ROLES_ROOT/$role/$flavor/$thescript not found"
            if [ `echo "$metascript" | wc -l` -gt 1 ]; then
              echo "Found more than one scripts with the name ${thescript}:"
              echo "$metascript"
              echo "Please narrow the search conditions"
              res=1
            else
              echo "Found: $metascript"
              res=1
            fi
          fi
        fi
      else
        therole=`echo "$therest" | cut -d'/' -s -f1`
        theflavor=`echo "$therest" | cut -d'/' -s -f2`
        [ -z "$therole" -a -z "$theflavor" ] && theflavor="$therest"
        if [ -n "$therole" ]; then
          msfoundinrole=`find "$ROLES_ROOT/$therole" -name "$thescript"`
          msfoundinflavor=`find "$ROLES_ROOT"/*/"$theflavor" -name "$thescript"`
          echo -e -n "Script $metascript not found "
          [ -n "$msfoundinrole" ] && echo -e "\n  Found: $msfoundinrole"
          [ -n "$msfoundinflavor" ] && echo -e "\n  Found: $msfoundinflavor"
          res=1
        else
          if [ -e "$ROLES_ROOT/$role/$theflavor/$thescript" ]; then
            metascript="$role/$theflavor/$thescript"
          else
            msfoundinflavor=`find "$ROLES_ROOT"/*/"$theflavor" -name "$thescript"`
            echo -e -n "Script $metascript not found"
            [ -n "$msfoundinflavor" ] && echo -e "\n  Found: $msfoundinflavor"
            res=1
          fi
        fi
      fi
    fi
    if [ $res -eq 0 ]; then
      [ -e "$CURRTASKDIR/$metascript" ] && rm -f "$CURRTASKDIR/$metascript"
      [ -e "$CURRTASKDIR/$metascript.var" ] && rm -f "$CURRTASKDIR/${metascript}.var"
      deploy.run --type=$metatype --file=$metascript --ip=$ip --key="$KEY" --cluster="$cluster" --role="$role" --flavor="$flavor" --timestamp=$timestampact --task="$task" $dry $V $D $I $F $SU
      res=$?
    fi
    if [ -n "$verbose" ] ; then
      if [ -n "$use_color" ] ; then
        [ $res -eq 0 ] && printf "\033[01;32mSuccess\033[0m\n\n" || printf "\033[01;31mError\033[0m\n\n"
      else
        [ $res -eq 0 ] && echo -e "Success\n" || echo "ERROR\n"
      fi
    else
      if [ -n "$use_color" ] ; then
        [ $res -eq 0 ] && printf " \033[01;32mSuccess\033[0m\n" || printf " \033[01;31mError\033[0m\n"
      else
        [ $res -eq 0 ] && echo " Success" || echo " ERROR"
      fi
    fi
    [ $res -eq 0 ] && echo "$meta" >> "$CURRTASKDIR/log"
    return $res
  else
    [ -n "$use_color" ] && printf "\033[01;31m"
    echo "Error parsing command: $meta"
    if [ "X$metatype" == "Xlocal" -o "X$metatype" == "Xremote" -o "X$metatype" == "Xinclude" ]; then
      echo "Looks like script is not defined"
    else
      echo "Looks like type is not defined"
    fi
    [ -n "$use_color" ] && printf "\033[0m"
    [ -z "$dry" ] && proper_exit 1 162
  fi
}

startserver() {
  ip=0 
  ip="$(IAMACHILD=1 "$rpath"/../cloud/$CLOUD_PROVIDER/start_server --cluster=$cluster --return=ip "$V" "$T" 2>>"$rpath"/../logs/cloud.log | tail -1)"
  [ $? -ne 0 ] && ip=$? 
  log "($CLOUD) start_server returned this: $ip"
}

SSH=`which ssh 2>/dev/null`
SCP=`which scp 2>/dev/null`
[ -f "/sbin/ifconfig" ] && IFCFG=/sbin/ifconfig || IFCFG=`which ifconfig 2>/dev/null`
possible_options="help verbose debug flavor ip cloud cluster task role timestamp test dry command output repeat newserver list skip force ignoreipnotpresent ignoreemptycluster ignorenocluster usage user nosudo nolock newtimestamp"
[ "X$*" == "X" ] && usage="yes"

IFSORIG=$IFS
IFS='-'
for s_option in "$@"
do
  found=false
  s_option=${s_option/--/}
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  [ "X$s_optarg" == "Xno" ] && unset $s_optname

  for option in ${possible_options// /-} ; do
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=true && break
  done
  
  if ! $found ; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFSORIG

found=false
for option in $necessary_options ; do
  [ -z "$(eval echo \$$option)" ] && missing_options="$missing_options --${option}," && found=true
done
if $found ; then
  echo "Necessary options: ${missing_options/%,/} not found"
  exit 1
fi

[ -n "$debug" ] && verbose="yes" && debug=true || debug=false
[ "X$help" == "Xyes" ] && debug=true
export verbose debug
[ -n "$repeat" ] && timestamp=repeat
[ -n "$newtimestamp" ] && unset timestamp timestampact
[ -n "$usage" ] && help="yes" && debug=false

if [ "X$help" == "Xyes" ] ; then
  if $debug ; then
    cat << "EOF"
Usage: ${0##*/} <options>

Common options:

  --help		this help
  --usage		short help
  --verbose		shows the output of each command; also exports
			"verbose=yes" to descendant processes, so it can be 
			used in scripts
  --debug		adds verbosity; also exports "debug=yes" to descendant
			processes, so it can be used in scripts
  --test|--dry		makes all preparations but doesn't really execute
			any scripts; in combination with --verbose or --debug
			outputs the resulting scripts and files with all
			variables substituted

Target selection options:

  --ip=[IP]		target is this IP only
  --ignoreemptycluster	useful only in combination with --ip in some cases;
			prevents from complaining about cluster not defined
  --cluster=[name]	allows to define cluster; overwrites M_CLUSTER 
			environment variable if it is defined
  --role=[name]		(re)defines cluster based on role
  --flavor=[name]	(re)defines cluster(s) based on flavor, i.e. selects
			all hosts of this flavor as a target
  --cloud=[name]	(re)defines cluster(s) based on cloud, i.e. selects
			all hosts in this cloud as a target

Commands selection options:

  --task=[name]		task is defined by metascript "extension"; metascript
			must be located in the root folder of the role, so e.g.
			file meta.deploy corresponds to the task named "deploy"
                        and contains the list of all correspondent commands
			inside
  --command=[command string]	executes a single command defined by command
			string; syntax is "command-type role/flavor/command"
			where command-type is either "remote" or "local";
			see documentation for more details
  --command=[number,...]	executes command(s) defined by their numbers in
			existing metascript defined by the --task option; see
			also option --list
  --list		outputs all commands listed in metascript defined by 
			the --task option with their numbers
  --skip=[number,...]	allows to skip certain commands while executing 
                        metascript defined by the --task option

Repeat options:

  These options don't require other options to be defined, all the options
  are inherited from the session being repeated

  --repeat		repeats the last meta execution starting from the
			command that failed during the previous run; if there
			were no failed commands, does nothing
  --timestamp=[string]  	repeats execution of the session defined by its
			timestamp; session timestamp is shown when metascript
			execution has finished, either successfully or not
  --newtimestamp    forces new timestamp generation; necessary if metaexec
      command is included in the script that is run by another metaexec command

Other options:

  --newserver		this is a shortcut combining start_server command and
			metascript execution on this new server when it is
			ready; includes all necessary automation: getting
			new server status, repeating the call if it has failed,
			inserting the IP into the list, ensuring it is up
			and accessible etc. See documentation for more details
			
  --nolock   the default is to lock cloud operations if --newserver option
      is present; this helps to avoid background API calls caused
      by absence of the target server in servers.list which may happen
      due to the lag with which just started server appears in the list
      returned by cloud API. But if the task is long enough, you may want
      to avoid locking. This should not cause any problems, but may require
      some extra time and extra API calls to ensure the target server presence.
      

EOF
  else
    echo -e "Usage: ${0##*/} <options>\n    Possible options: $possible_options\n    For detailed help use ${0##*/} --help\n"
  fi
  exit 0
fi

[ -n "$cloud" ] && CLOUD=$cloud
export CLOUD
[ -n "$CLOUD" ] && source "$M_ROOT/conf/clouds/${CLOUD}.conf"
[ -z "$CLOUD" ] && echo "Cloud is not defined" && exit 1

source "$M_ROOT/conf/deployment.conf"
source "$M_ROOT/lib/functions.sh"
source "$M_ROOT/lib/cloud_functions.sh"

[ -z "$ROLES_ROOT" ] && ROLES_ROOT=/opt/m/deployment/roles
[ -z "$WORK_DIR" ] && WORK_DIR=/root/deploy.tmp

export PATH="$M_ROOT/deployment:$M_ROOT/cloud/common:$M_ROOT/helpers:$PATH"
[ -n "$task" ] || task=notask
[ -n "$ignoreipnotpresent" -o -n "$force" -o -n "$ignorenocluster" ] && ignorenocluster="yes" && force="yes"
[ -n "$user" ] && SSH_REMOTE_USER="$user"
[ -z "$SSH_REMOTE_USER" ] && SSH_REMOTE_USER="root" && nosudo="yes"
[ "x$nosudo" == "xyes" ] && SU="--nosudo"

log "Starting metaexec with arguments $@"

[ -n "$IFCFG" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//' | grep -v '127.0.0.1'` || localip="ifconfig_not_found"

if [ -n "$timestamp" ] ; then
  [ -n "$newserver" ] && echo "Repeating existing sequence is disabled for new server. If you want to repeat a meta that has brought up a previous server, it's safe to run $rcommand --repeat or $rcommand --timestamp=<timestamp> without other arguments. It will pick up IP address of that server and all relevant arguments." && exit 1
  if [ "X$timestamp" == "Xrepeat" ]; then
    timestampact=`ls -1tr "$WORK_DIR" | tail -1` && timestampact=${timestampact##*.} && echo "Restoring process with timestamp $timestampact"
  else
    timestampact="$timestamp"
  fi
  if [ -n "$timestampact" ]; then
    argfile=`find "$WORK_DIR"/*.$timestampact/ -maxdepth 1 -name ARGV`
    if [ -f "$argfile" ]; then
      sed -i "/^newserver=/d;/^test=/d;/^verbose=/d;/^debug=/d;/^timestamp=/d" "$argfile"
      source "$argfile"
    else
      echo "Process with timestamp $timestampact cannot be repeated, no arguments file found"
      exit 1
    fi
  fi
else
  timestampact=`date +"%y_%m_%d_%H_%M_%S"`
fi

if [ -n "$ip" ] ; then
  [ -n "$newserver" ] && echo "Both newserver and ip are defined. Not sure what to do." && exit 1
  if [[ $ip =~ [^[0-9.]]* ]] ; then
    echo "Something's wrong with IP: $ip"
    exit 1
  fi
  ipcluster=`grep "^$ip|" "$M_ROOT/servers.list" | cut -d'|' -f5`
  [ -z "$ipcluster" ] && [ -n "$CLOUD" ] && "$M_ROOT"/cloud/common/find_server --cloud=$CLOUD --ip=$ip --updatelist
  ipcluster=`grep "^$ip|" "$M_ROOT/servers.list" | cut -d'|' -f5`
  [ -z "$ipcluster" ] && [ -z "$ignoreemptycluster" ] && echo "IP $ip is not present in servers.list or has no cluster defined." && exit 1
  if [ -n "$cluster" ] ; then
    [ "$cluster" != "$ipcluster" ] && [ -z "$force" ] && echo "Cluster found for this IP is ${ipcluster}, but cluster provided as an option is $cluster" && exit 1
  else
    cluster=$ipcluster
  fi
else
  # Cluster must be defined! If it is still not, we'll find it using the role
  if [ -z "$cluster" ] ; then
    if [ -z "$role" ] ; then
      if [ -n "$M_ROLE" ] ; then
        role=$M_ROLE
        cluster=$M_CLUSTER
      fi
    else
      [ -z "$cluster" ] && cluster=`cat "$M_ROOT/conf/clusters.conf" | grep -v ^# | grep -v ^$ | cut -d'|' -f1,10 | grep \|${role}$ | cut -d'|' -f1`
      [ -n "$cluster" ] && echo -e "\nUsing cluster ${cluster}, default for role $role"
    fi
    # Still no cluster??
    if [ -z "$cluster" -a -z "$ignorenocluster" ] ; then
      echo "Unable to find what cluster to use."
      [ -z "$list" ] && exit 1
    fi
  else
    # role by cluster
    if [ -z "$role" ] ; then
      role=`grep ^$cluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f10`
      echo "Using role ${role}, default for cluster $cluster"
      [ -z "$role" ] && echo "Unable to find the role of this cluster/server" && exit 1
    fi
  fi
fi
export role cluster
USER_FROM_CLUSTER=`grep ^$cluster\| "$M_ROOT/conf/clusters.conf" | cut -s -d'|' -f13`
[ -n "$USER_FROM_CLUSTER" ] && SSH_REMOTE_USER="$USER_FROM_CLUSTER" && unset nosudo SU

[ -n "$verbose" ] && V='--verbose'
[ -n "$test" ] && T='--test'
CURRTASKDIR="$WORK_DIR/${role}.${task}.$timestampact"
export CURRTASKDIR
if [ -d "$CURRTASKDIR" ] && [ -z "$timestamp" ]; then
  declare -i m ; m=1
  while [ -d "${CURRTASKDIR}_$m" ]; do
    m+=1
  done
  CURRTASKDIR="${CURRTASKDIR}_$m"
fi
install $V -d "$CURRTASKDIR"
export CURRTASKDIR
touch "$CURRTASKDIR/log"

if [ -z "$flavor" ] ; then
  flavor=`grep ^$cluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f11`
  [ -z "$flavor" ] && echo -e "Unable to find the flavor of this cluster/server OS\n\n (hint: option --flavor is available)\n" && exit 1 || echo "Using flavor $flavor, default for cluster $cluster"
fi

[ -z "$SERVER_CHECKS_NUMBER" ] && SERVER_CHECKS_NUMBER=20
[ -z "$SERVER_CHECKS_PERIOD" ] && SERVER_CHECKS_PERIOD=30

if [ -n "$newserver" ]; then
  
  [ -z "$NEW_SERVER_START_TRIES" ] && NEW_SERVER_START_TRIES=3
  [ -z "$WAIT_BETWEEN_TRIES" ] && WAIT_BETWEEN_TRIES=30
  echo "*** Bringing up new server in cloud $CLOUD"
  log "bringing up new server in cloud $CLOUD"
  if [ -z "$test" ]; then

    if [ -z "$nolock" ]; then
      log "getting cloud operations lock"
      lock_cloudops || exit 10
    fi
    log "initiating start_server sequence"
    
    for ((i=0; i<$NEW_SERVER_START_TRIES; i++)); do
      [ $i -eq 0 ] || sleep $WAIT_BETWEEN_TRIES
      startserver $T
      if [[ `expr "$ip" : "[0-9]*\.[0-9.]*$"` -ne 0 ]]; then
        break
      else
        # assuming it's the exit status (see the function)
        res=$ip
      fi
      [[ $res -eq 2 ]] && log "Timeout waiting for the server ready" && break
      [[ $res -eq 5 ]] && log "Maximum servers number for cluster $cluster has been reached, unable to add another server" && proper_exit 5 446
      # various weird errors below, exit 1 
      [[ $res -eq 6 ]] && log "Failed to generate a name for the new server" && proper_exit 1 448
      [[ $res -eq 7 ]] && log "Failed to find out what image to use to create the new server, define it in clusters.conf, please" && proper_exit 1 449
      [[ $res -eq 8 ]] && log "Failed to find out what flavor (server size) to use, define it in clusters.conf, please" && proper_exit 1 450
      [[ $res -eq 1 ]] && log "Something went wrong, unable to add a server to the cluster $cluster"
      if [ -z "$ip" ]; then
        log "Was unable either to start a cloud server in the cloud $CLOUD or to get its IP address." && sleep $WAIT_BETWEEN_TRIES && continue
      fi
      [[ `expr $ip : [0-9.]*$` -eq 0 ]] && log "Something's wrong with IP: $ip"
      echo "Something went wrong, check $LOG and fix the problem, next try is in $WAIT_BETWEEN_TRIES seconds"
    done
    [ $i -eq $NEW_SERVER_START_TRIES ] && log "Maximal number of tries reached, exiting" && proper_exit 1 458
  else
    echo "*** This is a test"
  fi
fi

# Default output is console, colored if colors are supported
[ -z "$output" ] && output=console
use_color=false
if [ "$output" == "console" ] ; then
   if [ -z "$M_COLOR" ]; then
    # Thanks to Gentoo guys for this part, I couldn't do better
    safe_term=${TERM//[^[:alnum:]]/?}   # sanitize TERM
    match_lhs=""
    [ -f ~/.dir_colors   ] && match_lhs="${match_lhs}$(<~/.dir_colors)"
    [ -f /etc/DIR_COLORS ] && match_lhs="${match_lhs}$(</etc/DIR_COLORS)"
    [ -z "$match_lhs" ] \
	    && type -P dircolors >/dev/null \
	    && match_lhs=$(dircolors --print-database)
    [[ $'\n'$match_lhs == *$'\n'"TERM "${safe_term}* ]] && use_color=true
  else
    use_color=true
  fi
fi

if [ `echo $ip | grep -c "^$localip$"` -eq 0 ] ; then
  #KEY=`grep "^${cluster}|" "${rpath}/../conf/clusters.conf" | cut -d'|' -f2`
  KEY=`"$M_ROOT"/helpers/find_key cluster "$cluster"` || KEY=`"$M_ROOT"/helpers/find_key server "$ip"` || proper_exit 1 467
  [ -z "$KEY" ] && echo "Access key not found!" && proper_exit 1 486
  [ -z "$SSH" ] && echo "SSH client not found!" && proper_exit 1 487
  # it's here because startserver function cause re-reading cloud config
  [ -n "$SSHPORT" ] || SSHPORT=22
  if [ -z "$list" ] ; then
    #SSH="$SSH -i \"${rpath}/../keys/${KEY}\" -o StrictHostKeyChecking=no"
    $debug && log "ensuring the target server $ip is accessible"
    if [ -z "$test" -a -n "$ip" ] ; then
      for ((k=0; k<$SERVER_CHECKS_NUMBER; k++)); do
        $SSH -i "$KEY" -p $SSHPORT -o "StrictHostKeyChecking=no" -o "ConnectTimeout=10" -o "PasswordAuthentication=no" "$SSH_REMOTE_USER"@"$ip" echo >>$LOG 2>&1
        if [ $? -ne 0 ]; then
          echo "Unable to login to the server $ip using key ${KEY}, trying again...">>"$LOG"
          loggedin=false
          sleep $SERVER_CHECKS_PERIOD
        else
          loggedin=true
          break
        fi
      done
      if ! $loggedin && [ -n "$newserver" ]; then
        # stop useless server and tell the parent process that something's wrong
        "$M_ROOT"/cloud/$CLOUD_PROVIDER/stop_server --ip=$ip
        proper_exit 13 508
      fi
    fi
    #[ -z "$SCP" ] && echo "SCP not found!" && exit 1

    #${rpath}/testmeta --flavor=$flavor --task=$task --role=$role || exit 1

    if [ -z "$timestamp" ]; then
    ## Saving arguments to make re-run simpler
      $debug && log "saving command-line arguments for possible repeat of the sequence"
      IFS2=$IFS ; IFS=$' \t\n'
      for option in `echo $possible_options | sed 's/,/ /g'`; do
        echo "${option}=\"`eval "echo \\$${option}"`\"" >> "$CURRTASKDIR/ARGV"
      done
      IFS=$IFS2
      echo -e "flavor=$flavor\ncluster=$cluster\nrole=$role\n" >> "$CURRTASKDIR/ARGV"
      if [ -n "$newserver" ]; then
        echo "ip=\"$ip\"" >> "$CURRTASKDIR/ARGV"
      fi
    else
      rm "$CURRTASKDIR"/meta 2>/dev/null
    fi
    ##
  fi
  echo
  if [ -n "$command" ] && [[ `echo $command | grep -c "^[0-9,]*$"` -eq 0 ]]; then
    meta="$command"
    run_meta $meta
  else
    rm "$CURRTASKDIR"/meta 2>/dev/null
    IFS='
'
    cat "$ROLES_ROOT/$role/meta.$task" | grep -v ^# | grep -v ^$ | grep -v ^[[:space:]]*# | while read metaline ; do (IFS=$IFSORIG ; genline $metaline >> "$CURRTASKDIR"/meta) ; done
    
    declare -i metan
    metan=1
    if [ -n "$command" ] ; then
      for commandn in `echo -e $command | tr ',' '\n'` ; do
        for meta in `cat "$CURRTASKDIR"/meta` ; do
          meta=`eval "echo $meta"`
          if [[ $commandn -eq $metan ]]; then
            if [ $metan -eq 1 ]; then
              newmeta="$meta"
            else
              newmeta="${newmeta}\n${meta}"
            fi
          fi
          metan+=1
        done
        metan=1
      done
      echo -e "$newmeta" > "$CURRTASKDIR/meta"
    fi
    for meta in `cat "$CURRTASKDIR"/meta` ; do
      meta=`eval "echo $meta"`
      skipthis=false
      if [ -n "$list" ] ; then
        echo "$metan $meta"
        if [ "$list" == "unfold" ]; then
          echo '--------------------------------------------------------------------------------'
          role show script "${meta#* }" | sed 's|\\\$|$|g'
          echo '--------------------------------------------------------------------------------'
        fi
      else
        if [ -n "$skip" ] ; then
          for skipn in `echo -e $skip | tr ',' '\n'` ; do
            [[ $skipn -eq $metan ]] && skipthis=true
          done
        fi

        if ! $skipthis ; then
          (IFS=$IFSORIG ; run_meta $meta)
          [ $? -ne 0 ] && echo -e "Timestamp: $timestampact\nWork directory: $CURRTASKDIR\n" && proper_exit 1 579
        fi
      fi
      metan+=1
    done
    IFS=$IFSORIG
  fi
else
  echo "Setting up self is not supported"
fi
if [ -z "$list" ] ; then
  echo -e "Timestamp: $timestampact\nWork directory: $CURRTASKDIR\n"
  # the best place for this seems to be here
  [ -z "$KEEP_DEPLOYTMP" ] && KEEP_DEPLOYTMP=30
  find "$WORK_DIR" -maxdepth 1 -mindepth 1 -type d -mtime +$KEEP_DEPLOYTMP -exec rm -rf {} \;
fi
echo
if [ -n "$newserver" ]; then
  proper_exit 0 597
fi
#echo "Preparing the keys"
#if [ -f /root/.ssh/id_rsa.pub ] ; then
#  echo "Using existing key"
#else
#  printf "Generating a new key..  "
#  ssh-keygen -q -f /root/.ssh/id_rsa -N '' && printf "done\n" || printf "error\n"
#fi
    
    
    
