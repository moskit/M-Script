#!/bin/bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/
M_ROOT=$(cd "$rpath/../" && pwd)
LOG="$M_ROOT/logs/deploy.log"

genline() {
  metatype=$1
  shift
  metascript=$@
  case $metatype in
  local)
    echo "local \"$metascript\""
    ;;
  remote)
    echo "remote \"$metascript\""
    ;;
  include)
    IFS='
'
    if [ -e "$ROLES_ROOT/$metascript" ]; then
      irole=${metascript%%/*}
      cat "$ROLES_ROOT/$metascript" | grep -v ^# | grep -v ^$ | grep -v ^[[:space:]]*# | sed "s|\$role|$irole|;s|\${role}|$irole|" | while read metaline ; do (IFS=$IFSORIG ; genline $metaline >> "$WORK_DIR/${role}.${task}.$timestampact"/meta) ; done
    else
      log "$ROLES_ROOT/$metascript not found"
    fi
    ;;
  *)
    # finding out from shebang
    ipr=`head -1 "$metascript" 2>/dev/null || log "$metascript not found" | grep ^#! | cut -b 3- | awk '{print $1}'`
    if [ -n "$ipr" ] ; then
      case $ipr in
        runlocal) ipr="local" ;;
        runremote) ipr="remote" ;;
        *) unset ipr ;;
      esac
    fi
    if [ -n "$ipr" ]; then
      echo "$ipr \"$1 $metascript\""
    else
      echo -e "# ERROR generating full line:\n# $metatype $metascript\n# either meta type is unknown or it is empty and no shebang in the script"
    fi
    ;;
  esac
}

run_meta() {
  declare -i res
  res=0
  [ `grep -c ^"$*"$ "$WORK_DIR/${role}.${task}.$timestampact/log"` -ne 0 ] && echo "Skipping: $*" | tee -a "$LOG" && return 0
  [ -n "$test" -o -n "$dry" ] && dry="--dry"
  
  metatype=$1
  shift
  metascript="$*"
  [ -n "$use_color" ] && printf "\033[01;36mMETA: \033[00;36m${metatype} $metascript\033[0m" || printf "META: $metatype $metascript"
  [ -z "$verbose" ] && echo -n " .. "
  
  if [ -n "$verbose" ] ; then
    printf "\n  type: $metatype  script: $metascript \n"
    V='--verbose'
  fi
  if $debug ; then
    D='--debug'
  fi
  if [ -n "$ignoreemptycluster" ] ; then
    I="--ignoreemptycluster"
  fi
  if [ -n "$ignorenocluster" ] ; then
    F="--ignorenocluster"
  fi
  if [ -n "$metatype" ] && [ -n "$metascript" ] ; then
    if [ ! -e "$ROLES_ROOT/$metascript" ] ; then
      thescript=${metascript##*/}
      therest=${metascript%/*}
      [ `expr "$therest" : "\.*/"` -gt 0 ] && therest=`expr "$therest" : "\.*/\(.*\)"`
      if [ -z "$therest" ]; then
        if [ -e "$ROLES_ROOT/$role/$flavor/$thescript" ]; then
          metascript="$role/$flavor/$thescript"
        else
          metascript=`find "$ROLES_ROOT" -name "$thescript"`
          if [ -z "$metascript" ]; then
            echo "$metascript not found"
            res=1
          else
            echo -e "\n$ROLES_ROOT/$role/$flavor/$thescript not found"
            if [ `echo "$metascript" | wc -l` -gt 1 ]; then
              echo "Found more than one scripts with the name ${thescript}:"
              echo "$metascript"
              echo "Please narrow the search conditions"
              res=1
            else
              echo "Found: $metascript"
              res=1
            fi
          fi
        fi
      else
        therole=`echo "$therest" | cut -d'/' -s -f1`
        theflavor=`echo "$therest" | cut -d'/' -s -f2`
        [ -z "$therole" -a -z "$theflavor" ] && theflavor="$therest"
        if [ -n "$therole" ]; then
          msfoundinrole=`find "$ROLES_ROOT/$therole" -name "$thescript"`
          msfoundinflavor=`find "$ROLES_ROOT"/*/"$theflavor" -name "$thescript"`
          echo -e -n "Script $metascript not found "
          [ -n "$msfoundinrole" ] && echo -e "\n  Found: $msfoundinrole"
          [ -n "$msfoundinflavor" ] && echo -e "\n  Found: $msfoundinflavor"
          res=1
        else
          if [ -e "$ROLES_ROOT/$role/$theflavor/$thescript" ]; then
            metascript="$role/$theflavor/$thescript"
          else
            msfoundinflavor=`find "$ROLES_ROOT"/*/"$theflavor" -name "$thescript"`
            echo -e -n "Script $metascript not found"
            [ -n "$msfoundinflavor" ] && echo -e "\n  Found: $msfoundinflavor"
            res=1
          fi
        fi
      fi
    fi
    if [ $res -eq 0 ]; then
      [ -e "$WORK_DIR/${role}.${task}.$timestampact/$metascript" ] && rm -f "$WORK_DIR/${role}.${task}.$timestampact/$metascript"
      [ -e "$WORK_DIR/${role}.${task}.$timestampact/$metascript.var" ] && rm -f "$WORK_DIR/${role}.${task}.$timestampact/${metascript}.var"
      deploy.run --type=$metatype --file=$metascript --ip=$ip --key="$KEY" --cluster="$cluster" --role="$role" --flavor="$flavor" --timestamp=$timestampact --task="$task" $dry $V $D $I $F $SU
      res=$?
    fi
    if [ -n "$verbose" ] ; then
      if [ -n "$use_color" ] ; then
        [ $res -eq 0 ] && printf "\033[01;32mSuccess\033[0m\n\n" || printf "\033[01;31mError\033[0m\n\n"
      else
        [ $res -eq 0 ] && echo -e "Success\n" || echo "ERROR\n"
      fi
    else
      if [ -n "$use_color" ] ; then
        [ $res -eq 0 ] && printf " \033[01;32mSuccess\033[0m\n" || printf " \033[01;31mError\033[0m\n"
      else
        [ $res -eq 0 ] && echo " Success" || echo " ERROR"
      fi
    fi
    [ $res -eq 0 ] && echo "$meta" >> "$WORK_DIR/${role}.${task}.$timestampact/log"
    return $res
  else
    [ -n "$use_color" ] && printf "\033[01;31m"
    echo "Error parsing meta: $meta"
    [ -n "$use_color" ] && printf "\033[0m"
    [ -z "$dry" ] && proper_exit 1 124
  fi
}

startserver() {
  ip=0 
  ip="$(IAMACHILD=1 "$rpath"/../cloud/$cloud/start_server --cluster=$cluster --return=ip "$V" "$T" 2>>"$rpath"/../logs/cloud.log | tail -1)"
  [ $? -ne 0 ] && ip=$? 
  log "($CLOUD) start_server returned this: $ip"
}

SSH=`which ssh 2>/dev/null`
SCP=`which scp 2>/dev/null`
[ -f "/sbin/ifconfig" ] && IFCFG=/sbin/ifconfig || IFCFG=`which ifconfig 2>/dev/null`
possible_options="help verbose debug flavor ip cloud cluster task role timestamp test dry command output repeat newserver list skip force ignoreipnotpresent ignoreemptycluster ignorenocluster usage user nosudo"
[ "X$*" == "X" ] && usage="yes"

IFSORIG=$IFS
IFS='-'
for s_option in "$@"
do
  found=false
  s_option=${s_option/--/}
  s_optname=${s_option%%=*}
  s_optarg=${s_option##*=}
  [ "X$s_optarg" == "X$s_optname" ] && s_optarg="yes"
  [ "X$s_optarg" == "Xno" ] && unset $s_optname

  for option in ${possible_options// /-} ; do
    [ "X$s_optname" == "X$option" ] && eval "$s_optname=\"$s_optarg\"" && found=true && break
  done
  
  if ! $found ; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
IFS=$IFSORIG

found=false
for option in $necessary_options ; do
  [ -z "$(eval echo \$$option)" ] && missing_options="$missing_options --${option}," && found=true
done
if $found ; then
  echo "Necessary options: ${missing_options/%,/} not found"
  exit 1
fi

[ -n "$debug" ] && verbose="yes" && debug=true || debug=false
[ "X$help" == "Xyes" ] && debug=true
export verbose debug
[ -n "$repeat" ] && timestamp=repeat
[ -n "$usage" ] && help="yes" && debug=false

if [ "X$help" == "Xyes" ] ; then
  if $debug ; then
    cat << "EOF"
Usage: ${0##*/} <options>

Common options:

  --help		this help
  --usage		short help
  --verbose		shows the output of each command; also exports
			"verbose=yes" to descendant processes, so it can be 
			used in scripts
  --debug		adds verbosity; also exports "debug=yes" to descendant
			processes, so it can be used in scripts
  --test|--dry		makes all preparations but doesn't really execute
			any scripts; in combination with --verbose or --debug
			outputs the resulting scripts and files with all
			variables substituted

Target selection options:

  --ip=[IP]		target is this IP only
  --ignoreemptycluster	useful only in combination with --ip in some cases;
			prevents from complaining about cluster not defined
  --cluster=[name]	allows to define cluster; overwrites M_CLUSTER 
			environment variable if it is defined
  --role=[name]		(re)defines cluster based on role
  --flavor=[name]	(re)defines cluster(s) based on flavor, i.e. selects
			all hosts of this flavor as a target
  --cloud=[name]	(re)defines cluster(s) based on cloud, i.e. selects
			all hosts in this cloud as a target

Commands selection options:

  --task=[name]		task is defined by metascript "extension"; metascript
			must be located in the root folder of the role, so e.g.
			file meta.deploy corresponds to the task named "deploy"
                        and contains the list of all correspondent commands
			inside
  --command=[command string]	executes a single command defined by command
			string; syntax is "command-type role/flavor/command"
			where command-type is either "remote" or "local";
			see documentation for more details
  --command=[number,...]	executes command(s) defined by their numbers in
			existing metascript defined by the --task option; see
			also option --list
  --list		outputs all commands listed in metascript defined by 
			the --task option with their numbers
  --skip=[number,...]	allows to skip certain commands while executing 
                        metascript defined by the --task option

Repeat options:

  These options don't require other options to be defined, all the options
  are inherited from the session being repeated

  --repeat		repeats the last meta execution starting from the
			command that failed during the previous run; if there
			were no failed commands, does nothing
  --timestamp=[string]	repeats execution of the session defined by its
			timestamp; session timestamp is shown when metascript
			execution has finished, either successfully or not

Other options:

  --newserver		this is a shortcut combining start_server command and
			metascript execution on this new server when it is
			ready; includes all necessary automation: getting
			new server status, repeating the call if it has failed,
			inserting the IP into the list, ensuring it is up
			and accessible etc. See documentation for more details

EOF
  else
    echo -e "Usage: ${0##*/} <options>\n   Possible options: $possible_options"
  fi
  exit 0
fi

source "$M_ROOT/conf/deployment.conf"
source "$M_ROOT/conf/cloud.conf"
source "$M_ROOT/lib/functions.sh"
source "$M_ROOT/lib/cloud_functions.sh"

[ -n "$cloud" ] || cloud=$CLOUD
[ -n "$cloud" ] || cloud=common
[ -n "$SSHPORT" ] || SSHPORT=22

export PATH="$M_ROOT/deployment:$M_ROOT/cloud/${cloud}:$M_ROOT/helpers:$PATH"
[ -n "$task" ] || task=notask
[ -n "$ignoreipnotpresent" -o -n "$force" -o -n "$ignorenocluster" ] && ignorenocluster="yes" && force="yes"
[ -n "$user" ] && REMOTE_USER="$user"
[ -z "$REMOTE_USER" ] && REMOTE_USER="root" && nosudo="yes"
[ "x$nosudo" == "xyes" ] && SU="--nosudo"

log "Starting metaexec with arguments $@"

[ "X$IFCFG" != "X" ] && localip=`$IFCFG | sed '/inet\ /!d;s/.*r://;s/\ .*//' | grep -v '127.0.0.1'` || localip="ifconfig_not_found"

if [ -n "$timestamp" ] ; then
  [ -n "$newserver" ] && echo "Repeating existing sequence is disabled for new server. If you want to repeat a meta that has brought up a previous server, it's safe to run $rcommand --repeat or $rcommand --timestamp=<timestamp> without other arguments. It will pick up IP address of that server and all relevant arguments." && exit 1
  if [ "X$timestamp" == "Xrepeat" ]; then
    timestampact=`ls -1tr "$WORK_DIR" | tail -1` && timestampact=${timestampact##*.} && echo "Restoring process with timestamp $timestampact"
  else
    timestampact="$timestamp"
  fi
  if [ -n "$timestampact" ]; then
    argfile=`find "$WORK_DIR"/*.$timestampact/ -maxdepth 1 -name ARGV`
    if [ -f "$argfile" ]; then
      sed -i "/^newserver/d;/^test/d;/^verbose/d;/^debug/d" "$argfile"
      source "$argfile"
    else
      echo "Process with timestamp $timestampact cannot be repeated, no arguments file found"
      exit 1
    fi
  fi
else
  timestampact=`date +"%y_%m_%d_%H_%M_%S"`
fi

if [ -n "$ip" ] ; then
  [ -n "$newserver" ] && echo "Both newserver and ip are defined. Not sure what to do." && exit 1
  if [[ $ip =~ [^[0-9.]]* ]] ; then
    echo "Something's wrong with IP: $ip"
    exit 1
  fi
  ipcluster=`grep "^$ip|" "$M_ROOT/servers.list" | cut -d'|' -f5`
  [ -z "$ipcluster" ] && [ -z "$ignoreemptycluster" ] && echo "IP $ip is not present in servers.list or has no cluster defined." && exit 1
  if [ -n "$cluster" ] ; then
    [ "$cluster" != "$ipcluster" ] && [ -z "$force" ] && echo "Cluster found for this IP is ${ipcluster}, but cluster provided as an option is $cluster" && exit 1
  else
    cluster=$ipcluster
  fi
else
  # Cluster must be defined! If it is still not, we'll find it using the role
  if [ -z "$cluster" ] ; then
    if [ -z "$role" ] ; then
      if [ -n "$M_ROLE" ] ; then
        role=$M_ROLE
        cluster=$M_CLUSTER
      fi
    else
      [ -z "$cluster" ] && cluster=`cat "$M_ROOT/conf/clusters.conf" | grep -v ^# | grep -v ^$ | cut -d'|' -f1,10 | grep \|${role}$ | cut -d'|' -f1`
      [ -n "$cluster" ] && echo "Using cluster ${cluster}, default for role $role"
    fi
    # Still no cluster??
    if [ -z "$cluster" -a -z "$ignorenocluster" ] ; then
      echo "Unable to find what cluster to use."
      [ -z "$list" ] && exit 1
    fi
  else
    # role by cluster
    if [ -z "$role" ] ; then
      role=`grep ^$cluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f10`
      echo "Using role ${role}, default for cluster $cluster"
      [ -z "$role" ] && echo "Unable to find the role of this cluster/server" && exit 1
    fi
  fi
fi
export role cluster
[ -n "$verbose" ] && V='--verbose'
[ -n "$test" ] && T='--test'
install $V -d "$WORK_DIR/${role}.${task}.$timestampact"
touch "$WORK_DIR/${role}.${task}.$timestampact/log"

if [ -z "$flavor" ] ; then
  flavor=`grep ^$cluster\| "$M_ROOT/conf/clusters.conf" | cut -d'|' -f11`
  [ -z "$flavor" ] && echo -e "Unable to find the flavor of this cluster/server OS\n\n (hint: option --flavor is available)\n" && exit 1 || echo "Using flavor $flavor, default for cluster $cluster"
fi

[ -z "$SERVER_CHECKS_NUMBER" ] && SERVER_CHECKS_NUMBER=20
[ -z "$SERVER_CHECKS_PERIOD" ] && SERVER_CHECKS_PERIOD=30

if [ -n "$newserver" ]; then
  [ -z "$cloud" ] && echo "Cloud is not defined" && exit 1
  [ -z "$NEW_SERVER_START_TRIES" ] && NEW_SERVER_START_TRIES=3
  [ -z "$WAIT_BETWEEN_TRIES" ] && WAIT_BETWEEN_TRIES=30
  echo "*** Bringing up new server in cloud $cloud"
  log "bringing up new server in cloud $cloud"
  if [ -z "$test" ]; then
    #log "updating servers list"
    #IAMACHILD=1 "$M_ROOT/cloud/$cloud/update_servers_list"
    log "getting cloud operations lock"

    lock_cloudops || exit 10
    log "initiating server start sequence"
    
    for ((i=0; i<$NEW_SERVER_START_TRIES; i++)); do
      [ $i -eq 0 ] || sleep $WAIT_BETWEEN_TRIES
      startserver $T
      if [[ `expr "$ip" : "[0-9]*\.[0-9.]*$"` -ne 0 ]]; then
        break
      else
        # assuming it's the exit status (see the function)
        res=$ip
      fi
      [[ $res -eq 2 ]] && log "Timeout waiting for the server ready" && break
      [[ $res -eq 5 ]] && log "Maximum servers number for cluster $cluster has been reached, unable to add another server" && proper_exit 5 411
      # various weird errors below, exit 1 
      [[ $res -eq 6 ]] && log "Failed to generate a name for the new server" && proper_exit 1 413
      [[ $res -eq 7 ]] && log "Failed to find out what image to use to create the new server, define it in clusters.conf, please" && proper_exit 1 414
      [[ $res -eq 8 ]] && log "Failed to find out what flavor (server size) to use, define it in clusters.conf, please" && proper_exit 1 415
      [[ $res -eq 1 ]] && log "Something went wrong, unable to add a server to the cluster $cluster"
      if [ -z "$ip" ]; then
        log "Was unable either to start a cloud server in the cloud $cloud or to get its IP address." && sleep $WAIT_BETWEEN_TRIES && continue
      fi
      [[ `expr $ip : [0-9.]*$` -eq 0 ]] && log "Something's wrong with IP: $ip"
      echo "Something went wrong, check $LOG and fix the problem, next try is in $WAIT_BETWEEN_TRIES seconds"
    done
    [ $i -eq $NEW_SERVER_START_TRIES ] && log "Maximal number of tries reached, exiting" && proper_exit 1 423
  else
    echo "*** This is a test"
  fi
fi

# Default output is console, colored if colors are supported
[ -z "$output" ] && output=console
use_color=false
if [ "$output" == "console" ] ; then
   if [ -z "$M_COLOR" ]; then
    # Thanks to Gentoo guys for this part, I couldn't do better
    safe_term=${TERM//[^[:alnum:]]/?}   # sanitize TERM
    match_lhs=""
    [ -f ~/.dir_colors   ] && match_lhs="${match_lhs}$(<~/.dir_colors)"
    [ -f /etc/DIR_COLORS ] && match_lhs="${match_lhs}$(</etc/DIR_COLORS)"
    [ -z "$match_lhs" ] \
	    && type -P dircolors >/dev/null \
	    && match_lhs=$(dircolors --print-database)
    [[ $'\n'$match_lhs == *$'\n'"TERM "${safe_term}* ]] && use_color=true
  else
    use_color=true
  fi
fi

if [ `echo $ip | grep -c "^$localip$"` -eq 0 ] ; then
  #KEY=`grep "^${cluster}|" "${rpath}/../conf/clusters.conf" | cut -d'|' -f2`
  KEY=`find_key cluster "$cluster"` || KEY=`find_key server "$ip"` || proper_exit 1 450
  [ -z "$KEY" ] && echo "Access key not found!" && proper_exit 1 451
  [ -z "$SSH" ] && echo "SSH client not found!" && proper_exit 1 452
  if [ -z "$list" ] ; then
    #SSH="$SSH -i \"${rpath}/../keys/${KEY}\" -o StrictHostKeyChecking=no"
    $debug && log "ensuring the target server $ip is accessible"
    if [ -z "$test" -a -n "$ip" ] ; then
      for ((k=0; k<$SERVER_CHECKS_NUMBER; k++)); do
        $SSH -i "$KEY" -p $SSHPORT -o "StrictHostKeyChecking=no" -o "ConnectTimeout=10" -o "PasswordAuthentication=no" "$REMOTE_USER"@"$ip" echo >/dev/null
        if [ $? -ne 0 ]; then
          echo "Unable to login to the server $ip using the key ${KEY}, trying again...">>"$LOG"
          loggedin=false
          sleep $SERVER_CHECKS_PERIOD
        else
          loggedin=true
          break
        fi
      done
      if ! $loggedin && [ -n "$newserver" ]; then
        # stop useless server and tell the parent process that something's wrong
        "$M_ROOT"/cloud/$CLOUD/stop_server --ip=$ip
        proper_exit 13 357
      fi
    fi
    #[ -z "$SCP" ] && echo "SCP not found!" && exit 1

    #${rpath}/testmeta --flavor=$flavor --task=$task --role=$role || exit 1

    if [ -z "$timestamp" ]; then
    ## Saving arguments to make re-run simpler
      $debug && log "saving command-line arguments for possible repeat of the sequence"
      IFS2=$IFS ; IFS=$' \t\n'
      for option in `echo $possible_options | sed 's/,/ /g'`; do
        echo "${option}=`eval "echo \\$${option}"`" >> "$WORK_DIR/${role}.${task}.$timestampact/ARGV"
      done
      IFS=$IFS2
      echo -e "flavor=$flavor\ncluster=$cluster\nrole=$role\n" >> "$WORK_DIR/${role}.${task}.$timestampact/ARGV"
      if [ -n "$newserver" ]; then
        echo "ip=$ip" >> "$WORK_DIR/${role}.${task}.$timestampact/ARGV"
      fi
    fi
    ##
  fi
  echo
  if [ -n "$command" ] && [[ `echo $command | grep -c "^[0-9,]*$"` -eq 0 ]]; then
    meta="$command"
    run_meta $meta
  else
    IFS='
'
    cat "$ROLES_ROOT/$role/meta.$task" | grep -v ^# | grep -v ^$ | grep -v ^[[:space:]]*# | while read metaline ; do (IFS=$IFSORIG ; genline $metaline >> "$WORK_DIR/${role}.${task}.$timestampact"/meta) ; done
    
    declare -i metan
    metan=1
    for meta in `cat "$WORK_DIR/${role}.${task}.$timestampact"/meta` ; do
      meta=`eval "echo $meta"`
      runthis=true
      skipthis=false
      if [ -n "$list" ] ; then
        echo "$metan $meta"
        if [ "$list" == "unfold" ]; then
          echo '--------------------------------------------------------------------------------'
          role show script "${meta#* }" | sed 's|\\\$|$|g'
          echo '--------------------------------------------------------------------------------'
        fi
      else
        if [ -n "$skip" ] ; then
          for skipn in `echo -e $skip | tr ',' '\n'` ; do
            [[ $skipn -eq $metan ]] && skipthis=true
          done
        fi
        if [ -n "$command" ] ; then
          runthis=false
          for commandn in `echo -e $command | tr ',' '\n'` ; do
            [[ $commandn -eq $metan ]] && runthis=true
          done
        fi
        if $runthis && ! $skipthis ; then
          (IFS=$IFSORIG ; run_meta $meta)
          [ $? -ne 0 ] && echo -e "Timestamp: $timestampact\nWork directory: $WORK_DIR/${role}.${task}.$timestampact\n" && proper_exit 1 527
        fi
      fi
      metan+=1
    done
    IFS=$IFSORIG
  fi
else
  echo "Setting up self is not supported"
fi
if [ -z "$list" ] ; then
  echo -e "Timestamp: $timestampact\nWork directory: $WORK_DIR/${role}.${task}.$timestampact\n"
  # the best place for this seems to be here
  [ -z "$KEEP_DEPLOYTMP" ] && KEEP_DEPLOYTMP=30
  find "$WORK_DIR" -maxdepth 1 -mindepth 1 -type d -mtime +$KEEP_DEPLOYTMP -exec rm -rf {} \;
fi
echo
if [ -n "$newserver" ]; then
  proper_exit 0 545
fi
#echo "Preparing the keys"
#if [ -f /root/.ssh/id_rsa.pub ] ; then
#  echo "Using existing key"
#else
#  printf "Generating a new key..  "
#  ssh-keygen -q -f /root/.ssh/id_rsa -N '' && printf "done\n" || printf "error\n"
#fi
    
    
    
