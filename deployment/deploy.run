#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/

store_vars() {
  varfile="${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var"
  local role="${1}"
  for LINE in `cat "${ROLES_ROOT}/common/role.conf" "${ROLES_ROOT}/${role}/role.conf" | grep -v ^# | grep -v ^$ | grep -v ^[[:space:]]*#` ; do ELINE=`echo "$LINE" | sed 's|"|\\\"|g' | sed "s|'|\\\'|g" | sed 's_|_\\\|_g'` ; eval "$LINE" ; eval "echo \"$ELINE\"" >> "$varfile" ; done
}

SSH=`which ssh 2>/dev/null`
SCP=`which scp 2>/dev/null`
possible_options="help verbose ip cluster type file key role flavor timestamp task dry cloud"
necessary_options="file type task role"
[ "X$*" == "X" ] && echo "Can't run without options. Possible options are: ${possible_options}" && exit 1
for s_option in "${@}"
do
  found=0
  case ${s_option} in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo "Wrong syntax: options must start with a double dash"
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  for option in `echo $possible_options | sed 's/,/ /g'`; do 
    [ "X$s_optname" == "X$option" ] && eval "$option=${s_optarg}" && found=1
  done
  [ "X$s_option" == "X$s_param" ] && found=1
  if [[ $found -ne 1 ]]; then 
    echo "Unknown option: $s_optname"
    exit 1
  fi
done
if [ "X$help" == "Xyes" ] ; then
  echo "Usage: ${0##*/} <options>"

  exit 0
fi
echo >> "${rpath}/../deploy.log"
date >> "${rpath}/../deploy.log"
echo "-------------------" >> "${rpath}/../deploy.log"
echo "${0} $*" >> "${rpath}/../deploy.log"
echo >> "${rpath}/../deploy.log"

source "${rpath}/../conf/deployment.conf"
source "${rpath}/../conf/cloud.conf"
# These must exist
[ -z "$WORK_DIR" ] && echo "WORK_DIR is not set, check deployment.conf" && exit 1
[ -z "$ROLES_ROOT" ] && echo "ROLES_ROOT is not set, check deployment.conf" && exit 1
[ -n "$SSHPORT" ] || SSHPORT=22
[ -n "$cloud" ] || cloud=$CLOUD
[ -n "$cloud" ] || cloud=common
[ -z "$M_ROOT" ] && M_ROOT=$(cd "${rpath}/../" && pwd)
export PATH=${M_ROOT}/deployment:${M_ROOT}/cloud/${cloud}:${M_ROOT}/helpers:${PATH}

[ -z "$ip" -a -z "$cluster" ] && echo "Neither cluster nor ip not found" >> "${rpath}/../deploy.log" && exit 1
[ -n "$cluster" ] && [ `cat "${rpath}/../servers.list" | grep -v ^$ | grep -v  ^# | grep -v ^[[:space:]]*# | cut -d'|' -f5 | grep -c "$cluster"` -eq 0 ] && echo "No servers found in cluster $cluster" && exit 1
[ -z "$task" ] && task="notask"
[ -z "$role" ] && role="norole"
[ "X$timestamp" == "Xrepeat" ] && timestamp=`ls -1tr "${WORK_DIR}/${role}.${task}.*" | tail -1` && timestamp=${timestamp##*.}
[ -z "$timestamp" ] && timestamp=`date +"%y_%m_%d_%H_%M"`
install -d "${WORK_DIR}/${role}.${task}.${timestamp}/${file%/*}" >> "${rpath}/../deploy.log" 2>&1 || exit 1
declare -i RETVAL
RETVAL=0
IFS1=$IFS; IFS='
'
# save variables to a file
if [ -e "${ROLES_ROOT}/${role}/role.conf" ] ; then
  store_vars $role
fi
# if some other role's script is included in meta script, source its variables
# too. Variables with same names would be overwritten.
roleincluded=${file%%/*}
if [ "X$roleincluded" != "X$role" ] ; then
  if [ -e "${ROLES_ROOT}/${roleincluded}/role.conf" ] ; then
    store_vars $roleincluded
    export ROLEINCL=$roleincluded
  fi
fi
# command-line options (variables from this script) should be saved too
IFS2=$IFS ; IFS=$' \t\n'
for option in `echo $possible_options | sed 's/,/ /g'`; do
  echo "${option}=`eval "echo \\$${option}"`" >> "${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var"
done
IFS=$IFS2
# now prepare the script
for LINE in `cat "${ROLES_ROOT}/${file}"` ; do
  ELINE=$(echo "$LINE" | \
  sed 's|"|\\\"|g' | \
  sed 's|`|\\\`|g')
  a=`eval "echo \"$ELINE\"" 2>/dev/null`
  [ $? -eq 0 ] && [ -n "$a" ] && echo "$a" >> "${WORK_DIR}/${role}.${task}.${timestamp}/${file}" || echo "$LINE" >> "${WORK_DIR}/${role}.${task}.${timestamp}/${file}"
done
  
if [ "$type" == "remote" ] ; then
  if [ -z "$cluster" ] && [ -n "$ip" ] ; then
    cluster=`grep "^${ip}|" "${rpath}/../servers.list" | cut -d'|' -f5`
    [ -z "$cluster" ] && echo "Unable to find cluster name" >> "${rpath}/../deploy.log" && exit 1
  fi
  M_ROOT_REMOTE=`grep "^${cluster}|" "${rpath}/../conf/clusters.conf" | cut -d'|' -f8`
  [ -n "$M_ROOT_REMOTE" ] || M_ROOT_REMOTE=$M_ROOT
  [ -n "$key" ] || key=`grep "^${cluster}|" "${rpath}/../conf/clusters.conf" | cut -d'|' -f2`
  if [ -n "$ip" ] && [ -z "$key" ] ; then
    key=`grep "^${ip}|" "${rpath}/../servers.list" | cut -d'|' -f2`
  fi
  [ -f "${rpath}/../keys/${key}" ] || key=${key}.pem
  [ -f "${rpath}/../keys/${key}" ] || (echo "Key $key not found" >> "${rpath}/../deploy.log" ; exit 1)
  echo "`date +"%H:%M:%S"` REMOTE $file" >> "${rpath}/../deploy.log"
  if [ -z "$ip" ] ; then
    ips=`get_ips --cluster="${cluster}"`
  else
    ips=$ip
  fi
  for IP in $ips ; do
    # install remote workdir
    $SSH -p $SSHPORT -i "${rpath}/../keys/${key}" $IP install -d "${WORK_DIR}/${role}.${task}.${timestamp}/${file%/*}" >> "${rpath}/../deploy.log" 2>&1 || exit 1
    # copy the script to remote server
    $SCP -P $SSHPORT -i "${rpath}/../keys/${key}" "${WORK_DIR}/${role}.${task}.${timestamp}/${file}" "${IP}:${WORK_DIR}/${role}.${task}.${timestamp}/${file}" >> "${rpath}/../deploy.log" 2>&1 || exit 1
    # copy config to remote server
    $SCP -P $SSHPORT -i "${rpath}/../keys/${key}" "${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var" "${IP}:${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var" >> "${rpath}/../deploy.log" 2>&1
    $SSH -p $SSHPORT -i "${rpath}/../keys/${key}" $IP echo "ip=$IP" \>\> "${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var"
    if [ -n "$dry" ] ; then
      result=`$SSH -p $SSHPORT -i "${rpath}/../keys/${key}" $IP "(source ${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var && cat ${WORK_DIR}/${role}.${task}.${timestamp}/${file})"`
    else
      # run the script, catch the output, exit if non-zero status
      result=`$SSH -p $SSHPORT -i "${rpath}/../keys/${key}" $IP "(source ${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var && bash ${WORK_DIR}/${role}.${task}.${timestamp}/${file} 2>&1 || echo ${timestamp}_ERROR)"`
    fi
    if [ -n "$verbose" ] ; then
      echo "--------------------------------------------------------------------------------"
      echo "${result}" | tee -a "${rpath}/../deploy.log"
      echo "--------------------------------------------------------------------------------"
    else
      echo "${result}" >> "${rpath}/../deploy.log"
    fi
    [ `echo "${result}" | grep -c ${timestamp}_ERROR` -gt 0 ] && RETVAL+=1 && break
  done
elif [ "$type" == "local" ] ; then
  echo "`date +"%H:%M:%S"` LOCAL $file" >> "${rpath}/../deploy.log"
  if [ -n "$dry" ] ; then
    result=`(source ${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var && cat ${WORK_DIR}/${role}.${task}.${timestamp}/${file})`
  else
    # running the script
    result=`(source ${WORK_DIR}/${role}.${task}.${timestamp}/${file}.var && bash ${WORK_DIR}/${role}.${task}.${timestamp}/${file} 2>&1 || echo ${timestamp}_ERROR)`
  fi
  if [ -n "$verbose" ] ; then
      echo "--------------------------------------------------------------------------------"
      echo "${result}" | tee -a "${rpath}/../deploy.log"
      echo "--------------------------------------------------------------------------------"
    else
      echo "${result}" >> "${rpath}/../deploy.log"
    fi
  [ `echo "${result}" | grep -c ${timestamp}_ERROR` -gt 0 ] && RETVAL+=1
else
  echo "type: \"$type\" not supported"
  exit 1
fi
IFS=$IFS1

unset ip cluster type file key role flavor result
exit $RETVAL



