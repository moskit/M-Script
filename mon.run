#!/bin/bash
# Copyright (C) 2008-2014 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

currentlocale=`echo ${LC_MESSAGES}`
export LC_MESSAGES="C"

HOSTNAME=`which hostname 2>/dev/null`
[ -h $0 ] && xcommand=`readlink $0` || xcommand=$0
rcommand=${xcommand##*/}
rpath=${xcommand%/*}
M_ROOT="$rpath" ; export M_ROOT
commline="$0 $*"
commlinehash=`echo "$commline" | md5sum | cut -b 1,2,3,4,5,6,7,8`
echo "`date +"%H:%M:%S"` == Running $commline ==" >> "$rpath/monitoring.log"
#*/

# removing stale lock file
[ -n "$MAXLOCK" ] || MAXLOCK=30
lockfile=`find "$rpath" -maxdepth 1 -name mon.run.lock -mmin +$MAXLOCK`
if [ -n "$lockfile" ] ; then
  ls -l "$lockfile" >> "$rpath/monitoring.log"
  echo "`date +"%H:%M:%S"` *** Lock file is older than $MAXLOCK minutes, removing" >> "$rpath/monitoring.log"
  rm -f "$lockfile"
fi
sleep $((RANDOM%5))
for ((i=1; i<=10; i++))
do
  if [ -e "$rpath/mon.run.lock" ] ; then
    printf "." >> "$rpath/monitoring.log"
    sleep $((RANDOM%10))
    continue
  else
    echo "`date +"%H:%M:%S"` not locked" >> "$rpath/monitoring.log"
    break
  fi
done
if [ -f "$rpath/mon.run.lock" ] ; then
  echo >> "$rpath/monitoring.log"
  echo "Giving up..." >> "$rpath/monitoring.log"
  exit 1
fi

touch "$rpath/mon.run.lock" && echo "`date +"%H:%M:%S"` >>> locking by $commline" >> "$rpath/monitoring.log"

function mailreport() {
  while read RLINE
  do
    if [ -n "$RLINE" ]; then
      cat "$rpath/conf/rep.header" "$rpath/report" | $MAILX -s "Server `$HOSTNAME -f 2>/dev/null || $HOSTNAME` report" "$RLINE"
    fi
  done < ${rpath}/conf/mail.admin.list
}

function mailalert() {
  if [ -f "$rpath/alert1" ] && [ `cat "$rpath/alert1" | wc -l` -ne 0 ]; then
    al='*' ; aln=1
    cat "$rpath/conf/header.alert1" "$rpath/alert1" >> "$rpath/alert"
  fi
  if [ -f "$rpath/alert2" ] && [ `cat "$rpath/alert2" | wc -l` -ne 0 ]; then
    al='**' ; aln=2
    cat "$rpath/conf/header.alert2" "$rpath/alert2" >> "$rpath/alert"
  fi
  if [ -f "$rpath/alert3" ] && [ `cat "$rpath/alert3" | wc -l` -ne 0 ]; then
    al='***' ; aln=3
    cat "$rpath/conf/header.alert3" "$rpath/alert3" >> "$rpath/alert"
  fi
  if [ -n "$al" ] ; then
    echo "================ sending alert =================" >> "$rpath/monitoring.log"
    cat "$rpath/alert" >> "$rpath/monitoring.log"
    echo "================================================" >> "$rpath/monitoring.log"
    for MLINE in `cat "$rpath/conf/mail.alert.list" | grep -vE "^$|^#|^[[:space:]]*#" | awk '{print $1}'`
    do
      recipn=`grep "^$MLINE" "$rpath/conf/mail.alert.list" | awk '{print $2}'`
      if ([ -z "$recipn" ] || [ $recipn -le $aln ]) ; then
        cat "$rpath/alert" | $MAILX -s "$al Server `$HOSTNAME -f 2>/dev/null || $HOSTNAME` alert" "$MLINE" >> "$rpath/monitoring.log" 2>&1
      fi
    done
  fi
  unset al aln
}

function cleanup() {
  rm -f "$rpath"/alert* 2>/dev/null
}

function runscript() {
  local LOG="$rpath/monitoring.log"
  daynow=$(date +"%Y%m%d")
  if [ "_$SQLITE3" == "_1" ] && ([ "_$1" == "_SQL" ] || [ "_$2" == "_SQL" ])
  then
    dbquery "$rpath/sysdata" "insert into sysdata (timeindex, day) values ('$timeindexnow', '$daynow')"
  fi

  echo -e "$etitle" >> "$LOG"
  echo -e "$etitle" > "$rpath/report"

  if [ "_$1" == "_SQL" ]; then
    
    for script in "$rpath/rc/"*.mon  #*/
    do
      [ -n "$RUNDELAY" ] && sleep $RUNDELAY && delay+=$RUNDELAY
      time0=`date +"%s"`
      mon="$rpath/rc/`readlink $script`"
      if [ -x "$mon" ]; then
        log "$mon"
        monoutput=`$mon $SQL 2>&1`
        echo "$monoutput" >> "$LOG"
        rmon=${mon##*/}
        if alert_blocked $rmon ; then
          log "=== alert is blocked for $mon"
          echo "$monoutput" >> "$rpath/report.blocked"
        else  
          echo "$monoutput" >> "$rpath/report"
        fi
        time1=`date +"%s"`
        dbquery "$rpath/sysdata" "insert into selfmon (timeindex, day, monitor, duration) values ('$timeindexnow', '$daynow', '$rmon', '`expr $time1 - $time0`')"
      else
        log "monitor $mon does not exist or is not executable"
      fi
    done

  elif [ -n "$1" ]; then
    for mon in `echo $1 | sed 's|,| |g'` ; do
      [ -n "$RUNDELAY" ] && sleep $RUNDELAY && delay+=$RUNDELAY
      if [ -x "$rpath/tests/$mon" ]; then
        log "$mon"
        monoutput=$("$rpath"/tests/$mon $SQL 2>&1 ; echo)
        echo "$monoutput" >> "$LOG"
        if alert_blocked ${mon##*/} ; then
          log "=== alert is blocked for $mon"
          echo "$monoutput" >> "$rpath/report.blocked"
        else
          echo "$monoutput" >> "$rpath/report"
        fi
      fi
    done
  fi
  echo >> "$rpath/report"
  al3=`grep '<\*\*\*>' "$rpath/report" | sed 's|<\*\*\*>||g'` > "$rpath/alert3"
  al2=`grep '<\*\*>' "$rpath/report" | sed 's|<\*\*>||g'` > "$rpath/alert2"
  al1=`grep '<\*>' "$rpath/report" | sed 's|<\*>||g'` > "$rpath/alert1"
  al0=`grep '<OK>' "$rpath/report" | sed 's|<OK>||g'` > "$rpath/alert0"
  [ -n "$al3" -o -n "$al2" -o -n "$al1" -o -n "$alok" ] && echo -e "$etitle" > "$rpath/alert"
  [ -n "$al3" ] && echo -e "$al3\n" > "$rpath/alert3"
  [ -n "$al2" ] && echo -e "$al2\n" > "$rpath/alert2"
  [ -n "$al1" ] && echo -e "$al1\n" > "$rpath/alert1"
  [ -n "$al0" ] && echo -e "$al0\n" > "$rpath/alert0"
}

function runactions() {
  local LOG="$M_ROOT/logs/actions.log"
  if [ -f "$rpath/report.blocked" ]; then
    log "blocked alerts found"
    
    grep '<\*\*\*>' "$rpath/report.blocked" | sed 's|<\*\*\*>||g' >> "$rpath/alert3"
    grep '<\*\*>' "$rpath/report.blocked" | sed 's|<\*\*>||g' >> "$rpath/alert2"
    grep '<\*>' "$rpath/report.blocked" | sed 's|<\*>||g' >> "$rpath/alert1"
    grep '<OK>' "$rpath/report.blocked" | sed 's|<OK>||g' >> "$rpath/alert0"
  fi
  rm -f "$rpath/report.blocked"
  IFS1=$IFS; IFS='
'
  for action in `cat "$rpath/conf/actions.conf" | grep -vE "^$|^#|^[[:space:]]*#" | cut -d'|' -f3 | sort | uniq` ; do
    #action=`echo "$action" | sed 's_\\$_\\\\$_'`
    all_alerts_found=false
    action_blocked "$action" && log "not doing anything: action $action is blocked" && continue
    for confline in `grep -E "\|${action}\||\|${action}$" "$rpath/conf/actions.conf" | grep -vE "^$|^#|^[[:space:]]*#"` ; do
      pattern=`echo $confline | cut -d'|' -f1`
      level=`echo $confline | cut -s -d'|' -f2`
      nalerts=`echo $confline | cut -s -d'|' -f4`
      blockccl=`echo $confline | cut -s -d'|' -f5`
      BLOCK_ERR13=`echo $confline | cut -s -d'|' -f6`
      BLOCK_ERR5=`echo $confline | cut -s -d'|' -f7`
      export BLOCK_ERR13 BLOCK_ERR5
      if [ -n "$nalerts" ] ; then
        [ -e "$M_TEMP/consequent_alerts.tmp" ] && calerts=`cat "$M_TEMP/consequent_alerts.tmp" | grep ^"$commline"\|"$pattern"\|$level\| | tail -1`
        if [ -n "$calerts" ] ; then
          calerts=`echo "$calerts" | cut -s -d'|' -f4`
          cinterval=`echo "$calerts" | cut -s -d'|' -f5`
        fi
        if [ `expr "$nalerts" : ".*[^[0-9]]*.*"` -gt 0 ]; then
          # if it's not a number, it's a number per time interval
          # (format: n/interval)
          alerts_interval=`echo "$nalerts" | cut -s -d'/' -f2`
          nalerts=`echo "$nalerts" | cut -s -d'/' -f1`
          [ -z "$nalerts" -o -z "$alerts_interval" ] && echo "Bad consequent alerts number or time interval setting in actions.conf for action '$action'" >> "$rpath/monitoring.log" && continue
          alerts_interval=`date -d "1970/01/01 +$alerts_interval" +"%s" 2>/dev/null`
          [ -z "$alerts_interval" ] && echo "Time format incorrect in actions.conf for action '$action'" >> "$rpath/monitoring.log" && continue
          [ -z "$calerts" ] && echo "$commline|$pattern|$level|0|0" >> "$M_TEMP/consequent_alerts.tmp"
        else
          [ -z "$calerts" ] && echo "$commline|$pattern|$level|0" >> "$M_TEMP/consequent_alerts.tmp"
        fi
      fi
      
      [ -z "$level" -o `expr "$level" : ".*[^[0-9]]*.*"` -gt 0 ] && echo "Bad alert level setting in actions.conf for action '$action'" >> "$rpath/monitoring.log" && continue
      
      action_alert_found=false
      alert_match=false
      
      [[ $level -eq 0 ]] && levelmax=0 || levelmax=3
      
      pattern_match=`echo "$pattern" | sed 's_\\\(__g;s_\\\)__g'`
      pattern_extract="\ *${pattern}"

      for ((i=$level; i<=$levelmax; i++)) ; do

        while read line ; do
          [ -z "$line" ] && continue
          if [ -z "$nalerts" ]; then
            if [[ $line =~ $pattern_match ]]; then
              alert_match=true
              XVAR=`expr "$line" : "$pattern_extract" 2>/dev/null`
              break
            fi
          else
            if [[ $line =~ $pattern_match ]] ; then
              action_alert_found=true
              if [ -z "$calerts" ]; then
                calerts=1
                [ -n "$alerts_interval" ] && cinterval=0
              fi
              calerts=`expr $calerts + 1`
              if [ -n "$alerts_interval" ]; then
                [ -z "$timeshift" ] && timeshift=`cat "$M_TEMP/timeshift"`
                cinterval=`expr $cinterval + $FREQ + $timeshift`
                sed -i "s%^$commline|$pattern|$level|.*%$commline|$pattern|$level|${calerts}|${cinterval}%" "$M_TEMP/consequent_alerts.tmp"
                if [[ $calerts -ge $nalerts ]] && [[ $cinterval -ge $alerts_interval ]]; then
                  alert_match=true
                  XVAR=`expr "$line" : "$pattern_extract" 2>/dev/null`
                  break
                fi
              else
                sed -i "s%^$commline|$pattern|$level|.*%$commline|$pattern|$level|${calerts}%" "$M_TEMP/consequent_alerts.tmp"
                if [[ $calerts -ge $nalerts ]]; then
                  alert_match=true
                  XVAR=`expr "$line" : "$pattern_extract" 2>/dev/null`
                  break
                fi
              fi
            fi
          fi
          export XVAR
        done <"$rpath/alert$i"
      done   ## <-- finished reading alerts
      
      if $alert_match ; then
        # matching condition found, but conditions might be ANDed
        # multiple conditions with the same action are ANDed
        # to make them ORed, add marks to the beginning of action, enclosed in
        # percent sign, e.g. %1% [action], %2% [action] and so on
        all_alerts_found=true
        log "alert match! XVAR: $XVAR"
      else
        all_alerts_found=false
      fi
      if ! $action_alert_found ; then
        # if no match, alert is not consequent and must be zeroed
        [ -n "$nalerts" ] && sed -i "s%^$commline|$pattern|$level|.*%$commline|$pattern|$level|0%" "$M_TEMP/consequent_alerts.tmp"
      fi
    done   ## <-- finished reading config
    
    if $all_alerts_found ; then
      XVARTXT="; XVAR: $XVAR"
      log "all alerts found for action: $action ; block enabled, cycles: $blockccl"
      [ -n "$blockccl" ] && block_action $blockccl "$action"
      echo -e "\n`date +"%m.%d %H:%M:%S"` action initiated: ${action}${XVARTXT}\n" >> "$rpath/monitoring.log" | tee -a $LOG
      for MLINE in `cat "$rpath/conf/mail.alert.list" | grep -vE "^$|^#|^[[:space:]]*#" | awk '{print $1}'`
      do
        echo "`date +"%m.%d %H:%M:%S"` alert pattern $pattern_match initiated action: ${action}${XVARTXT}" | $MAILX -s "Action triggered! Server `$HOSTNAME -f 2>/dev/null || $HOSTNAME` alert" "$MLINE"
      done
      action_or=`expr "$action" : "^%.*%\ \(.*\)"`
      [ -z "$action_or" ] && action $action || action $action_or
      [ -n "$nalerts" ] && sed -i "s%^$commline|$pattern|$level|.*%$commline|$pattern|$level|0%" "$M_TEMP/consequent_alerts.tmp"
    fi

  done
IFS=$IFS1
}

function runactionstest() {
IFS1=$IFS; IFS='
'
for confline in `cat "$rpath/conf/actions.conf" | grep -v ^$|grep -v ^#|grep -v ^[[:space:]]*#` ; do
  pattern=`echo $confline | cut -d'|' -f1`
  level=`echo $confline | cut -d'|' -f2`
  action=`echo $confline | cut -d'|' -f3`
  while read line ; do
    [[ $line =~ $pattern ]] && echo && echo "The alert message: \'$line\' would trigger the action: \'$action\'" && echo
  done<"$rpath/alert$level"
done
IFS=$IFS1
}

function newtimeindex() {
  timeindexnow=`date +"%s"`
  echo $timeindexnow > "$M_TEMP/timeindex.$commlinehash"
  lasttimeindex=`cat "$M_TEMP/lasttimeindex.$commlinehash" 2>/dev/null || echo 0`
  export timeindexnow lasttimeindex
}

function deltimeindex() {
  mv "$M_TEMP/timeindex.$commlinehash" "$M_TEMP/lasttimeindex.$commlinehash"
}

function timeshift() {
  fintime=`date +"%s"`
  timediff=`expr $fintime - $timeindexnow`
  timeshift=`expr $timediff - $delay`
  export timeshift timediff
  echo $timediff > "$M_TEMP"/timediff
  echo $timeshift > "$M_TEMP"/timeshift
  for l in 1 2 3 ; do
    MAINSEQ_EXECTIME=`eval "echo \\$MAINSEQ_EXECTIME_$l"`
    [ `expr $timeshift \> $MAINSEQ_EXECTIME` -eq 1 ] && echo "${BASH_SOURCE##*/} execution time is longer than $MAINSEQ_EXECTIME" >> "$rpath/alert$l" && return
  done
}

function action() {
  local newfile=false
  act=`echo "$@" | sed 's|/|\\\/|g;s| |\\\ |g'`
log "action: matching $act"
  [ -f "$rpath/actions.in" ] || newfile=true
  JOBINTIME=`date +"%y%m%d%H%M%S"`
  echo "`cat "$rpath/conf/actions.conf" | grep -vE "^$|^#|^[[:space:]]#" | grep "$act" | cut -d'|' -f3`|$JOBINTIME|" >> "$rpath/actions.in" && log "=== job created: $@"
  $newfile && chmod 600 "$rpath/actions.in"
  "$rpath"/lib/mq.run &
}

source "$rpath/conf/mon.conf"
[ -z "$MAILX" ] && MAILX=`which mail 2>/dev/null`
source "$rpath/lib/functions.sh"
SQLITE=dbquery
declare -i delay ; delay=0
export M_TEMP FREQ M_ROOT THRESHOLD SQLITE3 IPTABLES
[ "_$2" == "_SQL" ] && SQL=SQL
[ -d $M_TEMP ] || install -d $M_TEMP
etitle="------------------------------\n`date`\n------------------------------"

case $1 in
  --alert-only | -ao | -alert | --only-alert)
    newtimeindex
    runscript SQL
    mailalert
    gendash servers "$M_ROOT/report" marked
    runactions
    deltimeindex
    cleanup
  ;;
  -dry | --dry | --dry-run | -test | --test)
    export TEST=1
    newtimeindex
    runscript SQL
    runactionstest
    deltimeindex
    cat "$rpath/report"
    cleanup
  ;;
  -h | -help | --help)
    echo "Usage: mon.run --report"
    echo "         - collects and logs system data and then sends report"
    echo "       mon.run --alert-only"
    echo "         - collects and logs system data, but sends report only if problems"
    echo "           found"
    echo "       mon.run --dry-run"
    echo "         - collects and logs system data, outputs it to stdout and store it"
    echo "           into the database, but doesn't send any reports."
    echo "       mon.run --analyze-system"
    echo "         - analyzes system parameters change over a period of time and sends"
    echo "       a report."
    echo "       mon.run <scriptname.mon.sh>"
    echo "         - runs a selected script and sends an alert if necessary"
#    echo "       mon.run --analyze-logs"
#    echo "         - analyzes log messages since the last run and sends the statistical"
#    echo "       data and an unusual activity report."
  ;;
  -rep | -report | --report)
    newtimeindex
    runscript SQL
    mailreport
    mailalert
    genreport servers "$M_ROOT/report"
    deltimeindex
    cleanup
  ;;
  *.mon)
    newtimeindex
    runscript "$1" $SQL
    timeshift
    mailalert
    gendash servers "$M_ROOT/report"
    runactions
    deltimeindex
    cleanup
  ;;
  *)
    echo "Run mon.run --help to see available options"
  ;;
esac
rm -f "$rpath/mon.run.lock" && echo "`date +"%H:%M:%S"` <<< unlocking by $commline" >> "$rpath/monitoring.log"

export LC_MESSAGES=`echo $currentlocale`

