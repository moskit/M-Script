#!/bin/bash

# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

declare -i i
i=0
declare -a index
index[$i]=0
emptyobj=true
#d=1

parseline() {
  line=$1
  if [ -n "$d" ] ; then
    echo "Parsing line = $line"
    echo "  WAS: index = $i"
    echo "  WAS: var[$i] = ${index[$i]}"
    echo "  WAS: value = $value"
    echo "  WAS: emptyobj = $emptyobj"
    echo "  WAS: isclosed = $isclosed"
  fi
  if [ "X$line" == "X{" ] ; then
    $emptyobj && emptyobj=false && index[$i]=`expr ${index[$i]} + 1`
    if [ -n "$value" ] ; then
      printvalue "$value" && unset value
    fi
    i+=1
    if [ -n "$d" ] ; then
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
    return
  fi
  if [ "X$line" == "X}" ] ; then
    emptyobj=true
    if [ -n "$value" ] ; then
      printvalue "$value" && unset value
    fi
    i+=-1
    if [ -n "$d" ] ; then
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
    return
  fi
  if [ "X$line" == "X[" ] ; then
    #isarray=true
    
    if [[ $isclosed -ne 0 ]] ; then
      printvalue "$value" && unset value
      i+=1
      index[$i]=0
    else
      value="${value}${line}"
    fi
    if [ -n "$d" ] ; then
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
    return
  fi
  if [ "X$line" == "X]" ] ; then
    #isarray=false
    if [[ $isclosed -ne 0 ]] ; then
      printvalue "$value" && unset value
      i+=-1
    else
      value="${value}${line}"
    fi
    if [ -n "$d" ] ; then
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
    return
  fi
  if [ "X$line" == "X," ] ; then
    #emptystr=true
    if [[ $isclosed -ne 0 ]] ; then
      printvalue "$value" && unset value
    else
      value="${value}${line}"
    fi
    if [ -n "$d" ] ; then
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
    return
  fi
  if [ -n "$line" ] ; then
    $emptyobj && emptyobj=false
    #$emptystr && $isarray && emptystring=false && index[$i]=`expr ${index[$i]} + 1`
    #printf "== $line == "
    quotes=`expr "$line" : '.*".*'`
    if [[ $quotes -ne 0 ]] ; then
      f4=`echo $line | cut -d'"' -f4`
      f3=`echo $line | cut -d'"' -f3`
      f2=`echo $line | cut -d'"' -f2`
      f1=`echo $line | cut -d'"' -f1`
      # "string" : "string"

      if [ -n "$f4" ] ; then
        isclosed=`expr "$line" : '.*"$'`
        #echo '"string" : "string"'
        if [ -n "$f2" ] ; then
          index[$i]="$f2"
          if [[ $f3 =~ ^[[:space:]]*\:[[:space:]]*$ ]] ; then
            value="$f4"
          else
            # why is this?
            value="`echo "$f3" | cut -d':' -f2`\"${f4}\"`echo "$line" | cut -d'"' -f5`"
          fi
        fi
      else
        # either of:
        # notstring : notstring
        if [ -z "$f2" ] ; then
          if [ -z "$f1" ] ; then
            isclosed=1
          else
            #echo "notstring : notstring"
            index[$i]="`echo "$line" | cut -d':' -f1 | sed 's|^[[:space:]]*||;s|[[:space:]]*$||;s|^"||;s|"$||'`"
            value="`echo "$line" | cut -d':' -f2 | sed 's|^[[:space:]]*||;s|[[:space:]]*$||;s|^"||;s|"$||'`"
          fi
        else
        # notstring : "string"
          if [ -n "$f1" ] ; then
            #echo 'notstring : "string"'
            index[$i]="`echo "$f1" | cut -d':' -f1 | sed 's|^[[:space:]]*||;s|[[:space:]]*$||;s|^"||;s|"$||'`"
            if [ "X`echo $f1 | cut -d':' -f2 | sed 's|^[[:space:]]*||;s|[[:space:]]*$||;s|^"||;s|"$||'`" == "X" ] ; then
              value="$f2"
            else
              value="`echo "$f1" | cut -d':' -f2`\"${f2}\"${f3}"
            fi
            
          # "string" : notstring
          else
            #echo '"string" : notstring'
            # might be array, so no f3
            if [ -z "$f3" ] ; then
              value=$f2
            else
              index[$i]=$f2
              value="`echo $f3 | cut -d':' -f2 | sed 's|^[[:space:]]*||;s|[[:space:]]*$||;s|^"||;s|"$||'`"
            fi
          fi      
        fi
      
      fi
    
    else
      value="${value}${line}"
    fi
    if [ -n "$d" ] ; then
      echo "  = it's a data line"
      echo "  NOW: index = $i"
      echo "  NOW: var[$i] = ${index[$i]}"
      echo "  NOW: value = $value"
      echo "  NOW: emptyobj = $emptyobj"
      echo "  NOW: isclosed = $isclosed"
    fi
#    unset noprint
  fi

}

printvalue() {
  [ -z "$1" ] && return
  valuename="${index[0]}"
  for ((n=1; n<=$i; n++)) ; do
    valuename="${valuename}/${index[$n]}"
  done
  valuename=${valuename%/}
  echo "${valuename}|${1}"
  unset valuename
}

#( IFS='' ; for LINE in `cat $1` ; do echo "${LINE}" ; done ) | while read L ; do a=`printf "$L"|sed 's|{|\n{\n|g;s|}|\n}\n|g;s|,|\n|g'` ; echo "$a" | while read b ; do parseline $b ; echo ">>> $i $z" ; z=$i ; done ; done
cat $1|sed 's|{|\n{\n|g;s|},|\n}\n|g;s|}|\n}\n|g;s|",|"\n,\n|g;s|,"|\n,\n"|g;s|,$|\n,|g;s|,[[:space:]]"|\n,\n"|g;s|\[|\n\[\n|g;s|\],|\n\]\n|g;s|\]|\n\]\n|g' | while read b ; do [ -n "$b" ] && parseline "${b}" ; done
unset branch index ndcont cont i LINE node

