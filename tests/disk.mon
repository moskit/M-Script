#!/usr/bin/env bash
# Copyright (C) 2008-2011 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

rcommand=${0##*/}
rpath=${0%/*}
#*/ (this is needed to fix vi syntax highlighting)
[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../")
source "$rpath/../conf/mon.conf"
source "${0%.mon}.conf"
source "$M_ROOT/lib/functions.sh"

diffsec=`expr $timeindexnow - $lasttimeindex 2>/dev/null` || diffsec=1000000
sinceboot=`cat /proc/uptime | cut -d'.' -f1` || sinceboot=1000000

resolve_uuid() {
  local resdisk
  if [ "${1:0:4}" == "UUID" ]; then
    resdisk=`readlink /dev/disk/by-uuid/${1:5} 2>/dev/null`
    echo "this is UUID that resolves to $resdisk" >> $M_TEMP/disk.tmp.discovered
  fi
  echo "$resdisk"
}

check_slaves() {
  slaves=`ls /sys/class/block/$1/slaves 2>/dev/null`
  if [ -n "$slaves" ] ; then
    echo "Disk $1 is a logical volume built upon `echo $slaves`" >> "$M_TEMP/disk.tmp.discovered"
    for sldisk in $slaves ; do
      if `grep -q $sldisk$ /proc/partitions` ; then
        echo "/dev/$sldisk" >> "$M_TEMP"/disk.tmp.ext
      else
        realsldisk=`resolve_uuid $sldisk`
        if [ -n "$realsldisk" ]; then
          `grep -q $sldisk$ /proc/partitions` && echo "/dev/$realsldisk" >> "$M_TEMP"/disk.tmp.ext
        fi
      fi
    done
  fi
}

if [ "_$SQLITE3" == "_1" ]; then
  alltables=`dbquery "$rpath/../sysdata" ".tables" | sed 's|\ \ *|\n|g'`
fi

echo -e "\nDisks usage:\n------------\n"

df -m | grep -vE "^shm|^tmpfs|^devtmpfs|^udev|^none|^Filesystem" > "$M_TEMP/disk.tmp"

printf "\tDisk\t\t\t\tMountpoint\t\t\tUsage\n\n"
while read LINE
do
  if [ -n "$LONGLINE" ]
  then
    LINE="$LONGLINE $LINE"
    LONGLINE=""
  fi
  # Sometimes df breaks a line, if it is much longer than 80 symbols
  if [ -z "$(echo "$LINE" | awk '{ print $6}')" ] && [ -z "$LONGLINE" ]
  then
    LONGLINE="$LINE"
    continue
  fi
  disk=$(echo "$LINE" | awk '{ print $1}')
  mpoint=$(echo "$LINE" | awk '{ print $6}')
  used=$(echo "$LINE" | awk '{ print $5}' | sed 's@\%@@')
  x1="$(echo "$used >= $DISK_WARN_1" | bc)"
  x2="$(echo "$used >= $DISK_WARN_2" | bc)"
  x3="$(echo "$used >= $DISK_WARN_3" | bc)"
  warnind='<OK> '
  [ "$x1" == "1" ] && warnind=' <*> '
  [ "$x2" == "1" ] && warnind='<**> '
  [ "$x3" == "1" ] && warnind='<***>'
  echo "$used" >> "$M_TEMP/diskusage"
  printf "$warnind\t$disk"
  m=`expr length $disk`
  l=`expr 32 - $m`
  if [ $l -lt 1 ] ; then
    printf " "
  else
    for ((n=1; n <= $l; n++)); do printf " "; done
  fi
  printf "$mpoint"
  m=`expr length $mpoint`
  l=`expr 32 - $m`
  if [ $l -lt 1 ] ; then
    printf " "
  else
    for ((n=1; n <= $l; n++)); do printf " "; done
  fi
  printf "$used%%\n"
  
## Discovering what this disk really is
  disk=${disk##*/}
  if `grep -q $disk$ /proc/partitions` ; then
    echo $disk >> "$M_TEMP/disk.tmp.ext"
  else
    if [ -h /dev/$disk ]; then
      realdisk=`readlink /dev/$disk`
      echo "/dev/$disk is a symlink to $realdisk" >> $M_TEMP/disk.tmp.discovered
    elif [ "$disk" == "root" ]; then
      realdisk=`grep root= /proc/cmdline`
      if [ -n "$realdisk" ]; then
        realdisk=`echo "$realdisk" | cut -d'=' -f2 | cut -d' ' -f1`
        echo "/dev/root is $realdisk" >> $M_TEMP/disk.tmp.discovered
        if ! `grep -q ${realdisk##*/}$ /proc/partitions` ; then
          realdisk=`resolve_uuid ${realdisk##*/}`
        fi
      else
        echo "Unable to resolve /dev/root" >> $M_TEMP/disk.tmp.discovered
      fi
    fi
    check_slaves $disk
    [ -z "$realdisk" ] && echo "Unable to resolve $disk" >> $M_TEMP/disk.tmp.discovered && continue
    disk=${realdisk##*/}
    echo "/dev/$disk" >> "$M_TEMP"/disk.tmp.ext
  fi

done < "$M_TEMP/disk.tmp"

# inodes usage
df -i | grep -vE "^shm|^tmpfs|^devtmpfs|^udev|^none|^Filesystem" > "$M_TEMP/disk.tmp.i"

while read LINE
do
  if [ -n "$LONGLINE" ]
  then
    LINE="$LONGLINE $LINE"
    LONGLINE=""
  fi
  # Sometimes df breaks a line, if it is much longer than 80 symbols
  if [ -z "$(echo "$LINE" | awk '{ print $6}')" ] && [ -z "$LONGLINE" ]
  then
    LONGLINE="$LINE"
    continue
  fi
  disk=$(echo "$LINE" | awk '{ print $1}')
  mpoint=$(echo "$LINE" | awk '{ print $6}')
  used=$(echo "$LINE" | awk '{ print $5}' | sed 's@\%@@')
  unset warnind
  x1="$(echo "$used >= $DISK_WARN_1" | bc)"
  x2="$(echo "$used >= $DISK_WARN_2" | bc)"
  x3="$(echo "$used >= $DISK_WARN_3" | bc)"
  [ "$x1" == "1" ] && warnind=' <*> '
  [ "$x2" == "1" ] && warnind='<**> '
  [ "$x3" == "1" ] && warnind='<***>'
  echo "$used" >> "$M_TEMP/diskusage.i"
  [ -n "$warnind" ] && echo "$warnind disk $disk mountpoint $mpoint inodes usage is $used"

done < "$M_TEMP/disk.tmp.i"

swaps=`cat /proc/swaps | grep '^\/dev\/' | awk '{ print $1 }'`
echo "$swaps" >> "$M_TEMP/disk.tmp.ext"
for sw in `echo "$swaps"` ; do
  echo "$sw is a swap partition" >> $M_TEMP/disk.tmp.discovered
  check_slaves $sw
  swdisk=`resolve_uuid $sw`
  [ -n "$swdisk" ] && echo "/dev/${swdisk##*/}" >> "$M_TEMP/disk.tmp.ext"
done
echo

if [ "_$SQLITE3" == "_1" ]; then
  echo -e "\nAverage disk I/O usage:\n-----------------------\n\n    Disk                           Time percentage                 Mbytes/sec\n"

  for LINE in `cat $M_TEMP/disk.tmp.ext | sort | uniq`; do

    disk=${LINE##*/}
    [ -z "$disk" ] && continue
    
    if [ "_$SQLITE3" == "_1" ]; then
      tablefound=false
      echo "$alltables" | grep -q ^$disk$ && tablefound=true
      if ! $tablefound ; then
        log "creating table $disk"
        dbquery "$rpath/../sysdata" "create table $disk (timeindex integer primary key, diskusage real, diskreads real, diskwrites real, drspeed real, dwspeed real, drtime integer, dwtime integer); create index ti${disk} (timeindex)"
      fi
      if [ "_$1" == "_SQL" ]; then
        dbquery "$rpath/../sysdata" "insert into $disk (timeindex) values ('$timeindexnow')"
      fi
    fi
    # reading stats
    dr=$(cat /proc/diskstats | grep " $disk " | awk '{ print $6 }')
    [ -z "$dr" ] && disk=`expr $disk : '\(.*[a-z]\)'` && dr=$(cat /proc/diskstats | grep " ${disk} " | awk '{ print $6 }')
    drtime=$(cat /proc/diskstats | grep " $disk " | awk '{ print $7 }')
    lastdrtime=`dbquery "$rpath/../sysdata" "select drtime from $disk where timeindex='$lasttimeindex'"`
    [ -z "$lastdrtime" ] && lastdrtime=$drtime
    
    drratio=`solve 2 "($drtime - $lastdrtime) / ($diffsec * 1000)"`

    replinerd=`printf "$LINE read:"`
    m=`expr length "$LINE"`
    l=`expr 22 - $m`
    for ((n=1; n <= $l; n++)); do replinerd=`printf "$replinerd "`; done
    replinerd=`printf "${replinerd}${drratio}"`

    # writing stats
    dw=$(cat /proc/diskstats | grep " $disk " | awk '{ print $10 }')
    dwtime=$(cat /proc/diskstats | grep " $disk " | awk '{ print $11 }')
    lastdwtime=`dbquery "$rpath/../sysdata" "select dwtime from $disk where timeindex='$lasttimeindex'"`
    [ -z "$lastdwtime" ] && lastdwtime=$dwtime
    
    dwratio=`solve 2 "($dwtime - $lastdwtime) / ($diffsec * 1000)"`

    replinerw=`printf "$LINE write:"`
    m=`expr length "$LINE"`
    l=`expr 21 - $m`
    for ((n=1; n <= $l; n++)); do replinerw=`printf "$replinerw "`; done
    replinerw=`printf "${replinerw}${dwratio}"`

    [ -n "$dr" ] || dr=0
    diskreads=`solve 2 "($dr / 2048)"`
    diskreadslast=`dbquery "$rpath/../sysdata" "select diskreads from '$disk' where timeindex='$lasttimeindex'"`
    [ -n "$diskreadslast" ] || diskreadslast=$diskreads
    drspeed=`solve 2 "($diskreads - $diskreadslast) / $diffsec"`
    m=`expr length "$replinerd"`
    l=`expr 60 - $m`
    for ((n=1; n <= $l; n++)); do replinerd=`printf "$replinerd "`; done
    replinerd=`printf "${replinerd}${drspeed}\n"`
    [ -n "$dw" ] || dw=0
    diskwrites=`solve 2 "($dw / 2048)"`
    diskwriteslast=`dbquery "$rpath/../sysdata" "select diskwrites from '$disk' where timeindex='$lasttimeindex'"`
    [ -n "$diskwriteslast" ] || diskwriteslast=$diskwrites
    dwspeed=`solve 2 "($diskwrites - $diskwriteslast) / $diffsec"`
    m=`expr length "$replinerw"`
    l=`expr 60 - $m`
    for ((n=1; n <= $l; n++)); do replinerw=`printf "$replinerw "`; done
    replinerw=`printf "${replinerw}${dwspeed}\n"`
    
    if [ "_$1" == "_SQL" ]; then
      dbquery "$rpath/../sysdata" "update $disk set diskusage='$used', diskreads='$diskreads', drtime='$drtime', drspeed='$drspeed', diskwrites='$diskwrites', dwtime='$dwtime', dwspeed='$dwspeed' where timeindex='$timeindexnow'"
    fi
    echo "$replinerd"
    echo "$replinerw"
  done
fi

echo
cat $M_TEMP/disk.tmp.discovered 2>/dev/null

rm -f $M_TEMP/disk.tmp* $M_TEMP/diskusage $M_TEMP/diskusage.i >/dev/null 2>&1

