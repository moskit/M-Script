#!/bin/bash

[ -n "`expr "${BASH_SOURCE[0]}" : '\(\/\)'`" ] && rpath="${BASH_SOURCE[0]}" || rpath="./${BASH_SOURCE[0]}"
while [ -h "$rpath" ] ; do rpath=`readlink "$rpath"` ; done
rcommand=${rpath##*/}
rpath="$(cd -P "${rpath%/*}" && pwd)"
#*/
echo "Running ${rpath}/${rcommand}" >> "${rpath}/../../sa.log"

a=`cat "${rpath}/mongo_config_servers.list" 2>/dev/null | wc -l`
[[ $a -eq 0 ]] && a=1
b=`expr \( $RANDOM / $a \) + 1`
confserver=`head -n $b "${rpath}/mongo_config_servers.list" 2>/dev/null | tail -1`
[ -z "$confserver" ] && echo "No configuration servers found" && exit 1

masters=`a=0 ; mongo "$confserver"/config --quiet --eval "db.databases.find( { "partitioned" : true }, { "primary" : 1 } ).forEach(printjson)" | "${rpath}"/../../lib/json2txt | while read LINE ; do i=${LINE%%/*} ; if [[ "$i" == "$a" ]] ; then echo -n -e "|${LINE##*|}" ; else echo -n -e "\n${LINE##*|}" ; a=$i ; fi  ; done ; echo ; unset a`

sharded=`mongo "$confserver"/config --quiet --eval "db.collections.find( {}, { _id : 1 } ).forEach(printjson)" | "${rpath}"/../../lib/json2txt | cut -d'|' -f2`

echo "Sharded collections"
echo "-------------------"
echo
for coll in $sharded ; do
  echo "$coll"
  echo "-------------------"
  echo
  echo " Shard            Chunk: from ID                to ID"
  currshard=`mongo "$confserver"/config --quiet --eval "db.chunks.find( { ns : \"${coll}\" } ).sort({_id:-1}).limit(1).forEach(printjson)" | "${rpath}"/../../lib/json2txt | grep ^[0-9]*\/shard | cut -d'|' -f2`
  echo "$coll current shard: $currshard"
  database=${coll%%.*}
  mastershard=`echo $masters | grep ^$database\| | cut -d'|' -f2`
  oneforbackup=`mongo "$confserver"/config --quiet --eval "db.chunks.find( { ns : \"$coll\", shard : \\$and : [ { \\$ne : \"$currshard\" }, { \\$ne : \"$mastershard\" } ] }, { shard : 1, min : 1, max : 1, _id : 0 } ).sort({_id:-1}).limit(1).forEach(printjson)" | "${rpath}"/../../lib/json2txt`
  chkshard=`echo "$oneforbackup" | grep ^[0-9]*\/shard | cut -d'|' -f2`
  chkidmin=`echo "$oneforbackup" | grep ^[0-9]*\/min | cut -d'|' -f2`
  chkidmax=`echo "$oneforbackup" | grep ^[0-9]*\/max | cut -d'|' -f2`
  chkidmin=${chkidmin#*\"}
  chkidmin=${chkidmin%\"*}
  chkidmax=${chkidmax#*\"}
  chkidmax=${chkidmax%\"*}
  echo "$chkshard   $chkidmin   $chkidmax"
done


### Get the shard (and chunk?) currently being written to
#currshard1=`mongo "$confserver"/config --quiet --eval "db.chunks.find( { ns : \"${coll}\" } ).sort({_id:-1}).limit(1).forEach(printjson)" | "${rpath}"/../../lib/json2txt | grep ^[0-9]*\/shard | cut -d'|' -f2`

# the last split shard and the server it has been splitted on:
#lastsplit=`mongo "$confserver"/config --quiet --eval "db.changelog.find({what:\"split\", ns:\"${coll}\"}, { server:1, _id:0, \"details.right.min._id\":1 }).sort({time:-1}).limit(1).forEach(printjson)" | "${rpath}"/../../lib/json2txt | cut -d'|' -f2`
#lastsplitserver=`echo $lastsplit | head -1`
#lastsplitchunk=`echo $lastsplit | tail -1 | cut -d'"' -f2`
# chunk could be moved after split:
#chunkmovedto=`mongo "$confserver"/config --quiet --eval "db.changelog.find({\"details.min._id\":ObjectId(\"$lastsplitchunk\"), what:\"moveChunk.start\"},{\"details.to\":1, _id:0}).sort({time:1}).forEach(printjson)" | "${rpath}"/../../lib/json2txt | cut -d'|' -f2`
#if [ -n "$chunkmovedto" ] ; then
#  currshard2=$chunkmovedto
#else
#  currshard2=`mongo "$confserver"/config --quiet --eval "db."`
#fi

#depth=5

### Find the latest of chunks located neither on the current shard nor on the primary shard
#possible=`mongo $confserver/config --quiet --eval "db.chunks.find( { ns : \"${coll}\", shard : { \\$ne : \"$currshard\" }}, { shard : 1, min : 1, max : 1, _id : 0 } ).sort({_id:-1}).limit($depth).forEach(printjson)" | "${rpath}"/../../lib/json2txt`

### Check if it is backuped already
#for n in `echo "$possible" | cut -d'/' -f1 | sort | uniq` ; do

#done

unset masters
