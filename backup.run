#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

    
rpath=$(readlink -f "$BASH_SOURCE")
rcommand=${rpath##*/}
rpath=${rpath%/*}
#*/
rm -f $stdinto
source "$rpath/m.rc"

[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath")

splitfile() {
  if [ -n "$split_size" ]; then
    split -b $split_size -d $1 $1 2>>$M_TEMP/$archname.$linetoname.tar.log 1>>$stdinto
    rm -f ${localbackuppath}/$archname.$linetoname.tar.bz2
  fi
}

for s_option in $@
do
  case $s_option in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo 'Error: wrong syntax in ${s_option}' >> $stderrto
    exit 1
    ;;
  *)
    s_param="$s_option"
    s_optname=''
    s_optarg=''
    ;;
  esac
  case $s_optname in
  from-remote | to-remote)
    xferdirection=$s_optname
    case $s_optarg in
    ftp)	r_proto='ftp' ;;
    scp) 	r_proto='scp' ;;
    rsync)	r_proto='rsync' ;;
    s3) r_proto='s3' ;;
    help | *)
      cat <<"EOF"
  Files transfer method.
  Usage: --from-remote=method or --to-remote=method
  Supported methods are:
  ftp scp rsync s3
EOF
      exit 0
    ;;
    esac
  ;;
  to-local)
    xferdirection=$s_optname
    case $s_optarg in
    cp)	r_proto='cp' ;;
    rsync)	r_proto='rsync' ;;
    help | *)
      cat <<"EOF"
  Files transfer method.
  Usage: --from-remote=method or --to-remote=method
  Supported methods are:
  cp rsync
EOF
      exit 0
    ;;
    esac
  ;;
  only-pickup|no-tar|notar|no-archive)
    nonbackup='yes'
    onlypickup='yes'
    if [ X$s_optarg == 'Xhelp' ]; then
      cat <<"EOF"
    This option makes the program skip the backup creation part and only pick up
  files and transfer them to (from) another location.
    This option doesn't make sense without --to-remote or --from-remote
  option.
  Usage: --only-pickup or --only-pickup=yes or --only-pickup=/path/to/files,
  where /path/to/files overwrites the default, which is localbackuppath/backup.tmp
  (see conf/backup.conf)
EOF
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      if [ ! -e $s_optarg ]; then
        echo "Path $s_optarg doesn't exist!" | tee -a $stderrto
        echo "Check if it exists or use --only-pickup=help to get more help." | tee -a $stderrto
        exit 1
      else
        pickuppath=$s_optarg
      fi
    fi
  ;;
  only-cleanup|only-clean)
    nonbackup='yes'
    onlyclean='yes'
    if [ "X$s_optarg" == "Xhelp" ]; then
      cat <<"EOF"
    This option is useful for cleaning up disk space. It only removes
  outdated backups, if finds any. 
  It also can be used for cleaning any folders from old files, e.g. backup
  folders, created by another backup script.
  Usage: --only-clean or --only-clean=yes
EOF
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      echo 'Wrong syntax! Use --only-clean=help to get more help' | tee -a $stderrto
      exit 1
    fi
  ;;
  config|configfile|configfiles)
    if [ "X$s_optarg" == "Xhelp" ]; then
      cat <<"EOF"
    You can create as many backup configuration files as you want and backup
  files from or to many hosts at once. But you cannot do all backups in 
  a single run if you use both transfer directions, i.e. --from-remote
  for some hosts and --to-remote for others. Also you may wish to run 
  this program with, for example, --only-clean option for particular hosts.

  Syntax is:
  backup.run --configfiles=file1,file2,file3,...
  All other configuration files will be ignored.

    Note that this option also allows to use any config files names. Without
  this option backup will use only config files that have names like
  backup.*.conf. This option allows having both "usual" and
  "special" config files, so you can create backup.*.conf
  configuration files for most common use and "special"
  configuration files for non-common tasks.
EOF
      exit 0
    elif [ "X$s_optarg" == "X" ] || [ "X$s_optarg" == "Xyes" ]; then
      echo 'Wrong syntax! Use --configfiles=help to get more help' >> $stderrto
      exit 1
    fi
    configfiles=( `echo $s_optarg|sed 's|,| |g'` )
  ;;
  replace|incremental|incr)
    replaceflag=1
  ;;
  debug|verbose|v)
    debugflag=1
    export debugflag
  ;;
  fg|foreground)
    fgflag='yes'
    if [ "X$s_optarg" == "Xhelp" ]; then
      cat <<"EOF"
    This option makes all output go to stdin and is useful for debugging.
    
    Usage: --fg or --fg=yes
    
EOF
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      echo 'Wrong syntax! Use --fg=help to get more help' | tee -a $stderrto
      exit 1
    fi
  ;;
  help|*)
    cat <<"EOF"
  Possible options:
  --from-remote=method or --to-remote=method (use help instead of a method
  to see methods available)
  --only-pickup (use --only-pickup=help to get more help)
  --only-clean (use --only-clean=help to get more help)
  --configfiles (use --configfiles=help to get more help)
  --replace (replaces the previous backup; makes incremental backup when
    used with the rsync method)
  --verbose (increases logs verbosity)
EOF
    exit 0
  ;;
  esac
done

stdinto="$rpath/m_backup.log"
stderrto="$rpath/m_error.log"

if [ -n "$debugflag" ]
then
  echo -e "OPTIONS:\nxferdirection = $xferdirection\nr_proto = $r_proto\nnonbackup = $nonbackup\nonlypickup = $onlypickup\nonlyclean = $onlyclean\nconfigfiles = ${configfiles[*]}\nreplaceflag = $replaceflag\n" >> $stdinto
  dbginto=$stdinto
else
  dbginto="/dev/null"
fi

touch $stdinto $stderrto
if [ -n "$fgflag" ]; then
  tail -f $stdinto $stderrto &
  echo $! > "$M_TEMP/backup.fg.pid"
fi
export stdinto stderrto

RSYNC_RSH_BK=$RSYNC_RSH

###################################################################
# Main loop. Runs as many times as many config files used  #
###################################################################

source $M_ROOT/conf/mon.conf
M_TEMP=$M_TEMP/backups
[ -d "$M_TEMP" ] && install -d "$M_TEMP"
export M_TEMP
declare -i res

localbackuppath=$rpath
install -d "$M_TEMP" 2>$stderrto
# If config files collection is not set by option, we use all files having names
# like backup*.conf from the conf folder
if [ -z "${configfiles[*]}" ]
then
  configfiles=( )
  for conf in "$M_ROOT"/conf/backup*.conf
  do
    configfiles+=("$conf")
  done
  echo "configfiles options is not set, using default files: ${configfiles[*]}" >> $stdinto
fi
#### lets go
for backupconf in ${configfiles[*]}
do
  bconf=${backupconf##*/}
  backupconf="$M_ROOT/conf/$bconf"
  [ -f "$backupconf" ] || continue
  source "$backupconf"

  if [ "$r_proto" == "ftp" ]
  then
    ftpput=`which ncftpput 2>/dev/null`
    ftpget=`which ncftpget 2>/dev/null`
    if [ "X$ftpput" == "X" ]
    then
      echo 'To use FTP uploads please install NcFTP client' >> $stderrto
      exit 1
    fi
  fi
  if [ "$r_proto" == "scp" ]
  then
    SCP="`which scp 2>/dev/null` -r -q"
    if [ "X$SCP" == "X" ]
    then
      echo "No scp command found! Is OpenSSH installed?" >> $stderrto
      exit 1
    else
      echo "SCP command is $SCP" >> $stdinto
    fi
  fi
  if [ "$r_proto" == "rsync" ]
  then
    RSYNC="`which rsync 2>/dev/null`"
    if [ "X$RSYNC" == "X" ]
    then
      echo 'No rsync command found!' >> $stderrto
      exit 1
    else
      echo "RSYNC command is $RSYNC" >> $stdinto
    fi
  fi
  if [ "$r_proto" == "s3" ]
  then
    S3="`which s3cmd 2>/dev/null`"
    if [ "X${S3}" == "X" ]
    then
      echo 'No s3cmd command found!' >> $stderrto
      exit 1
    else
      echo "S3 command is $S3" >> $stdinto
    fi
  fi

  [ -z "$remoteuser" ] && remoteuser=$USER
  
  locallogpath=$localbackuppath
  if [ "X$onlyclean" == "Xyes" ]; then
    localrmpath="$localbackuppath"
    [ "X${0%/*}" == "X$localrmpath" ] && localrmpath="$localbackuppath/backup.local"
  else
    localrmpath="$localbackuppath/backup.local"
  fi
  [ -n "$debugflag" ] && echo -e "localbackuppath = $localbackuppath\nSET locallogpath = $locallogpath\nSET localrmpath = $localrmpath\n" >> $dbginto

  echo "Using configuration file ${backupconf}..." >> $stdinto
  if [ -z "$remotehost" ]; then
    [ "X$xferdirection" != "Xto-local" ] && echo "Backup is set to be $xferdirection but remote host is not set" >> $stderrto && exit 1
  fi
  ARCOPTS=""
  
  [ "X$followlinks" != "Xyes" ] || ARCOPTS="$ARCOPTS -h"
  [ "X$numericids" != "Xyes" ] || ARCOPTS="$ARCOPTS --numeric-owner"
  [ "X$preserveperm" != "Xyes" ] || ARCOPTS="$ARCOPTS -p"
  [ "X$samefs" != "Xyes" ] || ARCOPTS="$ARCOPTS --one-file-system"
  [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && ARCOPTS="$ARCOPTS -v" && echo "TAR options are: $ARCOPTS" >> $dbginto
  
  if [ -z "$nonbackup" -a -z "$onlyclean" ]; then
    install -d "$localbackuppath/backup.local"
    install -d "$localbackuppath/backup.tmp"
  fi
  install -d "${locallogpath}/logs"

  if [ -f "$M_ROOT/conf/${backupconf}.exclude" ]; then
    echo "Excluding files matching patterns from $rpath/${backupconf}.exclude" >> $stdinto
    ARCOPTS="$ARCOPTS --totals -X $M_ROOT/conf/${backupconf}.exclude"
  else
    ARCOPTS="$ARCOPTS --totals"
  fi
  if [ "$xferdirection" != "from-remote" ]
  then
  # if pickuppath is not defined (might be defined as command-line option),
  # the reasonable default is the place where the last backups are located
    if [ -n "$pickuppath" ]; then
      localbackuppath=$pickuppath
    else
      localbackuppath=$localbackuppath/backup.tmp
    fi
  fi
  if [ "$xferdirection" == "from-remote" ]; then
    if [ -n "$pickuppath" ]; then
      remotebackuppath=$pickuppath
    else
      remotebackuppath=$remotebackuppath/backup.tmp
    fi
  fi
  
  if [ -n "$debugflag" ]; then
    echo "SET localbackuppath = $localbackuppath" >> $dbginto
    [ -n "$remotebackuppath" ] && echo "SET remotebackuppath = $remotebackuppath" >> $dbginto
  fi
  if [ -z "$xferdirection" ]; then
    if [ -z "$nonbackup" ]; then
      echo -e "No options set, doing nothing.\nUse option --help to get help."
    fi
  fi

###################################
# Archiving files and dumping dbs #
###################################

  if [ -z "$nonbackup" ]; then
# Removing tmp files created during the previous run
    [ -d "$localbackuppath" ] && rm -rf "$localbackuppath"/*  #*/
    if [ -z "$replaceflag" ] || [ ! -f ${rpath}/lastbackup.${bconf}.archname ]; then
      archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
      echo "$archname" > "$rpath/lastbackup.${bconf}.archname"
    else
      archname=`cat "$rpath/lastbackup.${bconf}.archname"`
    fi
    [ -n "$debugflag" ] && echo "SET archname = $archname" >> $dbginto
# Saving folders from backup.sources.list
    if [ -f "${backupconf}.list" ] ; then
      while read LINE
      do
        if [ -n "$LINE" ]; then
          linetoname=`echo "$LINE" | sed 's|/|_|g'`
          if [ "X$compression" == "Xgzip" ]; then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar.gz" >> $dbginto
            tar $ARCOPTS -c -z -f "$localbackuppath/$archname.$linetoname.tar.gz" "$LINE" 2>"$M_TEMP/$archname.$linetoname.tar.log" 1>>$stdinto
            splitfile ${localbackuppath}/$archname.$linetoname.tar.gz
          fi
          if [ "X$compression" == "Xbzip2" ]
          then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar.bz2" >> $dbginto
            tar $ARCOPTS -c -j -f "$localbackuppath/$archname.$linetoname.tar.bz2" "$LINE" 2>"$M_TEMP/$archname.$linetoname.tar.log" 1>>$stdinto
            splitfile "$localbackuppath/$archname.$linetoname.tar.bz2"
          fi
          if [ "X$compression" == "X" ]
          then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar" >> $dbginto
          	tar $ARCOPTS -c -f "$localbackuppath/$archname.$linetoname.tar" "$LINE" 2>"$M_TEMP/$archname.$linetoname.tar.log" 1>>$stdinto
            splitfile "$localbackuppath/$archname.$linetoname.tar"
          fi
          
          if [ -f "$M_TEMP/$archname.$linetoname.tar.log" ]; then
            tarerr=$(grep '^tar:' "$M_TEMP/$archname.$linetoname.tar.log" | grep -v 'Removing leading' | grep -v 'as we read')
            [ -n "$tarerr" ] && echo "$tarerr" >> $stderrto
            echo "Tar: ${LINE} copied with some errors, see $locallogpath/logs/m_backup.error" >> $stdinto
            echo "Tar: $LINE copied `grep '^Total bytes written:' "$M_TEMP/$archname.$linetoname.tar.log" | cut -d' ' -f5,6`" >>$stdinto
          else
            echo "Tar: $LINE copied successfully `grep '^Total bytes written:' "$M_TEMP/$archname.$linetoname.tar.log" | cut -d' ' -f5,6`" >>$stdinto 2>/dev/null
            rm -f "$M_TEMP/$archname.$linetoname.tar.log"
          fi
        fi
      done < "${backupconf}.list"
    fi
    #rm -f $M_TEMP/${archname}.${linetoname}.tar.log
# Backuping databases (see the correspondent database backup scripts for details
    for DB in $databases
    do
      [ -x "$rpath"/${DB}.backup.sh ] && "$rpath"/${DB}.backup.sh "$backupconf" "$archname" 1>>$stdinto 2>>$stderrto
    done
  else
    archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
    [ -n "$debugflag" ] && echo "SET archname = $archname" >> $dbginto
  fi   
# --- ending non-backup condition inverted


###############################
# Local backup                #
###############################

  if [ "$xferdirection" == "to-local" ]
  then
    case $r_proto in 
    cp)
      [ "X$followlinks" != "Xyes" ] && CPOPTS="$CPOPTS -d" || CPOPTS="$CPOPTS -L"
      [ "X$preserveperm" != "Xyes" ] || CPOPTS="$CPOPTS --preserve=all"
      [ "X$samefs" != "Xyes" ] || CPOPTS="$CPOPTS --one-file-system"
      [ -n "$replaceflag" ] && CPOPTS="$CPOPTS --update"
      CPOPTS="$cpoptions $CPOPTS -r"
      if [ -n "$remotepath" ]; then
        if [ `echo "$remotepath" | cut -b1` != '/' ]; then
          remotepath="/var/m_backup/$remotepath"
        fi
      else
        remotepath="/var/m_backup"
      fi
      [ -d "$remotepath" ] || install -d "$remotepath"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && CPOPTS="${CPOPTS} -v" && echo "CP options are: $CPOPTS" >> $dbginto
      ltime=`(time -p cp $CPOPTS "$localbackuppath"/* "$remotepath" 2>"$M_TEMP/$archname.local.log" 1>>$dbginto) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s "$localbackuppath" | cut -f1`
      ltime=`expr $ltime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: cp $CPOPTS -r $localbackuppath\/\* $remotepath\nltime = $ltime\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f "$M_TEMP/$archname.local.log" ] && [ `cat "$M_TEMP/$archname.local.log" | wc -l` -gt 0 ]; then
        cat "$M_TEMP/$archname.local.log" >> $stderrto
        echo -e "CP: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nCP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)\n" >> $stdinto
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.local.log
    ;;
    rsync)
      [ "X$followlinks" == "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -l"
      [ "X$numericids" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS --numeric-owner"
      [ "X$preserveperm" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -Ago"
      [ "X$samefs" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS --safe-links"
      [ "X$bwlimit" != "X" ] && RSYNCOPTS="$SCPOPTS --bwlimit=`expr $bwlimit / 8`"
      [ "X$xfercompression" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -z"
      RSYNCOPTS="$rsyncoptions -rt $RSYNCOPTS"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && RSYNCOPTS="$RSYNCOPTS -v" && echo "Rsync options are: $RSYNCOPTS" >> $dbginto
      rsynctime=`(time -p $RSYNC $RSYNCOPTS "$localbackuppath"/* "$remotepath/" 1>>$dbginto 2>"$M_TEMP/$archname.rsync.log") 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s $localbackuppath | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: $RSYNC $RSYNCOPTS \"$localbackuppath\"/* \"$remotepath/\"\nrsynctime = $rsynctime\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f "$M_TEMP/$archname.rsync.log" ] && [ `cat "$M_TEMP/$archname.rsync.log" | wc -l` -gt 0 ]; then
        cat "$M_TEMP/$archname.rsync.log" >> $stderrto
        echo -e "RSYNC: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nRSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)\n" >> $stdinto
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.rsync.log
    ;;
    *)
      echo "Unknown protocol for local backup: $r_proto" >> $stderrto
    ;;
    esac
  fi
  
###############################
# From local to remote backup #
###############################

  if [ "$xferdirection" == "to-remote" ]
  then

# Starting files transfer
    case $r_proto in 
    ftp)
      [ "X$followlinks" != "Xyes" ] || FTPOPTS="$FTPOPTS"
      [ "X$numericids" != "Xyes" ] || FTPOPTS="$FTPOPTS"
      [ "X$preserveperm" != "Xyes" ] || FTPOPTS="$FTPOPTS"
      [ "X$samefs" != "Xyes" ] || FTPOPTS="$FTPOPTS"
      FTPOPTS="$ftpoptions $FTPOPTS"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && FTPOPTS="$FTPOPTS -d $stdinto" && echo "FTP options are: $FTPOPTS" >> $stdinto
      ftptime=`(time -p $ftpput $FTPOPTS -R -V -u$remoteuser -p$remotepw -m $remotehost $remotepath $localbackuppath/* 2>$M_TEMP/$archname.ftp.log 1>>$dbginto) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s $localbackuppath | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: ${ftpput} ${FTPOPTS} -R -V -u$remoteuser -p$remotepw -m $remotehost $remotepath $localbackuppath\/\*\nftptime = $ftptime\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f $M_TEMP/$archname.ftp.log ] && [ `cat $M_TEMP/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]; then
        cat $M_TEMP/$archname.ftp.log >> $stderrto
        echo -e "FTP: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nFTP: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)\n" >> $stdinto
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.ftp.log
    ;;
    scp)
      [ "X$followlinks" != "Xyes" ] || SCPOPTS="$SCPOPTS"
      [ "X$numericids" != "Xyes" ] || SCPOPTS="$SCPOPTS"
      [ "X$preserveperm" != "Xyes" ] || SCPOPTS="$SCPOPTS -p"
      [ "X$samefs" != "Xyes" ] || SCPOPTS="$SCPOPTS"
      [ "X$bwlimit" != "X" ] && SCPOPTS="$SCPOPTS -l $bwlimit"
      [ "X$xfercompression" != "Xyes" ] || SCPOPTS="$SCPOPTS -C"
      SCPOPTS="$scpoptions $SCPOPTS"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && SCPOPTS="$SCPOPTS -v" && echo "SCP options are: $SCPOPTS" >> $dbginto
      scptime=`(time -p $SCP $SCPOPTS "$localbackuppath"/* "$remoteuser"@"${remotehost}:${remotepath}" 2>"$M_TEMP/$archname.scp.log" 1>>$dbginto) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s $localbackuppath | cut -f1`
      scptime=`expr $scptime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: $SCP $SCPOPTS $localbackuppath/* $remoteuser@${remotehost}:${remotepath}\nscptime = $scptime\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f "$M_TEMP/$archname.scp.log" ] && [ `cat "$M_TEMP/$archname.scp.log" | wc -l` -gt 0 ]; then
        cat "$M_TEMP/$archname.scp.log" >> $stderrto
        echo -e "SCP: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nSCP: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)\n" >> $stdinto
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> $stdinto
      fi
      rm -f "$M_TEMP/$archname.scp.log"
    ;;
    rsync)
      [ "X$followlinks" == "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -l"
      [ "X$numericids" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS --numeric-owner"
      [ "X$preserveperm" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -Ago"
      [ "X$samefs" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS --safe-links"
      [ "X$bwlimit" != "X" ] && RSYNCOPTS="$SCPOPTS --bwlimit=`expr $bwlimit / 8`"
      [ "X$xfercompression" != "Xyes" ] || RSYNCOPTS="$RSYNCOPTS -z"
      RSYNCOPTS="$rsyncoptions -rt $RSYNCOPTS"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && RSYNCOPTS="$RSYNCOPTS -v" && echo "Rsync options are: $RSYNCOPTS" >> $dbginto
      rsynctime=`(time -p $RSYNC $RSYNCOPTS "$localbackuppath"/* -e "ssh -l $remoteuser" "$remoteuser"@"${remotehost}:${remotepath}" 1>>$dbginto 2>"$M_TEMP/$archname.rsync.log") 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s "$localbackuppath" | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: $RSYNC $RSYNCOPTS $localbackuppath/* -e \"ssh -l $remoteuser\" \"$remoteuser\"@\"${remotehost}:${remotepath}\"\nrsynctime = $rsynctime\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f "$M_TEMP/$archname.rsync.log" ] && [ `cat "$M_TEMP/$archname.rsync.log" | wc -l` -gt 0 ]; then
        cat "$M_TEMP/$archname.rsync.log" >> $stderrto
        echo -e "RSYNC: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nRSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)\n" >> $stdinto
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> $stdinto
      fi
      rm -f "$M_TEMP/$archname.rsync.log"
    ;;
    s3)
      [ "X$followlinks" != "Xyes" ] || S3OPTS="$S3OPTS"
      [ "X$numericids" != "Xyes" ] || S3OPTS="$S3OPTS"
      [ "X$preserveperm" != "Xyes" ] && S3OPTS="$S3OPTS --no-preserve"
      [ "X$samefs" != "Xyes" ] || S3OPTS="$S3OPTS"
      [ "X$bwlimit" != "X" ] && S3OPTS="$S3OPTS"
      [ "X$xfercompression" != "Xyes" ] || S3OPTS="$S3OPTS"
      S3OPTS="$s3options $S3OPTS"
      remotepath=${remotepath#/}
      s3target="s3://`echo "${remotehost%/}/${remotepath%/}/" | sed 's|s3://||;s|//|/|g'`"
      [ -n "$debugflag" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && S3OPTS="$S3OPTS -v" && echo "S3 options are: $S3OPTS" >> $dbginto
      s3time=`(time -p $S3 $S3OPTS sync $localbackuppath/ "$s3target" 2>$M_TEMP/$archname.s3.log 1>>$dbginto) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`
      arcsize=`du -k -s $localbackuppath | cut -f1`
      s3time=`expr $s3time + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: $S3 $S3OPTS sync $localbackuppath/ $s3target\ns3time = $s3time\narcsize = $arcsize\n" >> $dbginto
      fi
      if [ -f $M_TEMP/$archname.s3.log ] && [ `cat $M_TEMP/$archname.s3.log | wc -l` -gt 0 ]; then
        cat $M_TEMP/$archname.s3.log >> $stderrto
        echo -e "S3: There were errors while transferring files, see $locallogpath/logs/m_backup.error\nS3: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)\n" >> $stdinto
      else
        echo "S3: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.s3.log
    ;;
    *)
      echo "Unknown protocol for to-remote backup: $r_proto" >> $stderrto
    ;;
    esac
  fi
  
###############################
# From remote to local backup #
###############################

  if [ "$xferdirection" == "from-remote" ]
  then
    # If we want remote operations
    if [ "X$onlypickup" != "Xyes" ]
    then
      # we need SSH client to be present then
      SSH=`which ssh`
      if [ "X$SSH" == "X" ]
      then
        echo "No SSH client found! Consider using --only-pickup option"
        exit 1
      fi
      echo "install -d ${remotepath}/backup.local && install -d ${remotepath}/backup.tmp && install -d $M_TEMP" > ${rpath}/remote.backup.sh
      if [ "X$replaceflag" == "X" ]; then
        echo -e 'archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"\necho "${archname}" > ${rpath}/lastbackup.${bconf}.archname\narchname=`cat ${rpath}/lastbackup.${bconf}.archname`' >> ${rpath}/remote.backup.sh
      fi
      echo 'ARCOPTS="'${ARCOPTS}'"' >> ${rpath}/remote.backup.sh
      echo -e "compression=${compression}\nremotepath=${remotepath}\nkeepremote=${keepremote}\nremoveoldremote=${removeoldremote}\nkeepremotedays=${keepremotedays}\nremotebackuppath=${remotebackuppath}\ndatabases=${databases}\ncd ${remotepath}" >> ${rpath}/remote.backup.sh
      echo 'rm -f ${remotepath}/*.tar*' >> ${rpath}/remote.backup.sh
      for DB in ${databases}
      do
        echo 'rm -f ${remotepath}/${DB}/*.tar*' >> ${rpath}/remote.backup.sh
      done
      if [ -f "${rpath}/${backupconf}.list" ]; then
        while read LINE ; do
          if [ -n "${LINE}" ]; then
            echo "LINE=${LINE}" >> ${rpath}/remote.backup.sh
            linetoname=`echo ${LINE} | sed 's|/|_|g'`
            echo "linetoname=${linetoname}" >> ${rpath}/remote.backup.sh
            if [ "X${compression}" == "Xgzip" ]; then
              echo 'tar ${ARCOPTS} -c -z -f ${remotepath}/$archname.$linetoname.tar.gz ${LINE} 2>$M_TEMP/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
            fi
            if [ "X${compression}" == "Xbzip2" ]; then
              echo 'tar ${ARCOPTS} -c -j -f ${remotepath}/$archname.$linetoname.tar.bz2 ${LINE} 2>$M_TEMP/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
            fi
            cat >> ${rpath}/remote.backup.sh <<"EOF"
  if [ -f $M_TEMP/$archname.$linetoname.tar.log ]; then
    tarerr=$(grep '^tar:' $M_TEMP/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read')
    [ -n "$tarerr" ] && echo "$tarerr" >> "${remotepath}/m_backup.error"
    echo "Tar: ${LINE} copied with some errors, see ${localbackuppath}/logs/m_backup.error" >> ${remotepath}/m_backup.log
    echo "Tar: ${LINE} copied `grep '^Total bytes written:' $M_TEMP/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${remotepath}/m_backup.log
  else
    echo "Tar: ${LINE} copied successfully `grep '^Total bytes written:' $M_TEMP/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>"${remotepath}/m_backup.log" 2>/dev/null
    rm -f $M_TEMP/$archname.$linetoname.tar.log
  fi
  if [ X$keepremote == "Xyes" ]; then
    cp -r ${remotepath}/* ${remotepath}/backup.local 2>>${remotepath}/m_backup.error
  fi
  if [ "X$removeoldremote" == "Xyes" ]; then
    find ${remotepath}/backup.local -mtime +$keepremotedays | xargs rm -f
  fi
  echo ${archname} > ${remotepath}/m_backup.archname
EOF
          fi
        done < "${rpath}/${backupconf}.list"
      fi
      cat >> ${rpath}/remote.backup.sh <<"EOF"
for DB in ${databases} ; do
  [ -x ${remotepath}/${DB}.backup.sh ] && ${remotepath}/${DB}.backup.sh ${remotepath}/remote.${DB}.conf'
done
EOF
      echo "localbackuppath=${remotepath}" > ${rpath}/remote.${DB}.conf
      for DB in ${databases} ; do
        ${SCP} -q ${rpath}/${DB}.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/${DB}.backup.sh"
        ${SCP} -q ${rpath}/remote.${DB}.conf "${remoteuser}"@"${remotehost}:${remotepath}/remote.${DB}.conf"
      done
      ${SCP} -q ${rpath}/remote.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/remote.backup.sh"
      ${SSH} "${remoteuser}"@"${remotehost}" "bash ${remotepath}/remote.backup.sh && rm -f ${remotepath}/remote.backup.sh"
    fi
    case $r_proto in 
    ftp)
      ${ftpget} -V -u${remoteuser} -p${remotepw} ${remotehost} ${rpath}/ ${remotepath}/m_backup.*
      archname=`cat ${rpath}/m_backup.archname`
      ftptime=`(time -p ${ftpget} -R -V -u${remoteuser} -p${remotepw} ${remotehost} ${localbackuppath}/backup.tmp ${remotepath}/* 2>$M_TEMP/$archname.$linetoname.ftp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ -f $M_TEMP/$archname.$linetoname.ftp.log ] && [ `cat $M_TEMP/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]
      then
        cat $M_TEMP/$archname.$linetoname.ftp.log >> $stderrto
        echo "FTP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> $stdinto
        echo "FTP: Files transferred (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> $stdinto
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.$linetoname.ftp.log
    ;;
    scp)
      ${SCP} -q "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      scptime=`(time -p ${SCP} -q -r "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>$M_TEMP/$archname.$linetoname.scp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      scptime=`expr $scptime + 1`
      if [ -f $M_TEMP/$archname.$linetoname.scp.log ] && [ `cat $M_TEMP/$archname.$linetoname.scp.log | wc -l` -gt 0 ]
      then
        cat $M_TEMP/$archname.$linetoname.scp.log >> $stderrto
        echo "SCP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> $stdinto
        echo "SCP: Files transferred (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> $stdinto
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.$linetoname.scp.log
    ;;
    rsync)
      ${RSYNC} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      rsynctime=`(time -p ${RSYNC} -r -e "ssh -l ${remoteuser}" "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>$M_TEMP/$archname.$linetoname.rsync.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -f $M_TEMP/$archname.$linetoname.rsync.log ] && [ `cat $M_TEMP/$archname.$linetoname.rsync.log | wc -l` -gt 0 ]
      then
        cat $M_TEMP/$archname.$linetoname.rsync.log >> $stderrto
        echo "RSYNC: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> $stdinto
        echo "RSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> $stdinto
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.$linetoname.rsync.log
    ;;
    local)
      ${SCP} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      ltime=`(time -p ${SSH} "${remoteuser}"@"${remotehost}" "cp -r ${remotepath}/* ${remotebackuppath}/backup.tmp 2>$M_TEMP/$archname.$linetoname.local.log") 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ltime=`expr $rsynctime + 1`
      if [ -f $M_TEMP/$archname.$linetoname.local.log ] && [ `cat $M_TEMP/$archname.$linetoname.local.log | wc -l` -gt 0 ]
      then
        cat $M_TEMP/$archname.$linetoname.local.log >> $stderrto
        echo "CP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> $stdinto
        echo "CP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> $stdinto
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> $stdinto
      fi
      rm -f $M_TEMP/$archname.$linetoname.local.log
    ;;
    esac
    $SSH "$remoteuser"@"$remotehost" "rm -f $remotepath/m_backup.*"
  fi

# Copying backups to proper location
  if [ "X$keeplocal" == "Xyes" ] && [ "X$nonbackup" == "X" ]
  then
    if [ "X$debugflag" == "X" ]
    then
      cp -r $localbackuppath/* $localbackuppath/../backup.local 2>>$stderrto #*/
    else
      echo "Copying backups to proper (local) location:" >> $stdinto
      cp -r -v $localbackuppath/* $localbackuppath/../backup.local 2>>$stderrto 1>>$stdinto #*/
    fi
  fi
  
#############################
# Removing outdated backups #
#############################

  if [ "X$removeoldlocal" == "Xyes" ]
  then
    [ $keeplocaldays -gt 0 ] && keeplocaldays=`expr $keeplocaldays - 1`
    [ -n "$debugflag" ] && rmv='-v'
    find ${localrmpath} -mtime +$keeplocaldays -type f -print0 | xargs -0 rm "$rmv" -f 2>>$stderrto >> $stdinto && echo "Outdated backups at ${localrmpath} have been removed" >> $stdinto
  fi
  if [ "$xferdirection" == "to-remote" ]
  then
    if [ "X$removeoldremote" == "Xyes" ] && [ "X$keepremote" == "Xyes" ] && [ -n "${remotehost}" ]; then
      case $r_proto in 
      ftp)
        echo "Removing remote files via FTP is not (yet) supported." >>$stderrto
      ;;
      s3)
        remotepath1="${s3target}"
        while true; do
          `which s3cmd` ls "${remotepath1}" > $M_TEMP/s3list.$$
          if [ -n "$debugflag" ]; then
            echo "=== In ${remotepath1} `cat $M_TEMP/s3list.$$|wc -l` objects found" >> $dbginto
          fi
          grep DIR $M_TEMP/s3list.$$ | sed 's|^[[:space:]]*DIR[[:space:]]*||g' >> $M_TEMP/s3dirs.$$
          if [ -n "$debugflag" ]; then
            echo "=== `cat $M_TEMP/s3dirs.$$|wc -l` are directories" >> $dbginto
          fi
          grep -v ^[[:space:]]*DIR[[:space:]]* $M_TEMP/s3list.$$ >> $M_TEMP/s3files.$$
          if [ -n "$debugflag" ]; then
            echo "=== `cat $M_TEMP/s3files.$$|wc -l` are files" >> $dbginto
          fi
          for ((i=0; i < $keepremotedays; i++)); do
            d2k=$(date -d "`date +"%Y/%m/%d"` - $i days" +"%Y-%m-%d")
            sed -i -e "/$d2k/d" $M_TEMP/s3files.$$
          done
          if [ -n "$debugflag" ]; then
            echo "=== `cat $M_TEMP/s3files.$$|wc -l` files have been marked for removal" >> $dbginto
          fi
          for s3file in `cat $M_TEMP/s3files.$$ | awk -F's3://' '{print $2}'`; do
            `which s3cmd` del "s3://${s3file}" 2>>$stderrto 1>>$stdinto
          done
          if [ `cat $M_TEMP/s3dirs.$$ | grep -v ^$ | wc -l` -gt 0 ]; then
            remotepath1="`head -1 $M_TEMP/s3dirs.$$`"
            sed -i -e '1d' $M_TEMP/s3dirs.$$ 2>>$stderrto 1>>$stdinto
            if [ -n "$debugflag" ]; then
              echo "=== Entering $remotepath1 directory" >> $dbginto
            fi
            continue
          else
            break
          fi
        done
        rm -f $M_TEMP/s3dirs.$$ $M_TEMP/s3files.$$ $M_TEMP/s3list.$$
      ;;
      *)
        SSH=`which ssh`
    #      echo "if \$xferdirection=$xferdirection \|\| X\$onlyclean=X$onlyclean"
        # For --from-remote removing see line 339
        if [ -z "$SSH" ]; then
          echo "No SSH client found! It is impossible to remove outdated backups on remote hosts." >>$stderrto
          exit 1
        fi
        [ $keepremotedays -gt 0 ] && keepremotedays=`expr $keepremotedays - 1`
        $SSH "$remoteuser"@"$remotehost" "find $remotepath -mtime +$keepremotedays -type f" 2>>$stderrto > "$M_TEMP/remote_files_to_remove.list"
        res=0
        for LINE in `cat "$M_TEMP/remote_files_to_remove.list"`
        do
          [ -n "$debugflag" ] && rmv='-v'
          ${SSH} "${remoteuser}"@"${remotehost}" "rm "$rmv" -f \"${LINE}\"" 2>>$stderrto >> $dbginto
          res+=$?
        done
        if [ $res -eq 0 ]; then
          echo "Outdated backups at ${remotehost}:${remotepath} have been removed" >> $stdinto
        else
          echo "Outdated backups at ${remotehost}:${remotepath} have not been removed" >>$stdinto
        fi
      ;;
      esac
    fi
  fi
  if [ "$xferdirection" == "to-local" ]
  then
    if [ "X$removeoldremote" == "Xyes" ] && [ "X$keepremote" == "Xyes" ]; then
      [ $keepremotedays -gt 0 ] && keepremotedays=`expr $keepremotedays - 1`
      find $remotepath -mtime +$keepremotedays -type f 2>>$stderrto > "$M_TEMP/remote_files_to_remove.list"
      res=0
      for LINE in `cat "$M_TEMP/remote_files_to_remove.list"`
      do
        [ -n "$debugflag" ] && rmv='-v'
        rm "$rmv" -f \"${LINE}\" 2>>$stderrto >> $dbginto
        res+=$?
      done
      if [ $res -eq 0 ]; then
        echo "Outdated backups at ${remotehost}:${remotepath} have been removed" >> $stdinto
      else
        echo "Outdated backups at ${remotehost}:${remotepath} have not been removed" >>$stdinto
      fi
    fi
  fi
  
#########################
# Reporting and logging #
#########################

  echo -e "          Backup operations report\n--------------------------------------------------------------\nDate: `date`\n\n" > ${rpath}/backup.report
  if [ -z "$nonbackup" ]; then
    echo -e "Archive file name pattern: ${archname}\n--------------------------------------------------------------\n\n" >> "$rpath/backup.report"
  fi
  [ -f "$stderrto" ] && cat $stderrto >> "$locallogpath/logs/m_backup.error"
  
  errlog=`grep "\*\*\*" $stderrto`
  if [ -n "$errlog" ]; then
    if [ -n "$debugflag" ]; then
      [ -f "$stderrto" ] && cat $stderrto >> "$rpath/backup.report"
    else
      echo "*** There were errors during this backup:" >> "$rpath/backup.report"
      if [ -f "$stderrto" ]; then
        for command in "cp scp rsync debug mv rm mysql pgsql ncftpput tar s3cmd"
        do
          grep -i -m 3 "^$command" $stderrto >> "$rpath/backup.report"
        done
        echo -e "*** Note that errors shown are limited to 3 errors for every operation\nFull error log is available at $locallogpath/logs/m_backup.error\n" >> "$rpath/backup.report"
      fi
    fi
  fi
  
  echo -e "Operations finished:\n\n" >> "${rpath}/backup.report"

  if [ -n "$debugflag" ]; then
    [ -f "$dbginto" ] && cat $dbginto >> "${rpath}/backup.report"
  else
    [ -f "$stdinto" ] && cat $stdinto >> "${rpath}/backup.report"
  fi
# Send report by email
  while read LINE
  do
    if [ -n "${LINE}" ]; then
      cat "${rpath}/backup.report" | mail -s "Server $(hostname -f) backup report" "${LINE}"
    fi
  done < "$M_ROOT/conf/mail.backup.list"
  
  if [ -n "$errlog" ]; then
    echo "*** `date` ***" >> "${locallogpath}/logs/m_backup.error"
    if [ -z "$nonbackup" ]; then
      echo "*** ${archname} ***" >> "${locallogpath}/logs/m_backup.error"
    fi
    [ -f "$stderrto" ] && cat $stderrto >> "${locallogpath}/logs/m_backup.error"
  fi
  echo "*** `date` ***" >> "${locallogpath}/logs/m_backup.log"
  if [ -z "$nonbackup" ]; then
    echo "*** ${archname} ***" >> "${locallogpath}/logs/m_backup.log"
  fi
  
  [ -f "$stdinto" ] && cat $stdinto >> "${locallogpath}/logs/m_backup.log"
  rm -f ${rpath}/m_backup.{error,log} 2>/dev/null
  rm -f $M_TEMP/$archname*log 2>/dev/null
### Now it's time to restore some environment variables
  export RSYNC_RSH="${RSYNC_RSH_BK}"
done
[ -n "$fgflag" ] && kill `cat "$M_TEMP/backup.fg.pid"`


