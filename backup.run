#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

    
rpath=$(readlink -f "$BASH_SOURCE")
rcommand=${rpath##*/}
rpath=${rpath%/*}
#*/
rm -f "${rpath}/m_backup.log"
source "${rpath}/../m.rc"

[ -z "$M_ROOT" ] && M_ROOT=$(readlink -f "$rpath/../")

splitfile() {
  if [ -n "$split_size" ]; then
    split -b $split_size -d $1 $1 2>>$TMPDIR/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
    rm -f ${localbackuppath}/$archname.$linetoname.tar.bz2
  fi
}

for s_option in $@
do
  case $s_option in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo 'Error: wrong syntax in ${s_option}' >> ${rpath}/m_backup.error
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  case $s_optname in
  from-remote | to-remote)
    xferdirection=$s_optname
    case $s_optarg in
    ftp)	r_proto='ftp' ;;
    scp) 	r_proto='scp' ;;
    rsync)	r_proto='rsync' ;;
    local)  r_proto='local' ;;
    s3) r_proto='s3' ;;
    help | *)
      cat <<"EOF"
  Files transfer method.
  Usage: --from-remote=method or --to-remote=method
  Supported methods are:
  ftp scp rsync s3 local
EOF
      exit 0
    ;;
    esac
  ;;
  only-pickup)
    nonbackup='yes'
    onlypickup='yes'
    if [ X$s_optarg == 'Xhelp' ]; then
      cat <<"EOF"
    This option tells program not to try to create backups, but only pick up
  backup files already created and transfer them to (from) another host.
    This option doesn't make sense without --to-remote or --from-remote
  option.
  Usage: --only-pickup or --only-pickup=yes or --only-pickup=/path/to/files,
  where /path/to/files overwrites the default, which is localbackuppath/backup.tmp
  (see conf/backup.conf)
EOF
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      if [ ! -e $s_optarg ]; then
        echo "Path $s_optarg doesn't exist!" | tee -a ${rpath}/m_backup.error
        echo "Check if it exists or use --only-pickup=help to get more help." | tee -a ${rpath}/m_backup.error
        exit 1
      else
        pickuppath=$s_optarg
      fi
    fi
  ;;
  only-cleanup|only-clean)
    nonbackup='yes'
    onlyclean='yes'
    if [ "X$s_optarg" == "Xhelp" ]; then
      cat <<"EOF"
    This option is useful for cleaning up disk space. It only removes
  outdated backups, if finds any. 
  It also can be used for cleaning any folders from old files, e.g. backup
  folders, created by another backup script.
  Usage: --only-clean or --only-clean=yes
EOF
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      echo 'Wrong syntax! Use --only-clean=help to get more help' | tee -a ${rpath}/m_backup.error
      exit 1
    fi
  ;;
  configfile|configfiles)
    if [ "X$s_optarg" == "Xhelp" ]; then
      cat <<"EOF"
    You can create as many backup configuration files as you want and backup
  files from or to many hosts at once. But you cannot do all backups in 
  a single run if you use both transfer directions, i.e. --from-remote
  for some hosts and --to-remote for others. Also you may wish to run 
  this program with, for example, --only-clean option for particular hosts.

  Syntax is:
  backup.run --configfiles=file1,file2,file3,...
  All other configuration files will be ignored.

    Note that this option also allows to use any config files names. Without
  this option backup will use only config files that have names like
  backup.*.conf. This option allows having both "usual" and
  "special" config files, so you can create backup.*.conf
  configuration files for most common use and "special"
  configuration files for non-common tasks.
EOF
      exit 0
    elif [ "X$s_optarg" == "X" ] || [ "X$s_optarg" == "Xyes" ]; then
      echo 'Wrong syntax! Use --configfiles=help to get more help' >> ${rpath}/m_backup.error
      exit 1
    fi
    cfgfiles="`echo $s_optarg|sed 's|,| |g'`"
    for conf in ${cfgfiles}
    do
      configfiles="${configfiles} ${rpath}/../conf/${conf}"
    done
  ;;
  replace|incremental|incr)
    replaceflag=1
  ;;
  debug|verbose|v)
    debugflag=1
    export debugflag
  ;;
  help|*)
    cat <<"EOF"
  Possible options:
  --from-remote=method or --to-remote=method (use help instead of a method
  to see methods available)
  --only-pickup (use --only-pickup=help to get more help)
  --only-clean (use --only-clean=help to get more help)
  --configfiles (use --configfiles=help to get more help)
  --replace (replaces the previous backup; makes incremental backup when
    used with the rsync method)
  --verbose (increases logs verbosity)
EOF
    exit 0
  ;;
  esac
done

if [ -n "$debugflag" ]
then
  stdinto="${rpath}/m_backup.log"
  echo -e "OPTIONS:\nxferdirection = ${xferdirection}\nr_proto = ${r_proto}\nnonbackup = ${nonbackup}\nonlypickup = ${onlypickup}\nonlyclean = ${onlyclean}\nconfigfiles = ${configfiles}\nreplaceflag = ${replaceflag}\n" >> ${rpath}/m_backup.log
else
  stdinto="/dev/null"
fi
export stdinto
RSYNC_RSH_BK=$RSYNC_RSH

###################################################################
# Main loop. Runs as many times as many backup.*.conf files used  #
###################################################################

source ${rpath}/../conf/mon.conf
TMPDIR=$TMPDIR/backups
[ -d "$TMPDIR" ] && install -d "$TMPDIR"
export TMPDIR
declare -i res

localbackuppath=${rpath}
install -d "$TMPDIR" 2>&1>>${rpath}/m_backup.error
# If config files collection is not set by option, we use all files having names
# like backup*.conf
if [ -z "$configfiles" ]
then
  configfiles=( )
  for conf in ${rpath}/../conf/backup*.conf
  do
    configfiles+=("${conf}")
  done
  [ -n "$debugflag" ] && echo "configfiles not set, using default: ${configfiles[*]}" >> ${rpath}/m_backup.log
fi
#### Well, lets go
for backupconf in ${configfiles[*]}
do
bconf=${backupconf##*/}
  
  source ${backupconf}

  if [ "$r_proto" == "ftp" ]
  then
    ftpput=`which ncftpput 2>/dev/null`
    ftpget=`which ncftpget 2>/dev/null`
    if [ "X${ftpput}" == "X" ]
    then
      echo 'To use FTP uploads please install NcFTP client' >> ${rpath}/m_backup.error
      exit 1
    fi
  fi
  if [ "$r_proto" == "scp" ]
  then
    SCP="`which scp 2>/dev/null` -r -q"
    if [ "X${SCP}" == "X" ]
    then
      echo "No scp command found! Is OpenSSH installed?" >> ${rpath}/m_backup.error
      exit 1
    elif [ -n "$debugflag" ]
    then
      echo "SCP command is ${SCP}" >> ${rpath}/m_backup.log
    fi
  fi
  if [ "$r_proto" == "rsync" ]
  then
    RSYNC="`which rsync 2>/dev/null`"
    if [ "X${RSYNC}" == "X" ]
    then
      echo 'No rsync command found!' >> ${rpath}/m_backup.error
      exit 1
    elif [ -n "$debugflag" ]
    then
      echo "RSYNC command is ${RSYNC}" >> ${rpath}/m_backup.log
    fi
  fi
  if [ "$r_proto" == "s3" ]
  then
    S3="`which s3cmd 2>/dev/null`"
    if [ "X${S3}" == "X" ]
    then
      echo 'No s3cmd command found!' >> ${rpath}/m_backup.error
      exit 1
    elif [ -n "$debugflag" ]
    then
      echo "S3 command is ${S3}" >> ${rpath}/m_backup.log
    fi
  fi

  [ -z "$remoteuser" ] && remoteuser=$USER
  
  locallogpath=${localbackuppath}
  if [ "X$onlyclean" == "Xyes" ]; then
    localrmpath="${localbackuppath}"
    [ "X${0%/*}" == "X${localrmpath}" ] && localrmpath="${localbackuppath}/backup.local"
  else
    localrmpath=${localbackuppath}/backup.local
  fi
  [ -n "$debugflag" ] && echo -e "localbackuppath = ${localbackuppath}\nSET locallogpath = ${locallogpath}\nSET localrmpath = ${localrmpath}\n" >> ${rpath}/m_backup.log

  echo "Using configuration file ${backupconf}..." >> ${rpath}/m_backup.log
  if [ -z "${remotehost}" ]; then
    r_proto="local"
    echo -e "Connection to remote host isn't setup in ${backupconf}\nTransfer method has been forced to 'local'\n" >> ${rpath}/m_backup.log
  fi
  ARCOPTS=""
  
  [ "X$followlinks" != "Xyes" ] || ARCOPTS="${ARCOPTS} -h"
  [ "X$numericids" != "Xyes" ] || ARCOPTS="${ARCOPTS} --numeric-owner"
  [ "X$preserveperm" != "Xyes" ] || ARCOPTS="${ARCOPTS} -p"
  [ "X$samefs" != "Xyes" ] || ARCOPTS="${ARCOPTS} --one-file-system"
  [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && ARCOPTS="${ARCOPTS} -v" && echo "TAR options are: ${ARCOPTS}" >> ${rpath}/m_backup.log
  
  if [ -z "$nonbackup" -a -z "$onlyclean" ]; then
    install -d "${localbackuppath}/backup.local"
    install -d "${localbackuppath}/backup.tmp"
  fi
  install -d "${locallogpath}/logs"

  if [ -f ${rpath}/../conf/${backupconf}.exclude ]; then
    echo "Excluding files matching patterns from ${rpath}/${backupconf}.exclude" >> ${rpath}/m_backup.log
    ARCOPTS="${ARCOPTS} --totals -X ${rpath}/../conf/${backupconf}.exclude"
  else
    ARCOPTS="${ARCOPTS} --totals"
  fi
  if [ "$xferdirection" != "from-remote" ]
  then
  # if pickuppath is not defined (might be defined as command-line option),
  # the reasonable default is the place where the last backups are located
    if [ -n "$pickuppath" ]; then
      localbackuppath=$pickuppath
    else
      localbackuppath=$localbackuppath/backup.tmp
    fi
  fi
  if [ "$xferdirection" == "from-remote" ]; then
    if [ -n "$pickuppath" ]; then
      remotebackuppath=$pickuppath
    else
      remotebackuppath=$remotebackuppath/backup.tmp
    fi
  fi
  
  if [ -n "$debugflag" ]; then
    echo "SET localbackuppath = ${localbackuppath}" >> ${rpath}/m_backup.log
    [ -n "$remotebackuppath" ] && echo "SET remotebackuppath = ${remotebackuppath}" >> ${rpath}/m_backup.log
  fi
# If no direction is set..
  if [ -z "$xferdirection" ]; then
# ..it means that no --from-remote nor --to-remote options are set either
# Here is the place where other possible options go to.
# Tests for other options are inverted, i.e. if some options ARE set, we do NOT
# make local backups, which should run only if no options set at all.
    if [ -z "$nonbackup" ]; then
# If no options set at all, we make local backup:
      archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
      echo -e "Neither --from-remote nor --to-remote option is set, so this is a local backup.\nMaking local backup to ${localbackuppath}/backup.local...\n" >> ${rpath}/m_backup.log
      xferdirection="to-remote"
      r_proto="local"
    fi
  fi
  
###############################
# From local to remote backup #
###############################

# Starting operations
  if [ "$xferdirection" == "to-remote" ]
  then
# --- Starting nonbackup condition inverted
    if [ -z "$nonbackup" ]; then
# Removing tmp files created during the previous run
      [ -d ${localbackuppath} ] && rm -rf ${localbackuppath}/*  #*/
      if [ -z "$replaceflag" ] || [ ! -f ${rpath}/lastbackup.${bconf}.archname ]; then
        archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
        echo "${archname}" > ${rpath}/lastbackup.${bconf}.archname
      else
        archname=`cat ${rpath}/lastbackup.${bconf}.archname`
      fi
      [ -n "$debugflag" ] && echo "SET archname = ${archname}" >> ${rpath}/m_backup.log
  # Saving folders from backup.sources.list
      while read LINE
      do
        if [ -n "${LINE}" ]; then
          linetoname=`echo ${LINE} | sed 's|/|_|g'`
          if [ "X${compression}" == "Xgzip" ]; then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar.gz" >> ${rpath}/m_backup.log
            tar ${ARCOPTS} -c -z -f ${localbackuppath}/$archname.$linetoname.tar.gz ${LINE} 2>$TMPDIR/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            splitfile ${localbackuppath}/$archname.$linetoname.tar.gz
          fi
          if [ "X${compression}" == "Xbzip2" ]
          then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar.bz2" >> ${rpath}/m_backup.log
            tar ${ARCOPTS} -c -j -f ${localbackuppath}/$archname.$linetoname.tar.bz2 ${LINE} 2>$TMPDIR/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            splitfile ${localbackuppath}/$archname.$linetoname.tar.bz2
          fi
          if [ "X${compression}" == "X" ]
          then
            [ -n "$debugflag" ] && echo "Creating archive $archname.$linetoname.tar" >> ${rpath}/m_backup.log
          	tar ${ARCOPTS} -c -f ${localbackuppath}/$archname.$linetoname.tar ${LINE} 2>$TMPDIR/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            splitfile ${localbackuppath}/$archname.$linetoname.tar
          fi
          
          if [ -f $TMPDIR/$archname.$linetoname.tar.log ]; then
            tarerr=$(grep '^tar:' $TMPDIR/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read')
            [ -n "$tarerr" ] && echo "$tarerr" >> "${rpath}/m_backup.error"
            echo "Tar: ${LINE} copied with some errors, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
            echo "Tar: ${LINE} copied `grep '^Total bytes written:' $TMPDIR/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${rpath}/m_backup.log
          else
            echo "Tar: ${LINE} copied successfully `grep '^Total bytes written:' $TMPDIR/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>"${rpath}/m_backup.log" 2>/dev/null
            rm -f $TMPDIR/$archname.$linetoname.tar.log
          fi
        fi
      done < ${backupconf}.list
      #rm -f $TMPDIR/${archname}.${linetoname}.tar.log
  # Backuping databases (see the correspondent database backup scripts for details
      for DB in ${databases}
      do
        [ -x "${rpath}"/${DB}.backup.sh ] && "${rpath}"/${DB}.backup.sh "${backupconf}" "${archname}" 1>>"${rpath}"/m_backup.log 2>>"${rpath}"/m_backup.error
      done
    else
      archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
    fi   
# --- ending non-backup condition inverted

# Starting files transfer
    case $r_proto in 
    ftp)
      [ "X$followlinks" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$numericids" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$preserveperm" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$samefs" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      FTPOPTS="${ftpoptions}"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && FTPOPTS="${FTPOPTS} -d ${rpath}/m_backup.log" && echo "FTP options are: ${FTPOPTS}" >> ${rpath}/m_backup.log
      ftptime=`(time -p ${ftpput} ${FTPOPTS} -R -V -u${remoteuser} -p${remotepw} -m ${remotehost} ${remotepath} ${localbackuppath}/* 2>$TMPDIR/$archname.ftp.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: ${ftpput} ${FTPOPTS} -R -V -u${remoteuser} -p${remotepw} -m ${remotehost} ${remotepath} ${localbackuppath}\/\*\nftptime = $ftptime\narcsize = $arcsize\n" >> ${rpath}/m_backup.log
      fi
      if [ -f $TMPDIR/$archname.ftp.log ] && [ `cat $TMPDIR/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]; then
        cat $TMPDIR/$archname.ftp.log >> ${rpath}/m_backup.error
        echo -e "FTP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error\nFTP: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)\n" >> ${rpath}/m_backup.log
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.ftp.log
    ;;
    scp)
      [ "X$followlinks" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$numericids" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$preserveperm" != "Xyes" ] || SCPOPTS="${SCPOPTS} -p"
      [ "X$samefs" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$bwlimit" != "X" ] && SCPOPTS="${SCPOPTS} -l $bwlimit"
      [ "X$xfercompression" != "Xyes" ] || SCPOPTS="${SCPOPTS} -C"
      SCPOPTS="${scpoptions}"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && SCPOPTS="${SCPOPTS} -v" && echo "SCP options are: ${SCPOPTS}" >> ${rpath}/m_backup.log
      scptime=`(time -p ${SCP} ${SCPOPTS} ${localbackuppath}/* "${remoteuser}"@"${remotehost}:${remotepath}" 2>$TMPDIR/$archname.scp.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      scptime=`expr $scptime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: ${SCP} ${SCPOPTS} ${localbackuppath}/* ${remoteuser}@${remotehost}:${remotepath}\nscptime = $scptime\narcsize = $arcsize\n" >> ${rpath}/m_backup.log
      fi
      if [ -f $TMPDIR/$archname.scp.log ] && [ `cat $TMPDIR/$archname.scp.log | wc -l` -gt 0 ]; then
        cat $TMPDIR/$archname.scp.log >> ${rpath}/m_backup.error
        echo -e "SCP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error\nSCP: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)\n" >> ${rpath}/m_backup.log
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.scp.log
    ;;
    rsync)
      [ "X$followlinks" == "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -l"
      [ "X$numericids" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} --numeric-owner"
      [ "X$preserveperm" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -Ago"
      [ "X$samefs" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} --safe-links"
      [ "X$bwlimit" != "X" ] && RSYNCOPTS="${SCPOPTS} --bwlimit=`expr $bwlimit / 8`"
      [ "X$xfercompression" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -z"
      RSYNCOPTS="${rsyncoptions} -rt "
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && RSYNCOPTS="${RSYNCOPTS} -v" && echo "Rsync options are: ${RSYNCOPTS}" >> ${rpath}/m_backup.log
      rsynctime=`(time -p ${RSYNC} ${RSYNCOPTS} ${localbackuppath}/* -e "ssh -l ${remoteuser}" "${remoteuser}"@"${remotehost}:${remotepath}" 1>>${rpath}/m_backup.log 2>$TMPDIR/$archname.rsync.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: ${RSYNC} ${RSYNCOPTS} ${localbackuppath}/* -e \"ssh -l ${remoteuser}\" \"${remoteuser}\"@\"${remotehost}:${remotepath}\"\nrsynctime = $rsynctime\narcsize = $arcsize\n" >> ${rpath}/m_backup.log
      fi
      if [ -f $TMPDIR/$archname.rsync.log ] && [ `cat $TMPDIR/$archname.rsync.log | wc -l` -gt 0 ]; then
        cat $TMPDIR/$archname.rsync.log >> ${rpath}/m_backup.error
        echo -e "RSYNC: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error\nRSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)\n" >> ${rpath}/m_backup.log
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.rsync.log
    ;;
    s3)
      [ "X$followlinks" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$numericids" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$preserveperm" != "Xyes" ] && S3OPTS="${S3OPTS} --no-preserve"
      [ "X$samefs" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$bwlimit" != "X" ] && S3OPTS="${S3OPTS}"
      [ "X$xfercompression" != "Xyes" ] || S3OPTS="${S3OPTS}"
      S3OPTS="${s3options}"
      remotepath=${remotepath#/}
      s3target="s3://`echo "${remotehost%/}/${remotepath%/}/" | sed 's|s3://||;s|//|/|g'`"
#      [ -n "$debugflag" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && S3OPTS="${S3OPTS} -v" && echo "S3 options are: ${S3OPTS}" >> ${rpath}/m_backup.log
      s3time=`(time -p ${S3} ${S3OPTS} sync ${localbackuppath}/ "${s3target}" 2>$TMPDIR/$archname.s3.log 1>>$stdinto) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      s3time=`expr $s3time + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: ${S3} ${S3OPTS} sync ${localbackuppath}/ ${s3target}\ns3time = $s3time\narcsize = $arcsize\n" >> ${rpath}/m_backup.log
      fi
      if [ -f $TMPDIR/$archname.s3.log ] && [ `cat $TMPDIR/$archname.s3.log | wc -l` -gt 0 ]; then
        cat $TMPDIR/$archname.s3.log >> ${rpath}/m_backup.error
        echo -e "S3: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error\nS3: Files transferred (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)\n" >> ${rpath}/m_backup.log
      else
        echo "S3: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.s3.log
    ;;
    local)
      [ "X$followlinks" != "Xyes" ] && CPOPTS="${CPOPTS} -d" || CPOPTS="${CPOPTS} -L"
      [ "X$preserveperm" != "Xyes" ] || CPOPTS="${CPOPTS} --preserve=all"
      [ "X$samefs" != "Xyes" ] || CPOPTS="${CPOPTS} --one-file-system"
      CPOPTS="${cpoptions}"
      [ -n "$debugflag" -a -z "$nonbackup" -a -z "$onlyclean" ] && CPOPTS="${CPOPTS} -v" && echo "CP options are: ${CPOPTS}" >> ${rpath}/m_backup.log
      ltime=`(time -p cp ${CPOPTS} -r ${localbackuppath}/* ${remotepath} 2>$TMPDIR/$archname.local.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      ltime=`expr $ltime + 1`
      if [ -n "$debugflag" ]; then
        echo -e "COMMAND: cp ${CPOPTS} -r ${localbackuppath}\/\* ${remotepath}\nltime = $ltime\narcsize = $arcsize\n" >> ${rpath}/m_backup.log
      fi
      if [ -f $TMPDIR/$archname.local.log ] && [ `cat $TMPDIR/$archname.local.log | wc -l` -gt 0 ]; then
        cat $TMPDIR/$archname.local.log >> ${rpath}/m_backup.error
        echo -e "CP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error\nCP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)\n" >> ${rpath}/m_backup.log
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`.`expr $arcsize % 1024 \* 10 / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.local.log
    ;;
    esac
  fi
  
###############################
# From remote to local backup #
###############################

  if [ "$xferdirection" == "from-remote" ]
  then
    # If we want remote operations
    if [ "X$onlypickup" != "Xyes" ]
    then
      # we need SSH client to be present then
      SSH=`which ssh`
      if [ "X$SSH" == "X" ]
      then
        echo "No SSH client found! Consider using --only-pickup option"
        exit 1
      fi
      echo "install -d ${remotepath}/backup.local && install -d ${remotepath}/backup.tmp && install -d $TMPDIR" > ${rpath}/remote.backup.sh
      if [ "X$replaceflag" == "X" ]; then
        echo -e 'archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"\necho "${archname}" > ${rpath}/lastbackup.${bconf}.archname\narchname=`cat ${rpath}/lastbackup.${bconf}.archname`' >> ${rpath}/remote.backup.sh
      fi
      echo 'ARCOPTS="'${ARCOPTS}'"' >> ${rpath}/remote.backup.sh
      echo -e "compression=${compression}\nremotepath=${remotepath}\nkeepremote=${keepremote}\nremoveoldremote=${removeoldremote}\nkeepremotedays=${keepremotedays}\nremotebackuppath=${remotebackuppath}\ndatabases=${databases}\ncd ${remotepath}" >> ${rpath}/remote.backup.sh
      echo 'rm -f ${remotepath}/*.tar*' >> ${rpath}/remote.backup.sh
      for DB in ${databases}
      do
        echo 'rm -f ${remotepath}/${DB}/*.tar*' >> ${rpath}/remote.backup.sh
      done
      while read LINE ; do
        if [ -n "${LINE}" ]; then
          echo "LINE=${LINE}" >> ${rpath}/remote.backup.sh
          linetoname=`echo ${LINE} | sed 's|/|_|g'`
          echo "linetoname=${linetoname}" >> ${rpath}/remote.backup.sh
          if [ "X${compression}" == "Xgzip" ]; then
            echo 'tar ${ARCOPTS} -c -z -f ${remotepath}/$archname.$linetoname.tar.gz ${LINE} 2>$TMPDIR/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
          fi
          if [ "X${compression}" == "Xbzip2" ]; then
            echo 'tar ${ARCOPTS} -c -j -f ${remotepath}/$archname.$linetoname.tar.bz2 ${LINE} 2>$TMPDIR/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
          fi
          cat >> ${rpath}/remote.backup.sh <<"EOF"
if [ -f $TMPDIR/$archname.$linetoname.tar.log ]; then
  tarerr=$(grep '^tar:' $TMPDIR/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read')
  [ -n "$tarerr" ] && echo "$tarerr" >> "${remotepath}/m_backup.error"
  echo "Tar: ${LINE} copied with some errors, see ${localbackuppath}/logs/m_backup.error" >> ${remotepath}/m_backup.log
  echo "Tar: ${LINE} copied `grep '^Total bytes written:' $TMPDIR/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${remotepath}/m_backup.log
else
  echo "Tar: ${LINE} copied successfully `grep '^Total bytes written:' $TMPDIR/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>"${remotepath}/m_backup.log" 2>/dev/null
  rm -f $TMPDIR/$archname.$linetoname.tar.log
fi
if [ X$keepremote == "Xyes" ]; then
  cp -r ${remotepath}/* ${remotepath}/backup.local 2>>${remotepath}/m_backup.error
fi
if [ "X$removeoldremote" == "Xyes" ]; then
  find ${remotepath}/backup.local -mtime +$keepremotedays | xargs rm -f
fi
echo ${archname} > ${remotepath}/m_backup.archname
EOF
        fi
      done < ${rpath}/${backupconf}.list
      
      cat >> ${rpath}/remote.backup.sh <<"EOF"
for DB in ${databases} ; do
  [ -x ${remotepath}/${DB}.backup.sh ] && ${remotepath}/${DB}.backup.sh ${remotepath}/remote.${DB}.conf'
done
EOF
      echo "localbackuppath=${remotepath}" > ${rpath}/remote.${DB}.conf
      for DB in ${databases} ; do
        ${SCP} -q ${rpath}/${DB}.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/${DB}.backup.sh"
        ${SCP} -q ${rpath}/remote.${DB}.conf "${remoteuser}"@"${remotehost}:${remotepath}/remote.${DB}.conf"
      done
      ${SCP} -q ${rpath}/remote.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/remote.backup.sh"
      ${SSH} "${remoteuser}"@"${remotehost}" "bash ${remotepath}/remote.backup.sh && rm -f ${remotepath}/remote.backup.sh"
    fi
    case $r_proto in 
    ftp)
      ${ftpget} -V -u${remoteuser} -p${remotepw} ${remotehost} ${rpath}/ ${remotepath}/m_backup.*
      archname=`cat ${rpath}/m_backup.archname`
      ftptime=`(time -p ${ftpget} -R -V -u${remoteuser} -p${remotepw} ${remotehost} ${localbackuppath}/backup.tmp ${remotepath}/* 2>$TMPDIR/$archname.$linetoname.ftp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ -f $TMPDIR/$archname.$linetoname.ftp.log ] && [ `cat $TMPDIR/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]
      then
        cat $TMPDIR/$archname.$linetoname.ftp.log >> ${rpath}/m_backup.error
        echo "FTP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "FTP: Files transferred (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.$linetoname.ftp.log
    ;;
    scp)
      ${SCP} -q "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      scptime=`(time -p ${SCP} -q -r "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>$TMPDIR/$archname.$linetoname.scp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      scptime=`expr $scptime + 1`
      if [ -f $TMPDIR/$archname.$linetoname.scp.log ] && [ `cat $TMPDIR/$archname.$linetoname.scp.log | wc -l` -gt 0 ]
      then
        cat $TMPDIR/$archname.$linetoname.scp.log >> ${rpath}/m_backup.error
        echo "SCP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "SCP: Files transferred (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.$linetoname.scp.log
    ;;
    rsync)
      ${RSYNC} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      rsynctime=`(time -p ${RSYNC} -r -e "ssh -l ${remoteuser}" "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>$TMPDIR/$archname.$linetoname.rsync.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -f $TMPDIR/$archname.$linetoname.rsync.log ] && [ `cat $TMPDIR/$archname.$linetoname.rsync.log | wc -l` -gt 0 ]
      then
        cat $TMPDIR/$archname.$linetoname.rsync.log >> ${rpath}/m_backup.error
        echo "RSYNC: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "RSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.$linetoname.rsync.log
    ;;
    local)
      ${SCP} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      ltime=`(time -p ${SSH} "${remoteuser}"@"${remotehost}" "cp -r ${remotepath}/* ${remotebackuppath}/backup.tmp 2>$TMPDIR/$archname.$linetoname.local.log") 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ltime=`expr $rsynctime + 1`
      if [ -f $TMPDIR/$archname.$linetoname.local.log ] && [ `cat $TMPDIR/$archname.$linetoname.local.log | wc -l` -gt 0 ]
      then
        cat $TMPDIR/$archname.$linetoname.local.log >> ${rpath}/m_backup.error
        echo "CP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "CP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f $TMPDIR/$archname.$linetoname.local.log
    ;;
    esac
    ${SSH} "${remoteuser}"@"${remotehost}" "rm -f ${remotepath}/m_backup.*"
  fi

# Copying backups to proper location
  if [ "X$keeplocal" == "Xyes" ] && [ "X$nonbackup" == "X" ]
  then
    if [ "X$debugflag" == "X" ]
    then
      cp -r ${localbackuppath}/* ${localbackuppath}/../backup.local 2>>${rpath}/m_backup.error #*/
    else
      echo "Copying backups to proper (local) location:" >> ${rpath}/m_backup.log
      cp -r -v ${localbackuppath}/* ${localbackuppath}/../backup.local 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log #*/
    fi
  fi
  
#############################
# Removing outdated backups #
#############################

  if [ "X$removeoldlocal" == "Xyes" ]
  then
    [ $keeplocaldays -gt 0 ] && keeplocaldays=`expr $keeplocaldays - 1`
    [ -n "$debugflag" ] && rmv='-v'
    find ${localrmpath} -mtime +$keeplocaldays -type f -print0 | xargs -0 rm "$rmv" -f 2>>${rpath}/m_backup.error >> ${rpath}/m_backup.log && echo "Outdated backups at ${localrmpath} have been removed" >> ${rpath}/m_backup.log
  fi
#  echo "if X\$r_proto=X$r_proto"
  if [ "X$removeoldremote" == "Xyes" ] && [ "X$keepremote" == "Xyes" ] && [ "X$r_proto" != "Xlocal" ] && [ -n "${remotehost}" ]; then
    case $r_proto in 
    ftp)
      echo "Removing remote files via FTP is not (yet) supported." | tee -a ${rpath}/m_backup.error | tee -a ${rpath}/m_backup.log
    ;;
    s3)
      remotepath1="${s3target}"
      while true; do
        `which s3cmd` ls "${remotepath1}" > $TMPDIR/s3list.$$
        if [ -n "$debugflag" ]; then
          echo "=== In ${remotepath1} `cat $TMPDIR/s3list.$$|wc -l` objects found" >> ${rpath}/m_backup.log
        fi
        grep DIR $TMPDIR/s3list.$$ | sed 's|^[[:space:]]*DIR[[:space:]]*||g' >> $TMPDIR/s3dirs.$$
        if [ -n "$debugflag" ]; then
          echo "=== `cat $TMPDIR/s3dirs.$$|wc -l` are directories" >> ${rpath}/m_backup.log
        fi
        grep -v ^[[:space:]]*DIR[[:space:]]* $TMPDIR/s3list.$$ >> $TMPDIR/s3files.$$
        if [ -n "$debugflag" ]; then
          echo "=== `cat $TMPDIR/s3files.$$|wc -l` are files" >> ${rpath}/m_backup.log
        fi
        for ((i=0; i < $keepremotedays; i++)); do
          d2k=$(date -d "`date +"%Y/%m/%d"` - $i days" +"%Y-%m-%d")
          sed -i -e "/$d2k/d" $TMPDIR/s3files.$$
        done
        if [ -n "$debugflag" ]; then
          echo "=== `cat $TMPDIR/s3files.$$|wc -l` files have been marked for removal" >> ${rpath}/m_backup.log
        fi
        for s3file in `cat $TMPDIR/s3files.$$ | awk -F's3://' '{print $2}'`; do
          `which s3cmd` del "s3://${s3file}" 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log
        done
        if [ `cat $TMPDIR/s3dirs.$$ | grep -v ^$ | wc -l` -gt 0 ]; then
          remotepath1="`head -1 $TMPDIR/s3dirs.$$`"
          sed -i -e '1d' $TMPDIR/s3dirs.$$ 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log
          if [ -n "$debugflag" ]; then
            echo "=== Entering $remotepath1 directory" >> ${rpath}/m_backup.log
          fi
          continue
        else
          break
        fi
      done
      rm -f $TMPDIR/s3dirs.$$ $TMPDIR/s3files.$$ $TMPDIR/s3list.$$
    ;;
    *)
      SSH=`which ssh`
  #      echo "if \$xferdirection=$xferdirection \|\| X\$onlyclean=X$onlyclean"
      # For --from-remote removing see line 339
      if [ -z "$SSH" ]; then
        echo "No SSH client found! It is impossible to remove outdated backups on remote hosts." | tee -a ${rpath}/m_backup.error | tee -a ${rpath}/m_backup.log
        exit 1
      fi
      [ $keepremotedays -gt 0 ] && keepremotedays=`expr $keepremotedays - 1`
      ${SSH} "${remoteuser}"@"${remotehost}" "find ${remotepath} -mtime +$keepremotedays -type f" 2>>${rpath}/m_backup.error > $TMPDIR/remote_files_to_remove.list
      res=0
      for LINE in `cat $TMPDIR/remote_files_to_remove.list`
      do
        [ -n "$debugflag" ] && rmv='-v'
        ${SSH} "${remoteuser}"@"${remotehost}" "rm "$rmv" -f \"${LINE}\"" 2>>${rpath}/m_backup.error >> ${rpath}/m_backup.log
        res+=$?
      done
      if [ $res -eq 0 ]; then
        echo "Outdated backups at ${remotehost}:${remotepath} have been removed" >> ${rpath}/m_backup.log
      else
        echo "Outdated backups at ${remotehost}:${remotepath} have not been removed" >> ${rpath}/m_backup.error
      fi
    ;;
    esac
  fi

#########################
# Reporting and logging #
#########################

  echo -e "          Backup operations report\n--------------------------------------------------------------\nDate: `date`\n\n" > ${rpath}/backup.report
  if [ -z "$nonbackup" ]; then
    echo -e "Archive file name pattern: ${archname}\n--------------------------------------------------------------\n\n" >> ${rpath}/backup.report
  fi
  cat ${rpath}/m_backup.error >> ${locallogpath}/logs/m_backup.error
  
  errlog=`grep "\*\*\*" ${rpath}/m_backup.error`
  if [ -n "$errlog" ]; then
    if [ -n "$debugflag" ]; then
      cat ${rpath}/m_backup.error >> ${rpath}/backup.report
    else
      echo "*** There were errors during this backup:" >> ${rpath}/backup.report
      for command in "cp scp rsync debug mv rm mysql pgsql ncftpput tar"
      do
        grep -i -m 3 "^${command}" ${rpath}/m_backup.error >> ${rpath}/backup.report
      done
      echo -e "*** Note that errors shown are limited to 3 errors for every operation\nFull error log is available at ${locallogpath}/logs/m_backup.error\n" >> ${rpath}/backup.report
    fi
  fi
  
  echo -e "Operations finished:\n\n" >> ${rpath}/backup.report

  cat ${rpath}/m_backup.log >> ${rpath}/backup.report
# Send report by email
  while read LINE
  do
    if [ -n "${LINE}" ]; then
      cat ${rpath}/backup.report | mail -s "Server $(hostname -f) backup report" "${LINE}"
    fi
  done < ${rpath}/../conf/mail.backup.list
  
  if [ -n "$errlog" ]; then
    echo "*** `date` ***" >> ${locallogpath}/logs/m_backup.error
    if [ "X$nonbackup" == "X" ]; then
      echo "*** ${archname} ***" >> ${locallogpath}/logs/m_backup.error
    fi
    cat ${rpath}/m_backup.error >> ${locallogpath}/logs/m_backup.error
  fi
  echo "*** `date` ***" >> ${locallogpath}/logs/m_backup.log
  if [ "X$nonbackup" == "X" ]; then
    echo "*** ${archname} ***" >> ${locallogpath}/logs/m_backup.log
  fi
  
  cat ${rpath}/m_backup.log >> ${locallogpath}/logs/m_backup.log
  rm -f ${rpath}/m_backup.{error,log}
  rm -f $TMPDIR/$archname*log
### Now it's time to restore some environment variables
  export RSYNC_RSH="${RSYNC_RSH_BK}"
done

