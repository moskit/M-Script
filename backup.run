#!/usr/bin/env bash
# Copyright (C) 2008-2009 Igor Simonov (me@igorsimonov.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

    
[ -h $0 ] && xcommand=`readlink $0` || xcommand=$0
rcommand=${xcommand##*/}
rpath=${xcommand%/*}
#*/ (this is needed to fool vi syntax highlighting)
rm -f ${rpath}/m_backup.log

for s_option in $@
do
  case $s_option in
  --*=*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`  
    s_optarg=`expr "X$s_option" : 'X[^=]*=\(.*\)'` 
    ;;
  --*)
    s_optname=`expr "X$s_option" : 'X[^-]*-*\([^=]*\)'`    
    s_optarg='yes' 
    ;;
  *=*)
    echo 'Error: wrong syntax in ${s_option}' >> ${rpath}/m_backup.error
    exit 1
    ;;
  *)
    s_param=${s_option}
    s_optname=''
    s_optarg=''
    ;;
  esac
  case $s_optname in
  from-remote | to-remote)
    xferdirection=$s_optname
    case $s_optarg in
    ftp)	r_proto='ftp' ;;
    scp) 	r_proto='scp' ;;
    rsync)	r_proto='rsync' ;;
    local)  r_proto='local' ;;
    s3) r_proto='s3' ;;
    help | *)
      echo '  Files transfer method.'
      echo '  Usage: --from-remote=method or --to-remote=method'
      echo '  Supported methods are:'
      echo '  ftp scp rsync s3 local'
      exit 0
    ;;
    esac
  ;;
  only-pickup)
    nonbackup='yes'
    onlypickup='yes'
    if [ X$s_optarg == 'Xhelp' ]; then
      echo '    This option tells program not to try to create backups, but only pick up'
      echo '  backup files already created and transfer them to (from) another host.'
      echo "    This option doesn't make sense without --to-remote or --from-remote"
      echo '  option.'
      echo '  Usage: --only-pickup or --only-pickup=yes or --only-pickup=/path/to/files,'
      echo '  where /path/to/files overwrites the default, which is localbackuppath/backup.tmp'
      echo '  (see conf/backup.configuration files)'
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      if [ ! -e $s_optarg ]; then
        echo "Path $s_optarg doesn't exist!" | tee -a ${rpath}/m_backup.error
        echo "Check if it exists or use --only-pickup=help to get more help." | tee -a ${rpath}/m_backup.error
        exit 1
      else
        pickuppath=$s_optarg
      fi
    fi
  ;;
  only-cleanup|only-clean)
    nonbackup='yes'
    onlyclean='yes'
    if [ "X$s_optarg" == "Xhelp" ]; then
      echo '    This option is useful for cleaning up disk space. It only removes'
      echo '  outdated backups, if finds any. '
      echo '  It also can be used for cleaning any folders from old files, e.g. backup'
      echo '  folders, created by another backup script.'
      echo '  Usage: --only-clean or --only-clean=yes'
      exit 0
    elif [ "X$s_optarg" != "X" ] && [ "X$s_optarg" != "Xyes" ]; then
      echo 'Wrong syntax! Use --only-clean=help to get more help' | tee -a ${rpath}/m_backup.error
      exit 1
    fi
  ;;
  configfile|configfiles)
    if [ "X$s_optarg" == "Xhelp" ]; then
      echo '    You can create as many conf/backup.configuration files as you want and backup'
      echo '  files from or to many hosts at once. But you cannot do all backups in '
      echo '  a single run if you use both transfer directions, i.e. --from-remote'
      echo '  for some hosts and --to-remote for others. Also you may wish to run it '
      echo '  this program with, for example, --only-clean option for particular hosts.'
      echo ''
      echo '  Syntax is:'
      echo "  ${0} --configfile=file1,file2,file3,..."
      echo '  All other conf/backup.configuration files will be ignored.'
      echo ''
      echo '    Note that this option also allows using any config files names. Without'
      echo '  this option backup will use only config files having names like'
      echo '  backup.*.conf. This option, in contrary, allows having both "usual" and'
      echo '  "special" config files, so you can create backup.*.conf'
      echo '  configuration files for most common use and "special"'
      echo '  configuration files for non-common tasks.'
      exit 0
    elif [ "X$s_optarg" == "X" ] || [ "X$s_optarg" == "Xyes" ]; then
      echo 'Wrong syntax! Use --configfile=help to get more help' >> ${rpath}/m_backup.error
      exit 1
    fi
    cfgfiles="`echo $s_optarg|sed 's|,| |g'`"
    for conf in ${cfgfiles}
    do
      configfiles="${configfiles} ${rpath}/${conf}"
    done
  ;;
  replace|incremental|incr)
    replaceflag=1
  ;;
  debug|verbose|v)
    debugflag=1
  ;;
  help|*)
    echo '  Possible options are:'
    echo '  --from-remote=method or --to-remote=method (use help instead of a method'
    echo '  to see methods available)'
    echo '  --only-pickup (use --only-pickup=help to get more help)'
    echo '  --only-clean (use --only-clean=help to get more help)'
    echo '  --configfiles (use --configfiles=help to get more help)'
    echo '  --replace (replaces the previous backup; makes incremental backup when'
    echo '    used with the rsync method)'
    echo '  --verbose (increases logs verbosity)'
    exit 0
  ;;
  esac
done

if [ "X$debugflag" != "X" ]
then
  echo "OPTIONS:" >> ${rpath}/m_backup.log
  echo "xferdirection = ${xferdirection}" >> ${rpath}/m_backup.log
  echo "r_proto = ${r_proto}" >> ${rpath}/m_backup.log
  echo "nonbackup = ${nonbackup}" >> ${rpath}/m_backup.log
  echo "onlypickup = ${onlypickup}" >> ${rpath}/m_backup.log
  echo "onlyclean = ${onlyclean}" >> ${rpath}/m_backup.log
  echo "configfiles = ${configfiles}" >> ${rpath}/m_backup.log
  echo "replaceflag = ${replaceflag}" >> ${rpath}/m_backup.log
fi

###################################################################
# Main loop. Runs as many times as many backup.*.conf files used  #
###################################################################

# If no backup paths found in conf file, use current path
# TODO: is this the best solution? 
localbackuppath=${PWD}
`which install` -d "/tmp/m_script" 2>&1>>${rpath}/m_backup.error
# If config files collection is not set by option, we use all files having names
# like backup*.conf
if [ "X$configfiles" == "X" ]
then
# We use a loop to avoid possible issues caused by customized ls
  for conf in ${rpath}/backup*.conf
  do
    configfiles="${configfiles} ${conf}"
  done
  [ "X$debugflag" != "X" ] && echo "configfiles not set, using default: ${configfiles}" >> ${rpath}/m_backup.log
fi
#### Well, lets go
for backupconf in ${configfiles}
do
bconf=`basename ${backupconf}`
# Here we store environment variables that might be replaced by variables
# from current conf/backup.configuration file. When the main loop finishes, we
# restore them back (look for this somewhere closer to bottom)
  RSYNC_RSH_BK="${RSYNC_RSH}"
  
  source ${backupconf}

  if [ "$r_proto" == "ftp" ]
  then
    ftpput=`which ncftpput 2>/dev/null`
    ftpget=`which ncftpget 2>/dev/null`
    if [ "X${ftpput}" == "X" ]
    then
      echo 'To use FTP uploads please install NcFTP client' >> ${rpath}/m_backup.error
      exit 1
    fi
  fi
  if [ "$r_proto" == "scp" ]
  then
    SCP="`which scp 2>/dev/null` -r -q"
    if [ "X${SCP}" == "X" ]
    then
      echo "No scp command found! Is OpenSSH installed?" >> ${rpath}/m_backup.error
      exit 1
    elif [ "X$debugflag" != "X" ]
    then
      echo "SCP command is ${SCP}" >> ${rpath}/m_backup.log
    fi
  fi
  if [ "$r_proto" == "rsync" ]
  then
    RSYNC="`which rsync 2>/dev/null`"
    if [ "X${RSYNC}" == "X" ]
    then
      echo 'No rsync command found!' >> ${rpath}/m_backup.error
      exit 1
    elif [ "X$debugflag" != "X" ]
    then
      echo "RSYNC command is ${RSYNC}" >> ${rpath}/m_backup.log
    fi
  fi
  if [ "$r_proto" == "s3" ]
  then
    S3="`which s3cmd 2>/dev/null`"
    if [ "X${S3}" == "X" ]
    then
      echo 'No s3cmd command found!' >> ${rpath}/m_backup.error
      exit 1
    elif [ "X$debugflag" != "X" ]
    then
      echo "S3 command is ${S3}" >> ${rpath}/m_backup.log
    fi
  fi

  [ "X$remoteuser" == "X" ] && remoteuser=$USER
  
  export RSYNC_RSH="${RSYNC_RSH}"
  
  locallogpath=${localbackuppath}
  if [ "X$onlyclean" == "Xyes" ]
  then
    localrmpath="${localbackuppath}"
    [ "X${0%/*}" == "X${localrmpath}" ] && localrmpath="${localbackuppath}/backup.local"
  else
    localrmpath=${localbackuppath}/backup.local
  fi
  if [ "X$debugflag" != "X" ]
  then
    echo "localbackuppath = ${localbackuppath}" >> ${rpath}/m_backup.log
    echo "SET locallogpath = ${locallogpath}" >> ${rpath}/m_backup.log
    echo "SET localrmpath = ${localrmpath}" >> ${rpath}/m_backup.log
  fi
  echo "Using configuration file ${backupconf}..." >> ${rpath}/m_backup.log
  if [ "X${remoteuser}" == "X" ] && [ "X${remotehost}" == "X" ]
  then
    r_proto="local"
    echo "Connection to remote host isn't setup in ${backupconf}" >> ${rpath}/m_backup.log
    echo "Transfer method has been forced to 'local'" >> ${rpath}/m_backup.log
  fi
  ARCOPTS=""
  
  [ "X$followlinks" != "Xyes" ] || ARCOPTS="${ARCOPTS} -h"
  [ "X$numericids" != "Xyes" ] || ARCOPTS="${ARCOPTS} --numeric-owner"
  [ "X$preserveperm" != "Xyes" ] || ARCOPTS="${ARCOPTS} -p"
  [ "X$samefs" != "Xyes" ] || ARCOPTS="${ARCOPTS} --one-file-system"
  [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && ARCOPTS="${ARCOPTS} -v" && echo "TAR options are: ${ARCOPTS}" >> ${rpath}/m_backup.log
  
  if [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ]
  then
    install -d "${localbackuppath}/backup.local" 2>&1>>${rpath}/m_backup.error
    install -d "${localbackuppath}/backup.tmp" 2>&1>>${rpath}/m_backup.error
  fi
  install -d "${locallogpath}/logs" 2>&1>>${rpath}/m_backup.error

  if [ -f ${rpath}/${backupconf}.exclude ]
  then
    echo "Excluding files matching patterns from ${rpath}/${backupconf}.exclude" >> ${rpath}/m_backup.log
    ARCOPTS="${ARCOPTS} --totals -X ${rpath}/${backupconf}.exclude"
  else
    ARCOPTS="${ARCOPTS} --totals"
  fi
  if [ "$xferdirection" != "from-remote" ]
  then
  # if pickuppath is not defined (might be defined as command-line option),
  # the reasonable default is the place where the last backups are located
    if [ "X$pickuppath" != "X" ]
    then
      localbackuppath=$pickuppath
    else
      localbackuppath=$localbackuppath/backup.tmp
    fi
  fi
  if [ "$xferdirection" == "from-remote" ]
  then
    if [ "X$pickuppath" != "X" ]
    then
      remotebackuppath=$pickuppath
    else
      remotebackuppath=$remotebackuppath/backup.tmp
    fi
  fi
  
  if [ "X$debugflag" != "X" ]
  then
    echo "SET localbackuppath = ${localbackuppath}" >> ${rpath}/m_backup.log
    [ "X$remotebackuppath" == "X" ] || echo "SET remotebackuppath = ${remotebackuppath}" >> ${rpath}/m_backup.log
  fi
  
###############################
# From local to remote backup #
###############################

# Starting operations
  if [ "$xferdirection" == "to-remote" ]
  then
# --- Starting nonbackup condition inverted
    if [ "X$nonbackup" == "X" ]
    then
# Removing tmp files created during the previous run
      [ -d ${localbackuppath} ] && rm -rf ${localbackuppath}/*  #*/
      if [ "X$replaceflag" == "X" ] || [ ! -f ${rpath}/lastbackup.${bconf}.archname ]
      then
        archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
        echo "${archname}" > ${rpath}/lastbackup.${bconf}.archname
      else
        archname=`cat ${rpath}/lastbackup.${bconf}.archname`
      fi
      [ "X$debugflag" != "X" ] && echo "SET archname = ${archname}" >> ${rpath}/m_backup.log
  # Saving folders from backup.sources.list
      while read LINE
      do
        if [ "x${LINE}" != "x" ]
        then
          linetoname=`echo ${LINE} | sed 's|/|_|g'`
          if [ "X${compression}" == "Xgzip" ]
          then
            [ "X$debugflag" != "X" ] && echo "Creating archive $archname.$linetoname.tar.gz" >> ${rpath}/m_backup.log
            tar ${ARCOPTS} -c -z -f ${localbackuppath}/$archname.$linetoname.tar.gz ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            if [ "X$split_size" != "X" ]; then
              split -b $split_size -d ${localbackuppath}/$archname.$linetoname.tar.gz ${localbackuppath}/$archname.$linetoname.tar.gz 2>>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
              rm -f ${localbackuppath}/$archname.$linetoname.tar.gz
            fi
          fi
          if [ "X${compression}" == "Xbzip2" ]
          then
            [ "X$debugflag" != "X" ] && echo "Creating archive $archname.$linetoname.tar.bz2" >> ${rpath}/m_backup.log
            tar ${ARCOPTS} -c -j -f ${localbackuppath}/$archname.$linetoname.tar.bz2 ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            if [ "X$split_size" != "X" ]; then
              split -b $split_size -d ${localbackuppath}/$archname.$linetoname.tar.bz2 ${localbackuppath}/$archname.$linetoname.tar.bz2 2>>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
              rm -f ${localbackuppath}/$archname.$linetoname.tar.bz2
            fi
          fi
          if [ "X${compression}" == "X" ]
          then
            [ "X$debugflag" != "X" ] && echo "Creating archive $archname.$linetoname.tar" >> ${rpath}/m_backup.log
          	tar ${ARCOPTS} -c -f ${localbackuppath}/$archname.$linetoname.tar ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
            if [ "X$split_size" != "X" ]; then
              split -b $split_size -d ${localbackuppath}/$archname.$linetoname.tar ${localbackuppath}/$archname.$linetoname.tar 2>>/tmp/m_script/$archname.$linetoname.tar.log 1>>${rpath}/m_backup.log
              rm -f ${localbackuppath}/$archname.$linetoname.tar
            fi
          fi
          if [ -f /tmp/m_script/$archname.$linetoname.tar.log ] && [ $(grep '^tar:' /tmp/m_script/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read' | wc -l) -gt 0 ]
          then
            grep '^tar:' /tmp/m_script/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read' >> ${rpath}/m_backup.error
            echo "Tar: ${LINE} copied with some errors, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
            echo "Tar: ${LINE} copied `grep '^Total bytes written:' /tmp/m_script/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${rpath}/m_backup.log
          else
            echo "Tar: ${LINE} copied successfully `grep '^Total bytes written:' /tmp/m_script/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${rpath}/m_backup.log 2>/dev/null
            rm -f /tmp/m_script/$archname.$linetoname.tar.log
          fi
        fi
      done < ${backupconf}.list
      #rm -f /tmp/m_script/${archname}.${linetoname}.tar.log
  # Backuping databases (see the correspondent database backup scripts for details
      for DB in ${databases}
      do
        [ -x ${rpath}/${DB}.backup.sh ] && ${rpath}/${DB}.backup.sh "${backupconf}" "${archname}" 2>>${rpath}/m_backup.error
      done
    else
      archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
    fi   
# --- ending non-backup condition inverted

# Starting files transfer
    case $r_proto in 
    ftp)
      [ "X$followlinks" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$numericids" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$preserveperm" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      [ "X$samefs" != "Xyes" ] || FTPOPTS="${FTPOPTS}"
      FTPOPTS="${ftpoptions}"
      [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && FTPOPTS="${FTPOPTS} -d ${rpath}/m_backup.log" && echo "FTP options are: ${FTPOPTS}" >> ${rpath}/m_backup.log
      ftptime=`(time -p ${ftpput} ${FTPOPTS} -R -V -u${remoteuser} -p${remotepw} -m ${remotehost} ${remotepath} ${localbackuppath}/* 2>/tmp/m_script/$archname.ftp.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ "X$debugflag" != "X" ]
      then
        echo "COMMAND: ${ftpput} ${FTPOPTS} -R -V -u${remoteuser} -p${remotepw} -m ${remotehost} ${remotepath} ${localbackuppath}\/\*" >> ${rpath}/m_backup.log
        echo "ftptime = $ftptime" >> ${rpath}/m_backup.log
        echo "arcsize = $arcsize" >> ${rpath}/m_backup.log
      fi
      if [ -f /tmp/m_script/$archname.ftp.log ] && [ `cat /tmp/m_script/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.ftp.log >> ${rpath}/m_backup.error
        echo "FTP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "FTP: Files transferred (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.ftp.log
    ;;
    scp)
      [ "X$followlinks" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$numericids" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$preserveperm" != "Xyes" ] || SCPOPTS="${SCPOPTS} -p"
      [ "X$samefs" != "Xyes" ] || SCPOPTS="${SCPOPTS}"
      [ "X$bwlimit" != "X" ] && SCPOPTS="${SCPOPTS} -l $bwlimit"
      [ "X$xfercompression" != "Xyes" ] || SCPOPTS="${SCPOPTS} -C"
      SCPOPTS="${scpoptions}"
      [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && SCPOPTS="${SCPOPTS} -v" && echo "SCP options are: ${SCPOPTS}" >> ${rpath}/m_backup.log
      scptime=`(time -p ${SCP} ${SCPOPTS} ${localbackuppath}/* "${remoteuser}"@"${remotehost}:${remotepath}" 2>/tmp/m_script/$archname.scp.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      scptime=`expr $scptime + 1`
      if [ "X$debugflag" != "X" ]
      then
        echo "COMMAND: ${SCP} ${SCPOPTS} ${localbackuppath}/* ${remoteuser}@${remotehost}:${remotepath}" >> ${rpath}/m_backup.log
        echo "scptime = $scptime" >> ${rpath}/m_backup.log
        echo "arcsize = $arcsize" >> ${rpath}/m_backup.log
      fi
      if [ -f /tmp/m_script/$archname.scp.log ] && [ `cat /tmp/m_script/$archname.scp.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.scp.log >> ${rpath}/m_backup.error
        echo "SCP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "SCP: Files transferred (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.scp.log
    ;;
    rsync)
      [ "X$followlinks" == "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -l"
      [ "X$numericids" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} --numeric-owner"
      [ "X$preserveperm" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -Ago"
      [ "X$samefs" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} --safe-links"
      [ "X$bwlimit" != "X" ] && RSYNCOPTS="${SCPOPTS} --bwlimit=`expr $bwlimit / 8`"
      [ "X$xfercompression" != "Xyes" ] || RSYNCOPTS="${RSYNCOPTS} -z"
      RSYNCOPTS="${rsyncoptions} -rt "
      [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && RSYNCOPTS="${RSYNCOPTS} -v" && echo "Rsync options are: ${RSYNCOPTS}" >> ${rpath}/m_backup.log
      rsynctime=`(time -p ${RSYNC} ${RSYNCOPTS} ${localbackuppath}/* -e "ssh -l ${remoteuser}" "${remoteuser}"@"${remotehost}:${remotepath}" 1>>${rpath}/m_backup.log 2>/tmp/m_script/$archname.rsync.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ "X$debugflag" != "X" ]
      then
        echo "COMMAND: ${RSYNC} ${RSYNCOPTS} ${localbackuppath}/* -e \"ssh -l ${remoteuser}\" \"${remoteuser}\"@\"${remotehost}:${remotepath}\"" >> ${rpath}/m_backup.log
        echo "rsynctime = $rsynctime" >> ${rpath}/m_backup.log
        echo "arcsize = $arcsize" >> ${rpath}/m_backup.log
      fi
      if [ -f /tmp/m_script/$archname.rsync.log ] && [ `cat /tmp/m_script/$archname.rsync.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.rsync.log >> ${rpath}/m_backup.error
        echo "RSYNC: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "RSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.rsync.log
    ;;
    s3)
      [ "X$followlinks" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$numericids" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$preserveperm" != "Xyes" ] && S3OPTS="${S3OPTS} --no-preserve"
      [ "X$samefs" != "Xyes" ] || S3OPTS="${S3OPTS}"
      [ "X$bwlimit" != "X" ] && S3OPTS="${S3OPTS}"
      [ "X$xfercompression" != "Xyes" ] || S3OPTS="${S3OPTS}"
      S3OPTS="${s3options}"
      [ "X$remotepath" == "X" ] || remotepath="${remotepath%/}/"
#      [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && S3OPTS="${S3OPTS} -v" && echo "S3 options are: ${S3OPTS}" >> ${rpath}/m_backup.log
      s3time=`(time -p ${S3} ${S3OPTS} sync ${localbackuppath}/ "${remotehost}/${remotepath}" 2>/tmp/m_script/$archname.s3.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      s3time=`expr $s3time + 1`
      if [ "X$debugflag" != "X" ]
      then
        echo "COMMAND: ${S3} ${S3OPTS} sync ${localbackuppath}/ ${remotehost}/${remotepath}" >> ${rpath}/m_backup.log
        echo "s3time = $s3time" >> ${rpath}/m_backup.log
        echo "arcsize = $arcsize" >> ${rpath}/m_backup.log
      fi
      if [ -f /tmp/m_script/$archname.s3.log ] && [ `cat /tmp/m_script/$archname.s3.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.s3.log >> ${rpath}/m_backup.error
        echo "S3: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "S3: Files transferred (`expr $arcsize / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "S3: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $s3time / 60`min, `expr $arcsize / $s3time`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.s3.log
    ;;
    local)
      [ "X$followlinks" != "Xyes" ] && CPOPTS="${CPOPTS} -d" || CPOPTS="${CPOPTS} -L"
      [ "X$preserveperm" != "Xyes" ] || CPOPTS="${CPOPTS} --preserve=all"
      [ "X$samefs" != "Xyes" ] || CPOPTS="${CPOPTS} --one-file-system"
      CPOPTS="${cpoptions}"
      [ "X$debugflag" != "X" ] && [ "X$nonbackup" == "X" ] && [ "X$onlyclean" == "X" ] && CPOPTS="${CPOPTS} -v" && echo "CP options are: ${CPOPTS}" >> ${rpath}/m_backup.log
      ltime=`(time -p cp ${CPOPTS} -r ${localbackuppath}/* ${remotepath} 2>/tmp/m_script/$archname.local.log 1>>${rpath}/m_backup.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -s ${localbackuppath} | cut -f1`
      ltime=`expr $ltime + 1`
      if [ "X$debugflag" != "X" ]
      then
        echo "COMMAND: cp ${CPOPTS} -r ${localbackuppath}\/\* ${remotepath}" >> ${rpath}/m_backup.log
        echo "ltime = $ltime" >> ${rpath}/m_backup.log
        echo "arcsize = $arcsize" >> ${rpath}/m_backup.log
      fi
      if [ -f /tmp/m_script/$archname.local.log ] && [ `cat /tmp/m_script/$archname.local.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.local.log >> ${rpath}/m_backup.error
        echo "CP: There were errors while transferring files, see ${locallogpath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "CP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.local.log
    ;;
    esac
  fi
  
###############################
# From remote to local backup #
###############################

  if [ "$xferdirection" == "from-remote" ]
  then
    # If we want remote operations
    if [ "X$onlypickup" != "Xyes" ]
    then
      # we need SSH client to be present then
      SSH=`which ssh`
      if [ "X$SSH" == "X" ]
      then
        echo "No SSH client found! Consider using --only-pickup option"
        exit 1
      fi
      echo "install -d ${remotepath}/backup.local && install -d ${remotepath}/backup.tmp && install -d /tmp/m_script" > ${rpath}/remote.backup.sh
      if [ "X$replaceflag" == "X" ]
      then
        echo 'archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"' >> ${rpath}/remote.backup.sh
        echo 'echo "${archname}" > ${rpath}/lastbackup.${bconf}.archname' >> ${rpath}/remote.backup.sh
      else
        echo 'archname=`cat ${rpath}/lastbackup.${bconf}.archname`' >> ${rpath}/remote.backup.sh
      fi
      echo "compression=${compression}" >> ${rpath}/remote.backup.sh
      echo "remotepath=${remotepath}" >> ${rpath}/remote.backup.sh
      echo 'ARCOPTS="'${ARCOPTS}'"' >> ${rpath}/remote.backup.sh
      echo "keepremote=${keepremote}" >> ${rpath}/remote.backup.sh
      echo "removeoldremote=${removeoldremote}" >> ${rpath}/remote.backup.sh
      echo "keepremotedays=${keepremotedays}" >> ${rpath}/remote.backup.sh
      echo "remotebackuppath=${remotebackuppath}" >> ${rpath}/remote.backup.sh
      echo "databases=${databases}" >> ${rpath}/remote.backup.sh
      echo "cd ${remotepath}" >> ${rpath}/remote.backup.sh
      echo 'rm -f ${remotepath}/*.tar*' >> ${rpath}/remote.backup.sh
      for DB in ${databases}
      do
        echo 'rm -f ${remotepath}/${DB}/*.tar*' >> ${rpath}/remote.backup.sh
      done
      while read LINE
      do
        if [ "x${LINE}" != "x" ]
        then
          echo "LINE=${LINE}" >> ${rpath}/remote.backup.sh
          linetoname=`echo ${LINE} | sed 's|/|_|g'`
          echo "linetoname=${linetoname}" >> ${rpath}/remote.backup.sh
          if [ "X${compression}" == "Xgzip" ]
          then
            echo 'tar ${ARCOPTS} -c -z -f ${remotepath}/$archname.$linetoname.tar.gz ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
          fi
          if [ "X${compression}" == "Xbzip2" ]
          then
            echo 'tar ${ARCOPTS} -c -j -f ${remotepath}/$archname.$linetoname.tar.bz2 ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log' >> ${rpath}/remote.backup.sh
          fi
          echo 'if [ -f /tmp/m_script/$archname.$linetoname.tar.log] && [ `grep "^tar:" /tmp/m_script/$archname.$linetoname.tar.log | grep -v "Removing leading" | wc -l` -gt 0 ]' >> ${rpath}/remote.backup.sh
          echo 'then' >> ${rpath}/remote.backup.sh
          echo 'grep "^tar:" /tmp/m_script/$archname.$linetoname.tar.log | grep -v "Removing leading" >> ${remotepath}/m_backup.error' >> ${rpath}/remote.backup.sh
          echo 'echo "Tar: ${LINE} copied with some errors, see ${localbackuppath}/logs/m_backup.error" >> ${remotepath}/m_backup.log' >> ${rpath}/remote.backup.sh
          echo 'echo "Tar: ${LINE} copied `grep '^Total bytes written:' /tmp/m_script/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${remotepath}/m_backup.log' >> ${rpath}/remote.backup.sh
          echo 'else' >> ${rpath}/remote.backup.sh
          echo 'tarresult=`grep "^Total bytes written:" /tmp/m_script/$archname.$linetoname.tar.log | cut -d" " -f5,6`' >> ${rpath}/remote.backup.sh
          echo 'echo "Tar: ${LINE} copied successfully ${tarresult}" >>${remotepath}/m_backup.log' >> ${rpath}/remote.backup.sh
          echo 'fi' >> ${rpath}/remote.backup.sh
          
          echo 'if [ X$keepremote == "Xyes" ]' >> ${rpath}/remote.backup.sh
          echo 'then' >> ${rpath}/remote.backup.sh
            echo 'cp -r ${remotepath}/* ${remotepath}/backup.local 2>>${rpath}/m_backup.error' >> ${rpath}/remote.backup.sh
          echo 'fi' >> ${rpath}/remote.backup.sh
          echo 'if [ "X$removeoldremote" == "Xyes" ]' >> ${rpath}/remote.backup.sh
          echo 'then' >> ${rpath}/remote.backup.sh
            echo 'find ${remotepath}/backup.local -mtime +$keepremotedays | xargs rm -f' >> ${rpath}/remote.backup.sh
          echo 'fi' >> ${rpath}/remote.backup.sh
          echo 'echo ${archname} > ${remotepath}/m_backup.archname' >> ${rpath}/remote.backup.sh
        fi
      done < ${rpath}/${backupconf}.list
      echo 'for DB in "${databases}"' >> ${rpath}/remote.backup.sh
      echo 'do' >> ${rpath}/remote.backup.sh
      echo '[ -x '${remotepath}'/${DB}.backup.sh ] && '${remotepath}'/${DB}.backup.sh ${remotepath}/remote.${DB}.conf' >> ${rpath}/remote.backup.sh
      echo 'done' >> ${rpath}/remote.backup.sh
      echo "localbackuppath=${remotepath}" > ${rpath}/remote.${DB}.conf
      for DB in "${databases}"
      do
        ${SCP} -q ${rpath}/${DB}.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/${DB}.backup.sh"
        ${SCP} -q ${rpath}/remote.${DB}.conf "${remoteuser}"@"${remotehost}:${remotepath}/remote.${DB}.conf"
      done
      ${SCP} -q ${rpath}/remote.backup.sh "${remoteuser}"@"${remotehost}:${remotepath}/remote.backup.sh"
      ${SSH} "${remoteuser}"@"${remotehost}" "bash ${remotepath}/remote.backup.sh && rm -f ${remotepath}/remote.backup.sh"
    fi
    case $r_proto in 
    ftp)
      ${ftpget} -V -u${remoteuser} -p${remotepw} ${remotehost} ${rpath}/ ${remotepath}/m_backup.*
      archname=`cat ${rpath}/m_backup.archname`
      ftptime=`(time -p ${ftpget} -R -V -u${remoteuser} -p${remotepw} ${remotehost} ${localbackuppath}/backup.tmp ${remotepath}/* 2>/tmp/m_script/$archname.$linetoname.ftp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ftptime=`expr $ftptime + 1`
      if [ -f /tmp/m_script/$archname.$linetoname.ftp.log ] && [ `cat /tmp/m_script/$archname.$linetoname.ftp.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.$linetoname.ftp.log >> ${rpath}/m_backup.error
        echo "FTP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "FTP: Files transferred (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "FTP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ftptime / 60`min, `expr $arcsize / $ftptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.$linetoname.ftp.log
    ;;
    scp)
      ${SCP} -q "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      scptime=`(time -p ${SCP} -q -r "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>/tmp/m_script/$archname.$linetoname.scp.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      scptime=`expr $scptime + 1`
      if [ -f /tmp/m_script/$archname.$linetoname.scp.log ] && [ `cat /tmp/m_script/$archname.$linetoname.scp.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.$linetoname.scp.log >> ${rpath}/m_backup.error
        echo "SCP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "SCP: Files transferred (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "SCP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $scptime / 60`min, `expr $arcsize / $scptime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.$linetoname.scp.log
    ;;
    rsync)
      ${RSYNC} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      rsynctime=`(time -p ${RSYNC} -r -e "ssh -l ${remoteuser}" "${remoteuser}"@"${remotehost}:${remotepath}/*" ${localbackuppath}/backup.tmp 2>/tmp/m_script/$archname.$linetoname.rsync.log) 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      rsynctime=`expr $rsynctime + 1`
      if [ -f /tmp/m_script/$archname.$linetoname.rsync.log ] && [ `cat /tmp/m_script/$archname.$linetoname.rsync.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.$linetoname.rsync.log >> ${rpath}/m_backup.error
        echo "RSYNC: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "RSYNC: Files transferred (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "RSYNC: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $rsynctime / 60`min, `expr $arcsize / $rsynctime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.$linetoname.rsync.log
    ;;
    local)
      ${SCP} "${remoteuser}"@"${remotehost}:${remotepath}/m_backup.*" ${rpath}/
      archname=`cat ${rpath}/m_backup.archname`
      ltime=`(time -p ${SSH} "${remoteuser}"@"${remotehost}" "cp -r ${remotepath}/* ${remotebackuppath}/backup.tmp 2>/tmp/m_script/$archname.$linetoname.local.log") 2>&1 | grep 'real' | cut -d' ' -f2 | cut -d'.' -f1`  #*/
      arcsize=`du -k -c ${localbackuppath} | grep 'total' | cut -f1`
      ltime=`expr $rsynctime + 1`
      if [ -f /tmp/m_script/$archname.$linetoname.local.log ] && [ `cat /tmp/m_script/$archname.$linetoname.local.log | wc -l` -gt 0 ]
      then
        cat /tmp/m_script/$archname.$linetoname.local.log >> ${rpath}/m_backup.error
        echo "CP: There were errors while transferring files, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
        echo "CP: Files transferred (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      else
        echo "CP: Files transferred successfully (`expr $arcsize / 1024`MB, `expr $ltime / 60`min, `expr $arcsize / $ltime`KB/s)" >> ${rpath}/m_backup.log
      fi
      rm -f /tmp/m_script/$archname.$linetoname.local.log
    ;;
    esac
    ${SSH} "${remoteuser}"@"${remotehost}" "rm -f ${remotepath}/m_backup.*"
  fi
# If no direction is set..
  if [ "X$xferdirection" == "X" ]
  then
# ..it means that no --from-remote nor --to-remote options are set either
# Here is the place where other possible options go to.
# Tests for other options are inverted, i.e. if some options ARE set, we do NOT
# make local backups, which should run only if no options set at all.
    if [ "X$nonbackup" == "X" ]
    then
# If no options set at all, we make local backup:

###################
# Local FS backup #
###################

      archname="$(hostname -f)$(date +".%Y.%m.%d_%H.%M")"
      echo "Neither --from-remote nor --to-remote option is set, so this is a local backup." >> ${rpath}/m_backup.log
      echo "Making local backup to ${localbackuppath}/backup.local..." >> ${rpath}/m_backup.log
      while read LINE
      do
        if [ "x${LINE}" != "x" ]
        then
          linetoname=`echo ${LINE} | sed 's|/|_|g'`
          if [[ ${compression} == "gzip" ]]
          then
            tar ${ARCOPTS} -c -z -f ${localbackuppath}/$archname.$linetoname.tar.gz ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log
          fi
          if [[ ${compression} == "bzip2" ]]
          then
            tar ${ARCOPTS} -c -j -f ${localbackuppath}/$archname.$linetoname.tar.bz2 ${LINE} 2>/tmp/m_script/$archname.$linetoname.tar.log
          fi
          if [[ $(grep '^tar:' /tmp/m_script/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read' | wc -l) -gt 0 ]]
          then
            grep '^tar:' /tmp/m_script/$archname.$linetoname.tar.log | grep -v 'Removing leading' | grep -v 'as we read' >> ${rpath}/m_backup.error
            echo "Tar: ${LINE} copied with some errors, see ${localbackuppath}/logs/m_backup.error" >> ${rpath}/m_backup.log
            echo "Tar: ${LINE} copied `grep '^Total bytes written:' /tmp/m_script/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${rpath}/m_backup.log
          else
            echo "Tar: ${LINE} copied successfully `grep '^Total bytes written:' /tmp/m_script/$archname.$linetoname.tar.log | cut -d' ' -f5,6`" >>${rpath}/m_backup.log
          fi
        fi
      done < ${backupconf}.list
    fi
  fi
  rm -f /tmp/m_script/$archname.$linetoname.tar.log
# Copying backups to proper location
  if [ "X$keeplocal" == "Xyes" ] && [ "X$nonbackup" == "X" ]
  then
    if [ "X$debugflag" == "X" ]
    then
      cp -r ${localbackuppath}/* ${localbackuppath}/../backup.local 2>>${rpath}/m_backup.error #*/
    else
      echo "Copying backups to proper (local) location:" >> ${rpath}/m_backup.log
      cp -r -v ${localbackuppath}/* ${localbackuppath}/../backup.local 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log #*/
    fi
  fi
  
#############################
# Removing outdated backups #
#############################

  if [ "X$removeoldlocal" == "Xyes" ]
  then
    [ $keeplocaldays -gt 0 ] && keeplocaldays=`expr $keeplocaldays - 1`
    [ "X$debugflag" == "X" ] || rmv='-v'
    find ${localrmpath} -mtime +$keeplocaldays -type f -print0 | xargs -0 rm "$rmv" -f 2>>${rpath}/m_backup.error >> ${rpath}/m_backup.log && echo "Outdated backups at ${localrmpath} have been removed" >> ${rpath}/m_backup.log
  fi
#  echo "if X\$r_proto=X$r_proto"
  if [ "X$removeoldremote" == "Xyes" ] && [ "X$keepremote" == "Xyes" ] && [ "X$r_proto" != "Xlocal" ] && [ "X${remotehost}" != "X" ]
  then
    case $r_proto in 
    ftp)
      echo "Removing remote files via FTP is not (yet) supported." | tee -a ${rpath}/m_backup.error | tee -a ${rpath}/m_backup.log
    ;;
    s3)
      remotepath1="${remotehost}/${remotepath}"
      while true; do
        `which s3cmd` ls "${remotepath1}" > /tmp/m_script/s3list.$$
        if [ "X$debugflag" != "X" ]; then
          echo "=== In ${remotepath1} `cat /tmp/m_script/s3list.$$|wc -l` objects found" >> ${rpath}/m_backup.log
        fi
        grep DIR /tmp/m_script/s3list.$$ | awk '{print $2}' >> /tmp/m_script/s3dirs.$$
        if [ "X$debugflag" != "X" ]; then
          echo "=== `cat /tmp/m_script/s3dirs.$$|wc -l` are directories" >> ${rpath}/m_backup.log
        fi
        grep -v DIR /tmp/m_script/s3list.$$ >> /tmp/m_script/s3files.$$
        if [ "X$debugflag" != "X" ]; then
          echo "=== `cat /tmp/m_script/s3files.$$|wc -l` are files" >> ${rpath}/m_backup.log
        fi
        for ((i=0; i < $keepremotedays; i++)); do
          d2k=$(date -d "`date +"%Y/%m/%d"` - $i days" +"%Y-%m-%d")
          sed -i -e "/$d2k/d" /tmp/m_script/s3files.$$
        done
        if [ "X$debugflag" != "X" ]; then
          echo "=== `cat /tmp/m_script/s3files.$$|wc -l` files have been marked for removal" >> ${rpath}/m_backup.log
        fi
        for s3file in `cat /tmp/m_script/s3files.$$ | awk '{print $4}'`; do
          `which s3cmd` del "${s3file}" 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log
        done
        if [ `cat /tmp/m_script/s3dirs.$$ | wc -l` -gt 0 ]; then
          remotepath1="`head -1 /tmp/m_script/s3dirs.$$`"
          sed -i -e '1d' /tmp/m_script/s3dirs.$$ 2>>${rpath}/m_backup.error 1>>${rpath}/m_backup.log
          if [ "X$debugflag" != "X" ]; then
            echo "=== Entering $remotepath1 directory" >> ${rpath}/m_backup.log
          fi
          continue
        else
          break
        fi
      done
      rm -f /tmp/m_script/s3dirs.$$ /tmp/m_script/s3files.$$
    ;;
    *)
      SSH=`which ssh`
  #      echo "if \$xferdirection=$xferdirection \|\| X\$onlyclean=X$onlyclean"
      # For --from-remote removing see line 339
      if [ "X$SSH" == "X" ]
      then
        echo "No SSH client found! It is impossible to remove outdated backups on remote hosts." | tee -a ${rpath}/m_backup.error | tee -a ${rpath}/m_backup.log
        exit 1
      fi
      [ $keepremotedays -gt 0 ] && keepremotedays=`expr $keepremotedays - 1`
      ${SSH} "${remoteuser}"@"${remotehost}" "find ${remotepath} -mtime +$keepremotedays -type f" 2>>${rpath}/m_backup.error > /tmp/m_script/remote_files_to_remove.list
      for LINE in `cat /tmp/m_script/remote_files_to_remove.list`
      do
        [ "X$debugflag" == "X" ] || rmv='-v'
        ${SSH} "${remoteuser}"@"${remotehost}" "rm "$rmv" -f \"${LINE}\"" 2>>${rpath}/m_backup.error >> ${rpath}/m_backup.log
      done
      if [ "X@?" == "X0" ]; then
        echo "Outdated backups at ${remotehost}:${remotepath} have been removed" >> ${rpath}/m_backup.log
      else
        echo "Outdated backups at ${remotehost}:${remotepath} have not been removed" >> ${rpath}/m_backup.error
      fi
    ;;
    esac
  fi

#########################
# Reporting and logging #
#########################

  echo "          Backup operations report" > ${rpath}/backup.report
  echo "--------------------------------------------------------------" >> ${rpath}/backup.report
  echo "Date: `date`" >> ${rpath}/backup.report
  if [ "X$nonbackup" == "X" ]; then
    echo "Archive file pattern: ${archname}" >> ${rpath}/backup.report
  fi
  echo "--------------------------------------------------------------" >> ${rpath}/backup.report
  echo "" >> ${rpath}/backup.report
  if [ `grep -c "\*\*\*" ${rpath}/m_backup.error` -ne 0 ]; then
    if [ "X$debugflag" == "X" ]; then
      grep "\*\*\*" ${rpath}/m_backup.error >> ${locallogpath}/logs/m_backup.error
    fi
    echo "*** There were errors during this backup:" >> ${rpath}/backup.report
    for command in "cp scp rsync debug mv rm mysql pgsql ncftpput tar"
    do
      grep -i -m 3 "^${command}" ${rpath}/m_backup.error >> ${rpath}/backup.report
    done
    echo "*** Note that errors shown are limited to 3 errors for every operation" >> ${rpath}/backup.report
    echo "Full error log is available at ${locallogpath}/logs/m_backup.error" >> ${rpath}/backup.report
  fi
  echo "Operations finished:" >> ${rpath}/backup.report
  echo "" >> ${rpath}/backup.report
  cat ${rpath}/m_backup.log >> ${rpath}/backup.report
# Send report by email
  while read LINE
  do
    if [ -n "${LINE}" ]; then
      cat ${rpath}/backup.report | mail -s "Server $(hostname -f) backup report" "${LINE}"
    fi
  done < ${rpath}/conf/mail.backup.list
  
  echo "*** `date` ***" >> ${locallogpath}/logs/m_backup.error
  echo "*** `date` ***" >> ${locallogpath}/logs/m_backup.log
  if [ "X$nonbackup" == "X" ]; then
    echo "*** ${archname} ***" >> ${locallogpath}/logs/m_backup.error
    echo "*** ${archname} ***" >> ${locallogpath}/logs/m_backup.log
  fi
  cat ${rpath}/m_backup.error >> ${locallogpath}/logs/m_backup.error
  cat ${rpath}/m_backup.log >> ${locallogpath}/logs/m_backup.log
  rm -f ${rpath}/m_backup.*
  rm -f /tmp/m_script/$archname*log
### Now it's time to restore some environment variables
  export RSYNC_RSH="${RSYNC_RSH_BK}"
done

